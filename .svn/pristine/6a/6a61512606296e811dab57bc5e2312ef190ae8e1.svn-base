Kevin C. Chang
Query Processing
Database Systems
1
• Logical/physical operators
•Cost parameters and sorting 
•One‐pass algorithms 
• Nested‐loop join 
•Two‐pass algorithms
• Sort‐merge join
• Hash‐based join
• Index‐based algorithms
• Index‐based join
Concepts You Will Learn
Indexing (1 of 66)Default Section (1 of 2)
The Big Picture: Where We Are
Indexing (2 of 66)
Data Access
Data Modeling
Data/Query Processing
Data Acquisition
Relational NonRelational
S
t
r
u
c
t
u
r
e
d
S
e
m
i
S
t
r
u
c
t
u
r
e
d
Transaction Management
N
o
S
Q
L
 
D
a
t
a
b
a
s
e
s
X
M
L
 
D
a
t
a
b
a
s
e
s
U
n
t
r
u
c
t
u
r
e
d
Relational Databases
• SQL
• Relational Algebra
• Query Optimization
• Query Execution
• Indexing
• Concurrency Control
• Logging Recovery
Database Systems Toolkits
M
a
p
 
R
e
d
u
c
e
(
P
a
r
a
l
l
e
l
)
S
t
o
r
m
 
(
S
t
r
e
a
m
)
Information Extraction
ER  Relational Model
Query Language
Query Execution
4
Query compiler
Execution engine
Index/record mgr.
Buffer manager
Storage manager
storage
User/
Application
Query
or update
Query execution
plan
Record, index
requests
Page 
commands
Read/write
pages
• Logical operators
•what they do
• e.g., union, selection, project, join, grouping
•Physical operators
• how they do it
• e.g., nested loop join, sort‐merge join, hash join, index 
join
Logical v.s. Physical Operators
5
Query Execution Plans
6
Purchase Person
Buyer=name
City=‘urbana’ phone>’5430000’
buyer
(Simple Nested Loops)
SELECT S.sname
FROM     Purchase P, Person Q
WHERE  P.buyer=Q.name AND
Q.city=‘urbana’ AND
Q.phone > ‘5430000’ 

Query Plan:
• logical tree
• implementation   
choice at every node
• scheduling of 
operations.
(Table scan) (Index scan)
Some operators are from relational
algebra, and others (e.g., scan, group) are not.
The iterator model.
•Each operation is implemented by 3 functions:
• Open: sets up the data structures and performs 
initializations
• GetNext: returns the the next tuple of the result.
• Close: ends the operations. Cleans up the data structures.
•Enables pipelining!
How do We Combine Operations?
7
•Cost parameters  
•M = number of blocks that fit in main memory
• B(R) = number of blocks holding R
• T(R) = number of tuples in R
• V(R,a) = number of distinct values of the attribute a
•Estimating the cost:
• Important in optimization (next lecture)
• Compute I/O cost only
•We compute the cost to read the tables 
•We don’t compute the cost to write the result (because 
pipelining)
Cost Parameters
8
•Two pass multi‐way merge sort
•Step 1:
• Read M blocks at a time, sort, write
• Result: have runs of length M on disk
•Step 2:
•Merge M‐1 at a time, write to disk
• Result: have runs of length M(M‐1)M2
•Cost: 3B(R),  Assumption: B(R) M2
Sorting
9
•The table is clustered (I.e. blocks consists only of 
records from this table):
• Table‐scan: if we know where the blocks are
• Index scan: if we have index to find the blocks
•The table is unclustered (e.g. its records are placed 
on blocks with other tables)
•May need one read for each record
Scanning Tables
10
•Clustered relation:
• Table scan:  B(R); to sort: 3B(R)
• Index scan:  B(R); to sort: B(R) or 3B(R)
•Unclustered relation
• T(R); to sort: T(R) + 2B(R)
Cost of the Scan Operator
11
Selection (R), projection (R)
•Both are tuple‐at‐a‐Time algorithms
•Cost: B(R)
One‐pass Algorithms
12
Input buffer Output bufferUnary
operator
Duplicate elimination (R)
•Need to keep a dictionary in memory:
• balanced search tree
• hash table
• etc
•Cost: B(R)
•Assumption: B((R)) <= M
One‐pass Algorithms
13
Grouping: city, sum(price) (R)
•Need to keep a dictionary in memory
•Also store the sum(price) for each city
•Cost: B(R)
•Assumption: number of cities fits in memory
One‐pass Algorithms
14
Binary operations: R ∩ S, R U S, R – S
•Assumption: min(B(R), B(S)) <= M
•Scan one table first, then the next, eliminate 
duplicates
•Cost: B(R)+B(S)
One‐pass Algorithms
15
•Tuple‐based nested loop 
•R=outer relation, S=inner relation
for each tuple r in R do
for each tuple s in S do
if r and s join then output (r,s)
•Cost: T(R) T(S),  sometimes T(R) B(S)
Nested Loop Joins
16
•Block‐based Nested Loop Join
for each (M‐1) blocks bs of S do
for each block br of R do
for each tuple s in bs do
for each tuple r in br do
if r and s join then output(r,s)
Nested Loop Joins
17
Nested Loop Joins
18
. . .
. . .
R & S
Blocks of S
(k < M-1 pages)
Input buffer for R Output buffer
. . .
Join Result
