October 21, 2013 
How do we evaluate computer architectures? 
  Think of 5 characteristics that differentiate computers? 
—  Can some processors compute things that others can’t?  
 
October 21, 2013 2 
How do we evaluate computer architectures? 
  Think of 5 characteristics that differentiate computers? 
 
3 
Two notions of performance 
  Which has higher performance? 
  From a passenger’s viewpoint: latency (time to do the task) 
—  hours per flight, execution time, response time 
  From an airline’s viewpoint: throughput (tasks per unit time) 
—  passengers per hour, bandwidth 
  Latency and throughput are often in opposition 
Aircraft DC to Paris Passengers 
747 6 hours 500 
Concorde 3 hours 125 
4 
Some Definitions 
  Relative performance: “x is N times faster than y” 
               Performance(x)  
                           Performance(y) 
  If we are primarily concerned with latency, 
 
Performance(x) =            1                                     
                Latency(x) 
  If we are primarily concerned with throughput, 
 
Performance(x) = throughput(x) 
=    N 
5 
CPU performance 
  The obvious metric: how long does it take to run a test program? This 
depends upon three factors: 
1.  The number of dynamic instructions N in the program 
—  Executing more instructions tends to take longer.  
2.  The kind of instructions in the program 
—  Some instructions take more CPU cycles than others 
—  Let c be the average number of cycles per instruction (CPI) 
3.  The time t per CPU clock cycle (clock-cycle time) 
CPU time  =  Instructions executed × CPI × Clock cycle time 
Seconds 
= 
Instructions 
× 
Clock cycles 
× 
Seconds 
Program Program Instructions Clock cycle 
6 
  Instructions executed: 
—  the dynamic instruction count (#instructions actually executed) 
—  not the (static) number of lines of code 
  Average Cycles per instruction: 
—  function of the machine and program 
•  CPI(floating-point operations) > CPI(integer operations) 
•  Improved processor may execute same instructions in fewer cycles 
—  Single-cycle machine: each instruction takes 1 cycle (CPI = 1) 
•  CPI can be > 1 due to memory stalls and slow instructions 
•  CPI can be < 1 on superscalar machines 
  Clock cycle time: 1 cycle = minimum time it takes the CPU to do any 
work 
—  clock cycle time = 1/ clock frequency 
—  500MHz processor has a cycle time of 2ns (nanoseconds) 
—  2GHz (2000MHz) CPU has a cycle time of just 0.5ns 
—  higher frequency is usually better 
The three components of CPU performance 
7 
 
CPU time  =  Instructions executed × CPI × Clock cycle time 
  Make things faster by making any component smaller! 
  Often easy to reduce one component by increasing another 
 
Execution time, again 
Program Compiler ISA Organization Technology 
Instruction 
Executed 
CPI 
Clock Cycle 
Time 
X
_
_
X
X
_
X
X
X
_
X
X
_
_
X
a) b) c) d) e)
October 21, 2013 Performance 8 
  Let’s compare the performances two x86-based processors. 
—  An 800MHz AMD Duron, with a CPI of 1.2 for an MP3 compressor. 
—  A 1GHz Pentium III with a CPI of 1.5 for the same program. 
  Compatible processors implement identical instruction sets and will use 
the same executable files, with the same number of instructions. 
  But they implement the ISA differently, which leads to different CPIs. 
     CPU timeAMD,P  = InstructionsP * CPIAMD,P * Cycle timeAMD 
  =  
   =  
 
   CPU timeP3,P  = InstructionsP * CPIP3,P * Cycle timeP3 
  =  
   =  
 
 
Example 1: ISA-compatible processors 
October 21, 2013 Performance 9 
Example 2: Comparing across ISAs 
  Intel’s Itanium (IA-64) ISA is designed facilitate executing multiple 
instructions per cycle.  If an Itanium processor achieves an average CPI 
of .3 (3 instructions per cycle), how much faster is it than a Pentium4 
(which uses the x86 ISA) with an average CPI of 1? 
a)  Itanium is three times faster 
b)  Itanium is one third as fast 
c)  Not enough information 
