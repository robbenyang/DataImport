1 
Lab_memory extension to Tuesday, 9/17, 11:59p 
MP2 available, due 9/17, 11:59p. 
 
Same Day, so get one done early! 
 
Announcements 
class sphere { 
public: 
sphere(); 
sphere(double r); 
… 
double getVolume(); 
void setRadius(double r); 
… 
void display(); 
private: 
double theRadius; 
}; 
class ball:public sphere { 
public: 
ball(); 
ball(double r string n); 
… 
string getName(); 
void setName(string n); 
… 
void display(); 
private: 
string name; 
}; 
something to consider: 
void sphere::display() { 
  cout << “sphe e” << endl; 
} 
sphere s; 
ball b; 
s.display(); 
b.display(); 
void ball::display() { 
   cout << “ball” << endl; 
} 
sphere * sptr; 
sptr = &s; 
sptr->display(); 
sphere * sptr; 
sptr = &b; 
sptr->display(); 
e
x
3
 
e
x
2
 
e
x
1
 
class sphere { 
public: 
sphere(); 
sphere(double r); 
… 
double getVolume(); 
void setRadius(double r); 
… 
        void display(); 
private: 
double theRadius; 
}; 
class ball:public sphere { 
public: 
ball(); 
ball(double r string n); 
string getName(); 
 
void setName(string n); 
… 
         void display(); 
private: 
string name; 
}; 
“virtual” functions: 
void sphere::display() { 
  cout << “sphe e” << endl; 
} 
void ball::display() { 
   cout << “ball” << endl; 
} 
if (a==0) 
   sptr = &s; 
else sptr = &b; 
sptr->display(); 
e
x
4
 
virtual functions – the rules: 
 
A virtual method is one a _____________ can override. 
A class’s virtual methods _______ be implemented.  If not, then the 
class is an “abstract base class” and no objects of that type can be 
declared. 
A derived class is not required to override an existing implementation 
of an _____________ virtual method. 
Constructors ____________ be virtual 
Destructors can and ___________virtual 
Virtual method return type ___________ be overwritten. 
Constructors for derived class: 
ball::ball():sphere() 
{ 
   name = “not known”; 
} 
 
ball b; 
ball::ball(double r, string n): 
sphere(r) 
{ 
   name = n; 
} 
 
ball b(0.5,”grape”); 
class Base{ 
public: 
   Base(){cout<<”Ctor: B"<<endl;}  
   ~Base(){cout<<”Dtor: B"<<endl;} 
}; 
class Derived: public Base{ 
public: 
   Derived(){cout<<”Ctor: D"<<endl;}  
   ~Derived(){cout<<”Dtor: D"<<endl;} 
}; 
“virtual” destructors: 
void main(){ 
   Base * V = new Derived();  
   delete V; 
} 
class flower { 
public: 
flower(); 
virtual void drawBlossom() = 0; 
virtual void drawStem() = 0; 
virtual void drawFoliage() = 0; 
… 
}; 
class daisy:public flower { 
public: 
virtual void drawBlossom(); 
virtual void drawStem(); 
virtual void drawFoliage(); 
… 
private: 
int blossom; // number of petals 
int stem; // length of stem 
int foliage // leaves per inch 
}; 
Abstract Base Classes: 
void daisy::drawBlossom() { 
// whatever 
} 
void daisy::drawStem() { 
// whatever 
} 
void daisy::drawFoliage() { 
// whatever 
} 
flower f; 
daisy d; 
flower * fptr; 
 
 
 
Concluding remarks on inheritance: 
 
Polymorphism:  objects of different types can employ methods of the same 
name and parameterization. 
 
 
 
 
 
 
 
 
Inheritance provides DYNAMIC polymorphism—type dependent functions can 
be selected at run-time.  Wikipedia: Polymorphism in OOP 
Next topic:  “templates” are C++ implementation of static polymorphism, 
where type dependent functions are chosen at compile-time. 
animal ** farm; 
 
farm = new animal*[5]; 
farm[0] = new dog; 
farm[1] = new pig; 
farm[2] = new horse; 
farm[3] = new cow; 
farm[4] = new duck; 
 
for (int i=0; i<5;i++) 
    farm[i]->speak(); 
