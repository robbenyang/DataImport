1 
MP5 available, due 11/11, 11:59p. EC due 10/25, 11:59p. 
 
Where do you compile? 
 
How could you rely less on EWS? 
 
 
 
 
Announcements 
Height balance 
The “height balance” of a tree T is:  
b = height(TL) - height(TR) 
A tree T is “height balanced” if: 
• T = {} OR 
• T = {r, TL, TR}, |b| ___  and TL and TR are ht balanced. 
  50 
  70 
  90 
 50 
  70 
  90 
struct treeNode { 
   T key; 
   D data; 
   int height; 
   treeNode * left; 
   treeNode * right; 
}; 
operations on BST - rotations 
50 
90 
99 
95 
80 
60 
85 
40 20 
30 
balanced trees - rotations 
  70 
  60 
  80 
  50   20 
  40 
balanced trees - rotations 
70 
60 
80 
50 20 
40 
GOAL:  use rotations to maintain balance of BSTs. 
height balanced trees - we have a special name: 
 
Three issues to consider as we move toward implementation:   
Rotating 
Maintaining height 
Detecting imbalance 6 
balanced trees - rotations summary: 
• there are 4 kinds: left, right, left-right, right-left (symmetric!) 
• local operations (subtrees not affected) 
• constant time operations 
• BST characteristic maintained 
8 
4 
6 
5 
9 12 
10 
3 
1 11 
2 
Maintaining height upon a rotation: 
AVL trees: rotations (identifying the need) 
t1 
t2 
t3 t4 
If an imbalance is detected at t, and if 
an insertion was in subtrees t3 or 
t4, then a __________ rotation 
about t rebalances the tree. 
 
We gauge this by noting that the 
balance factor at t->right is _____ 
t 
AVL trees: rotations (identifying the need) 
t1 
t2 
t3 
t4 
If an imbalance is detected at t, and if 
an insertion was in subtrees t2 or 
t3, then a ____________ rotation 
about t rebalances the tree. 
 
We gauge this by noting that the 
balance factor at t->right is _____ 
t 
AVL trees: 
struct treeNode { 
   T key; 
   D data; 
   int height; 
   treeNode * left; 
   treeNode * right; 
}; 
Insert: 
insert at proper place 
check for imbalance 
rotate if necessary 
update height 
AVL tree insertions: 
template <class T> 
void AVLTree<T>::insert(const T & x, treeNode<T> * & t ){ 
   if( t == NULL ) t = new treeNode<T>( x, 0, NULL, NULL); 
   else if( x < t->key ){ 
      insert( x, t->left ); 
      int balance = height(t->right)-height(t->left); 
      int leftBalance = height(t->left->right)-height(t->left->left); 
      if( balance == -2 ) 
         if( leftBalance == -1 ) 
            rotate_____________( t ); 
         else 
            rotate_____________( t ); 
   } 
   else if( x > t->key ){ 
      insert( x, t->right ); 
      int balance = height(t->right)-height(t->left); 
      int rightBalance = height(t->right->right)-height(t->right->left); 
      if( balance == 2 ) 
         if( rightBalance == 1 ) 
            rotate_____________( t ); 
         else 
            rotate_____________( t ); 
      } 
   t->height=max(height(t->left ), height(t->right))+ 1; 
} 
