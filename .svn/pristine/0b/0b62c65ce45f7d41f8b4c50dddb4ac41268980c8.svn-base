Kevin C. Chang
Indexing
Database Systems
• Index– what is?
• Clustered/unclustered indexes.
• Dense/sparse indexes.
• Primary/secondary indexes.
• B+ trees
• Search, insertion, deletion on B+ trees.
• Hash tables 
• Extensible hash tables
• Search, insertion, deletion
• Linear hash tables
• Search, insertion, deletion
Concepts You Will Learn
Indexing (1 of 66)Default Section (1 of 2)
The Big Picture: Where We Are
Indexing (2 of 66)
Default Section (2 of 2)
Query Executor
Buffer Manager
Storage Manager
Tables, Indexes
Query Optimizer
Query Parser/Rewriter
Access Manager
Web/Mobile/Console Applications
S
Q
L
R
e
l
a
t
i
o
n
a
l
 
A
l
g
e
b
r
a
B
+
T
r
e
e
H
a
s
h
E
R
Transaction
Manager
Concurrency 
Control
Logging/
Recovery
Relational NonRelational
Information Extraction
XML 
Databases
Map Reduce
NoSQL 
Databases
Structured SemiStructured
Why Do We Learn This?
Indexing (3 of 66)Why Do We Learn This? (0 of 0)
Index: What, Why, and How?
Indexing (4 of 66)Index: What, Why, and How? (0 of 14)
• To build an index.
• But what is an index? 
• Examples in the real world?
Q: What is “indexing”? 
Indexing (5 of 66)Index: What, Why, and How? (1 of 14)
What is “indexing”? 
Indexing (6 of 66)Index: What, Why, and How? (2 of 14)
•An index on a file speeds up selections on the search key 
field(s) 
•Search key = any subset of the fields of a relation
• Search key is not the same as key (minimal set of fields that 
uniquely identify a record in a relation).
•Entries in an index: (k, r), where:
• k = the key
• r = the record OR record id OR record ids
Indexes
Indexing (7 of 66)Index: What, Why, and How? (3 of 14)
•Clustered/unclustered
• Clustered = records sorted in the key order
• Unclustered = no
•Dense/sparse
• Dense = each record has an entry in the index
• Sparse = only some records have
•Primary/secondary
• Primary = on the primary key
• Secondary = on any key
• Some textbooks interpret these differently
•B+ tree / Hash table / …
Types of Indexes
Indexing (8 of 66)Index: What, Why, and How? (4 of 14)
• Clustered: File is sorted on the index attribute
• Dense: sequence of (key,pointer) pairs
Ex: Clustered, Dense Index
Indexing (9 of 66)
10
20
30
40
50
60
70
80
10
20
30
40
50
60
70
80
Index: What, Why, and How? (5 of 14)
• Sparse index: one key per data block
Clustered, Sparse Index
Indexing (10 of 66)
10
30
50
70
90
110
130
150
10
20
30
40
50
60
70
80
Index: What, Why, and How? (6 of 14)
How if duplicate keys?
Indexing (11 of 66)Index: What, Why, and How? (7 of 14)
• Dense index: point to the first record with that key
Clustered Index with Duplicate Keys
Indexing (12 of 66)
10
20
30
40
50
60
70
80
10
10
10
20
20
20
30
40
Index: What, Why, and How? (8 of 14)
• Sparse index: pointer to lowest search key in each block:
• OK? 
Try search for 20
Clustered Index with Duplicate Keys
Indexing (13 of 66)
10
10
20
30
10
10
10
20
20
20
30
40
Index: What, Why, and How? (9 of 14)
• Better: pointer to lowest new search key in each block:
• Search for 20
Clustered Index with Duplicate Keys
Indexing (14 of 66)
10
20
30
40
50
60
70
80
10
10
10
20
30
30
40
50
Index: What, Why, and How? (10 of 14)
• Often for indexing other attributes than primary key
• Always dense (why ?)
Unclustered Indexes
Indexing (15 of 66)
10
10
20
20
20
30
30
30
20
30
30
20
10
20
10
30
Index: What, Why, and How? (11 of 14)
Summary Clustered vs. Unclustered Index
Indexing (16 of 66)
Data entries
(Index File)
(Data file)
Data Records
Data entries
Data Records
CLUSTERED UNCLUSTERED
Index: What, Why, and How? (12 of 14)
Composite Search Keys
• Composite Search Keys: Search 
on a combination of fields.
• Equality query: Every field 
value is equal to a constant 
value. E.g. wrt <sal,age> index:
• age=20 and sal =75
• Range query: Some field value 
is not a constant. E.g.:
• age =20; or age=20 and sal > 10
Indexing (17 of 66)
sue 13 75
bob
cal
joe 12
10
20
8011
12
name age sal
<sal, age>
<age, sal> <age>
<sal>
12,20
12,10
11,80
13,75
20,12
10,12
75,13
80,11
11
12
12
13
10
20
75
80
Data records
sorted by name
Data entries in index
sorted by <sal,age>
Data entries
sorted by <sal>
Examples of composite key
indexes using lexicographic order.
Index: What, Why, and How? (13 of 14)
• How many indexes? Where?
• What are keys? What are records?
• Clustered?
• Dense?
• Primary?
Q: Our textbook as example: Indexes? 
Indexing (18 of 66)Index: What, Why, and How? (14 of 14)
B+ Trees
Indexing (19 of 66)B+ Trees (0 of 26)
Kevin C. Chang
B+ Trees
Indexing (20 of 66)
What’s wrong with sequential index?
B+ Trees (1 of 26)
B‐Trees/B+Trees: B_ ?_ _? _ _ Trees
• Intuition:
• Give up on sequentiality of index
• Try to get “balance” by dynamic reorganization
• B+trees:
• Textbook refers to B+trees (a popular variant) as B‐trees (as most people do)
• Distinction will be clear later (ok to confuse now)
Indexing (21 of 66)B+ Trees (2 of 26)
Behind the Scene: 
UIUC (Alumni) Contribution!
Prof. Rudolf Bayer
Rudolf Bayer studied Mathematics in Munich and at the University of Illinois, 
where he received his Ph.D. in 1966. After working at Boeing Research Labs he 
became an Associate Professor at Purdue University. He is a Professor of 
Informatics at the Technische Universität München since 1972 and … …
The 2001 SIGMOD Innovations Award goes to Prof. Rudolf Bayer of the Technical 
University of Munich, for his invention of the B‐Tree (with Edward M. 
McCreight), of B‐Tree prefix compression, and of lock coupling (a.k.a. crabbing) 
for concurrent access to B‐Trees (with Mario Schkolnick). All of these techniques 
are widely used in commercial database products. ……
The Original Publication
Rudolf Bayer, Edward M. McCreight: Organization and Maintenance of 
Large Ordered Indices. Acta Informatica 1: 173-189(1972)
Indexing (22 of 66)B+ Trees (3 of 26)
Behind the Scene: And he said Hello!
Indexing (23 of 66)B+ Trees (4 of 26)
• Parameter d = the degree
• Each node has [d, 2d] keys (except root)
• Internal node:
• Leaf:
B+ Trees Basics
Indexing (24 of 66)
30 120 240
[X , 30) [30, 120) [120, 240) [240, Y)
40 50 60
40 50 60
next leaf
B+ Trees (5 of 26)
B+ Tree Example
Indexing (25 of 66)
80
20 60 100 120 140
10 15 18 20 30 40 50 60 65 80 85 90
10 15 18 20 30 40 50 60 65 80 85 90
d = 2
B+ Trees (6 of 26)
• How large d ?
• Example:
• Key size = 4 bytes
• Pointer size = 8 bytes
• Block size = 4096 byes
• 2d x 4  + (2d+1) x 8  <=  4096
• d = 170
B+ Tree Design
Indexing (26 of 66)B+ Trees (7 of 26)
• Exact key values:
• Start at the root
• Proceed down, to the leaf
• Range queries:
• As above
• Then sequential traversal
Searching a B+ Tree
Indexing (27 of 66)
Select name
From people
Where age = 25
Select name
From people
Where 20 <= age
and  age <= 30
B+ Trees (8 of 26)
•Typical order: 100.  Typical fill‐factor: 67%.
• average fanout = 133
•Typical capacities:
• Height 4: 1334 = 312,900,700 records
• Height 3: 1333 =     2,352,637 records
•Can often hold top levels in buffer pool:
• Level 1 =           1 page  =     8 Kbytes
• Level 2 =      133 pages =     1 Mbyte
• Level 3 = 17,689 pages = 133 MBytes       
B+ Trees in Practice
Indexing (28 of 66)B+ Trees (9 of 26)
Insert (K, P)
• Find leaf where K belongs, insert
• If no overflow (2d keys or less), halt
• If overflow (2d+1 keys), split node, insert in parent:
• If leaf, keep K3 too in right node
•When root splits, new root has 1 key only 
• that’s why root is special for degree satisfaction
Insertion in a B+ Tree
Indexing (29 of 66)
K1 K2 K3 K4 K5
P0 P1 P2 P3 P4 p5
K1 K2
P0 P1 P2
K4 K5
P3 P4 p5
(K3,    ) to parent
B+ Trees (10 of 26)
Insertion in a B+ Tree
Indexing (30 of 66)
80
20 60 100 120 140
10 15 18 20 30 40 50 60 65 80 85 90
10 15 18 20 30 40 50 60 65 80 85 90
Insert K=19
B+ Trees (11 of 26)
Insertion in a B+ Tree
Indexing (31 of 66)
80
20 60 100 120 140
10 15 18 19 20 30 40 50 60 65 80 85 90
10 15 18 20 30 40 50 60 65 80 85 9019
After insertion
B+ Trees (12 of 26)
Insertion in a B+ Tree
Indexing (32 of 66)
80
20 60 100 120 140
10 15 18 19 20 30 40 50 60 65 80 85 90
10 15 18 20 30 40 50 60 65 80 85 9019
Now insert 25
B+ Trees (13 of 26)
Insertion in a B+ Tree
Indexing (33 of 66)
80
20 60 100 120 140
10 15 18 19 20 25 30 40 50 60 65 80 85 90
10 15 18 20 25 30 40 60 65 80 85 9019
After insertion
50
B+ Trees (14 of 26)
Insertion in a B+ Tree
Indexing (34 of 66)
80
20 60 100 120 140
10 15 18 19 20 25 30 40 50 60 65 80 85 90
10 15 18 20 25 30 40 60 65 80 85 9019
But now have to split !
50
B+ Trees (15 of 26)
Insertion in a B+ Tree
Indexing (35 of 66)
80
20 30 60 100 120 140
10 15 18 19 20 25 60 65 80 85 90
10 15 18 20 25 30 40 60 65 80 85 9019
After the split
50
30 40 50
B+ Trees (16 of 26)
Deletion from a B+ Tree
Indexing (36 of 66)
80
20 30 60 100 120 140
10 15 18 19 20 25 60 65 80 85 90
10 15 18 20 25 30 40 60 65 80 85 9019
Delete 30
50
30 40 50
B+ Trees (17 of 26)
Deletion from a B+ Tree
Indexing (37 of 66)
80
20 30 60 100 120 140
10 15 18 19 20 25 60 65 80 85 90
10 15 18 20 25 40 60 65 80 85 9019
After deleting 30
50
40 50
May change to 
40, or not
B+ Trees (18 of 26)
Deletion from a B+ Tree
Indexing (38 of 66)
80
20 30 60 100 120 140
10 15 18 19 20 25 60 65 80 85 90
10 15 18 20 25 40 60 65 80 85 9019
Now delete 25
50
40 50
B+ Trees (19 of 26)
Deletion from a B+ Tree
Indexing (39 of 66)
80
20 30 60 100 120 140
10 15 18 19 20 60 65 80 85 90
10 15 18 20 40 60 65 80 85 9019
After deleting 25
Need to rebalance
Rotate
50
40 50
B+ Trees (20 of 26)
Deletion from a B+ Tree
Indexing (40 of 66)
80
19 30 60 100 120 140
10 15 18 19 20 60 65 80 85 90
10 15 18 20 40 60 65 80 85 9019
Now delete 40
50
40 50
B+ Trees (21 of 26)
Deletion from a B+ Tree
Indexing (41 of 66)
80
19 30 60 100 120 140
10 15 18 19 20 60 65 80 85 90
10 15 18 20 60 65 80 85 9019
After deleting 40
Rotation not possible
Need to merge nodes
50
50
B+ Trees (22 of 26)
Deletion from a B+ Tree
Indexing (42 of 66)
80
19 60 100 120 140
10 15 18 19 20 50 60 65 80 85 90
10 15 18 20 60 65 80 85 9019
Final tree
50
B+ Trees (23 of 26)
• Idea:
• Avoid duplicate keys
• Have record pointers in non‐leaf nodes
•Note: Textbook’s B‐Tree means B+‐tree!
Variation on B+tree: B‐tree (no +)
Indexing (43 of 66)B+ Trees (24 of 26)
to record to record to record
with K1 with K2 with K3
to keys to keys to keys to keys
< K1 K1<x<K2 K2<x<k3 >k3
Indexing (44 of 66)
K1 P1 K2 P2 K3 P3
B+ Trees (25 of 26)
B‐tree example n=2
Indexing (45 of 66)
6
5
1
2
5
1
4
5
1
6
5
8
5
1
0
5
2
5
4
5
1
0
2
0
3
0
4
0
1
1
0
1
2
0
9
0
1
0
0
7
0
8
0
1
7
0
1
8
0
5
0
6
0
1
3
0
1
4
0
1
5
0
1
6
0
• Sequence pointers not useful now! 
B+ Trees (26 of 26)
Hash Tables
Indexing (46 of 66)Hash Tables (0 of 20)
• Secondary storage hash tables are much like main memory ones
• Recall basics:
• There are n buckets
• A hash function f(k) maps a key k to {0, 1, …, n‐1}
• Store in bucket f(k) a pointer to record with key k
• Secondary storage: bucket = block, use overflow blocks when needed
Hash Tables
Indexing (47 of 66)Hash Tables (1 of 20)
• Assume 1 bucket (block) stores 2 keys + pointers
• h(e)=0
• h(b)=h(f)=1
• h(g)=2
• h(a)=h(c)=3
Hash Table Example
Indexing (48 of 66)
e
b
f
g
a
c
0
1
2
3
Hash Tables (2 of 20)
• Search for a:
• Compute h(a)=3
• Read bucket 3
• 1 disk access
Searching in a Hash Table
Indexing (49 of 66)
e
b
f
g
a
c
0
1
2
3
Hash Tables (3 of 20)
• Place in right bucket, if space
• E.g. h(d)=2
Insertion in Hash Table
Indexing (50 of 66)
e
b
f
g
d
a
c
0
1
2
3
Hash Tables (4 of 20)
• Create overflow block, if no space
• E.g. h(k)=1
• More over‐
flow blocks
may be needed
Insertion in Hash Table
Indexing (51 of 66)
e
b
f
g
d
a
c
0
1
2
3
k
Hash Tables (5 of 20)
• Excellent, if no overflow blocks
• Degrades considerably when number of keys exceeds the number of 
buckets (I.e. many overflow blocks).
Hash Table Performance
Indexing (52 of 66)Hash Tables (6 of 20)
• Allows hash table to grow, to avoid performance degradation
• Assume a hash function h that returns numbers in {0, …, 2k – 1}
• Start with n = 2i << 2k , only look at first i most significant bits
Extensible Hash Table
Indexing (53 of 66)Hash Tables (7 of 20)
• E.g. i=1, n=2, k=4
• Note: we only look at the first bit (0 or 1)
Extensible Hash Table
Indexing (54 of 66)
0(010)
1(011)
i=1 1
1
0
1
Hash Tables (8 of 20)
• Insert 1110
Insertion in Extensible Hash Table
Indexing (55 of 66)
0(010)
1(011)
1(110)
i=1 1
1
0
1
Hash Tables (9 of 20)
• Now insert 1010
• Need to extend table, split blocks
• i becomes 2
Insertion in Extensible Hash Table
Indexing (56 of 66)
0(010)
1(011)
1(110), 1(010)
i=1 1
1
0
1
Hash Tables (10 of 20)
• Now insert 1010 (cont.)
Insertion in Extensible Hash Table
Indexing (57 of 66)
0(010)
10(11)
10(10)
i=2 1
2
00
01
10
11
11(10) 2
Hash Tables (11 of 20)
• Now insert 0000, then 0101
• Need to split block
Insertion in Extensible Hash Table
Indexing (58 of 66)
0(010)
0(000), 0(101)
10(11)
10(10)
i=2 1
2
00
01
10
11
11(10) 2
Hash Tables (12 of 20)
• After splitting the block
Insertion in Extensible Hash Table
Indexing (59 of 66)
00(10)
00(00)
10(11)
10(10)
i=2
2
2
00
01
10
11
11(10) 2
01(01) 2
Hash Tables (13 of 20)
• No overflow blocks: access always one read
• BUT:
• Extensions can be costly and disruptive
• After an extension table may no longer fit in memory
Performance Extensible Hash Table
Indexing (60 of 66)Hash Tables (14 of 20)
• Idea: extend only one entry at a time
• Problem: n= no longer a power of 2
• Let i be #bits necessary to address n buckets.
• 2i‐1 < n <= 2i
• After computing h(k), use last i bits:
• If last i bits represent a number >= n, change msb from 1 to 0 (get a number 
< n)
Linear Hash Table
Indexing (61 of 66)Hash Tables (15 of 20)
• N=3
Linear Hash Table Example
Indexing (62 of 66)
(01)00
(11)00
(10)10
i=2
00
01
10
(01)11 BIT FLIP
Hash Tables (16 of 20)
• Insert 1000: overflow blocks…
Linear Hash Table Example
Indexing (63 of 66)
(01)00
(11)00
(10)10
i=2
00
01
10
(01)11
(10)00
Hash Tables (17 of 20)
• Extension: independent on overflow blocks
• Extend n:=n+1 when average number of records per block exceeds 
(say) 80%
Linear Hash Tables
Indexing (64 of 66)Hash Tables (18 of 20)
•From n=3 to n=4
•Only need to touch
one block (which one ?)
Linear Hash Table Extension
Indexing (65 of 66)
(01)00
(11)00
(10)10
i=2
00
01
10
(01)11
(01)11
(01)11
i=2
00
01
10
(10)10
(01)00
(11)00
11
Hash Tables (19 of 20)
• From n=3 to n=4 finished
• Extension from n=4
to n=5 (new bit)
• Need to touch every
single block (why ?)
Linear Hash Table Extension
Indexing (66 of 66)
(01)11
i=2
00
01
10
(10)10
(01)00
(11)00
11
Hash Tables (20 of 20)
