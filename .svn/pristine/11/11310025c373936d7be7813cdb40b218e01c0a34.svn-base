1 Inductive Proofs for DFAs
1.1 Properties about DFAs
Deterministic Behavior
Proposition 1. For a DFA M = (Q,Σ, δ, q0, F ), and any q ∈ Q, and w ∈ Σ∗, |δˆM (q, w)| = 1.
Proof. Proof is by induction on |w|. Thus, Si is taken to be
For every q ∈ Q, and w ∈ Σi, |δˆM (q, w)| = 1.
Base Case: We need to prove the case when w ∈ Σ0. Thus, w = . By definition w−→M , q w−→M q′
if and only q′ = q. Thus, |δˆM (q, w)| = |{q}| = 1.
Ind. Hyp.: Suppose for every q ∈ Q, and w ∈ Σ∗ such that |w| < i, |δˆM (q, w)| = 1.
Ind. Step: Consider (without loss of generality) w = a1a2 · · · ai, such that ai ∈ Σ. Take u =
a1 · · · ai−1
q
w−→M q′ iff there are r0, r1, . . . , ri such that r0 = q, ri = q′, and δ(rj , aj+1) = rj+1
iff there is ri−1 such that q
u−→M ri−1 and δ(ri−1, ai) = q′
Now, by induction hypothesis, since |δˆM (q, u)| = 1, there is a unique ri−1 such that q u−→M
ri−1. Also, since from any state ri−1 on symbol ai the next state is uniquely determined,
|δˆM (q, w)| = 1.
DFA Computation
Proposition 2. Let M = (Q,Σ, δ, q0, F ) be a DFA. For any q1, q2 ∈ Q, u, v ∈ Σ∗, q1 uv−→M q2 iff
there is q ∈ Q such that q1 u−→M q and q v−→M q2.
Proof. Let u = a1a2 . . . ai and v = ai+1 · · · ai+k. Observe that,
q1
uv−→M q2 iff there are r0, r1, . . . , ri+k such that r0 = q1, ri+k = q2, and δ(rj , aj+1) = rj+1
iff there is ri (= q of the proposition) such that q1
u−→M ri and ri v−→M q2
Conventions in Inductive Proofs
“We will prove by induction on |v|” is a short-hand for “We will prove the proposition by induction.
Take Si to be statement of the proposition restricted to strings v where |v| = i.”
1
1.2 Proving Correctness of DFA Constructions
Proving Correctness of DFAs
Problem
Show that DFA M recognizes language L.
That is, we need to show that for all w, w ∈ L(M) iff w ∈ L. This is often carried out by
induction on |w|.
Example I
q0 q1
0 0
1
1
Figure 1: Transition Diagram of M1
Proposition 3. L(M1) = {w ∈ {0, 1}∗ | w has an odd number of 1s}
Proof. We will prove this by induction on |w|. That is, let Si be
For all w ∈ {0, 1}i. M1 accepts w iff w has an odd number of 1s
Observe that M1 accepts w iff q0
w−→M1 q1. So we could rewrite Si as
For all w ∈ {0, 1}i. q0 w−→M1 q1 iff w has an odd number of 1s
Base Case: When w = , w has an even number of 1s. Further, q0
−→M1 q0, and so M1 does not
accept w.
Ind. Hyp.: Assume that for all w of length < n, q0
w−→M1 q1 iff w has an odd number of 1s.
Ind. Step: Consider w of length n; without loss of generality, w is either 0u or 1u for some string
u of length i− 1.
If w = 0u then, w has an odd number of 1s iff u has an odd number of 1s, iff (by ind. hyp.)
q0
u−→M1 q1 iff q0 w=0u−→M1 q1 (since δ(q0, 0) = q0).
On the other hand, if w = 1u then, w has an odd number of 1s iff u has an even number
of 1s. Now q0
w=1u−→M1 q1 iff q1 u−→M1 q1. Does M1 accept u that has an even number of
0s from state q1? Unfortunately, we cannot use the induction hypothesis in this case, as the
hypothesis does not say anything about what strings u are accepted when the automaton is
started from state q1; it only gives the behavior on strings when M1 is started in the initial
state q0. We need to strengthen the hypothesis to make the proof work!! The strengthening
will explicitly tell us the behavior of the machine on strings when starting from states other
than the initial state.
2
New (correct) induction proof: Let Si be
∀w ∈ {0, 1}i. q0 w−→M1 q1 iff w has an odd number of 1s
and q1
w−→M1 q1 iff w has an even number of 1s
We will prove this sequence of statements by induction.
Base Case: When w = , w has an even number of 1s. Further, q0
−→M1 q0 and q1 w−→M1 q1,
and so M1 does not accept w from state q0, but accepts w from state q1. This establishes the
base case.
Ind. Hyp.: Assume that for all w of length < n, q0
w−→M1 q1 iff w has an odd number of 1s and
q1
w−→M1 q1 iff w has an even number of 1s.
Ind. Step: Consider w of length n; without loss of generality, w is either 0u or 1u for some string
u of length i− 1.
If w = 0u then q0
0u−→M1 q1 iff q0 u−→M1 q1 (because δ(q0, 0) = q0) iff u has an odd number of
1s (by ind. hyp.) iff w = 0u has an odd number of 1s. Similarly, q1
0u−→M1 q1 iff q1 u−→M1 q1
(because δ(q1, 0) = q1) iff u has an even number of 1s iff w = 0u has an even number of 1s.
On the other hand, if w = 1u then q0
w=1u−→M1 q1 iff q1 u−→M1 q1 (since δ(q0, 1) = q1) iff
(by ind. hyp.) u has an even number of 1s iff w = 1u has an odd number of 1s. Similarly,
q1
w=1u−→M1 q1 iff q0 u−→M1 q1 (since δ(q1, 1) = q0) iff (by ind. hyp.) u has an odd number of
1s iff w has an even number of 1s.
Remark
The above induction proof can be made to work without strengthening if in the first induction proof
step, we considered w = ua, for a ∈ {0, 1}, instead of w = au as we did. However, the fact that
the induction proof works without strengthening here is a very special case, and does not hold in
general for DFAs.
Example II
q0 q1
q2q3
1
1
1
1
0 0 0 0
Figure 2: Transition Diagram of M2
Proposition 4. L(M2) = {w ∈ {0, 1}∗ | w has an odd number of 1s and odd number of 0s}
3
Proof. We will once again prove the proposition by induction on |w|. The straightforward proof
would suggest that we take Si to be
For any w ∈ {0, 1}i. M2 accepts w iff w has an odd number of 1s and 0s
Since M2 accepts w iff q0
w−→M2 q2, we could rewrite the condition as “q0 w−→M2 q2 iff w has an odd
number of 1s and 0s”. The induction proof will unfortunately not go through! To see this, consider
the induction step, when w = 0u. Now, q0
w−→M2 q iff q3 u−→M2 q, because M2 goes to state q3
(from q0) on reading 0. Since w and u have the same parity for the number of 1s, but opposite
parity for the number of 0s, w must be accepted (i.e., reach state q2) iff u is accepted from q3 when
u has an odd number of 1s and even number of 0s. But is that the case? The induction hypothesis
says nothing about strings accepted from state q3, and so the induction step cannot be established.
This is typical of many induction proofs. Again, we must strengthen the proposition in order to
construct a proof. The proposition must not only characterize the strings that are accepted from
the initial state q0, but also those that are accepted from states q1, q2, and q3.
We will show by induction on w that
(a) q0
w−→M2 q2 iff w has an odd number of 0s and odd number of 1s,
(b) q1
w−→M2 q2 iff w has odd number of 0s and even number of 1s,
(c) q2
w−→M2 q2 iff w has an even number of 0s and even number of 1s, and
(d) q3
w−→M2 q2 iff w has even number of 0s and odd number of 1s.
Thus in the our new induction proof, statement Si says that conditions (a),(b),(c), and (d) hold
for all strings of length i.
Base Case: When |w| = 0, w = . Observe that w has an even number of 0s and 1s, and q −→M2 q
for any state q. String  is only accepted from state q2, and thus statements (a),(b),(c), and
(d) hold in the base case.
Ind. Hyp.: Suppose (a),(b),(c),(d) all hold for any string w of length < n.
Ind. Step: Consider w of length n. Without loss of generality, w is of the form au, where a ∈ {0, 1}
and u ∈ {0, 1}n−1.
• Case q = q0, a = 0: q0 0u−→M2 q2 iff q3 u−→M2 q2 iff u has even number of 0s and odd
number of 1s (by ind. hyp. (d)) iff w has odd number of 0s and odd number of 1s.
• Case q = q0, a = 1: q0 1u−→M2 q2 iff q1 u−→M2 q2 iff u has odd number of 0s and even
number of 1s (by ind. hyp. (b)) iff w has odd number of 0s and odd number of 1s
• Case q = q1, a = 0: q1 0u−→M2 q2 iff q2 u−→M2 q2 iff u has even number of 0s and even
number of 1s (by ind. hyp. (c)) iff w has odd number of 0s and even number of 1s
• . . . And so on for the other cases of q = q1 and a = 1, q = q2 and a = 0, q = q2 and
a = 1, q = q3 and a = 0, and finally q = q3 and a = 1.
4
Proving Correctness of a DFA
Proof Template
Given a DFA M having n states {q0, q1, . . . qn−1} with initial state q0, and final states F , to prove
that L(M) = L, we do the following.
1. Come up with languages L0, L1, . . . Ln−1 such that L0 = L
2. Prove by induction on |w|, δˆM (qi, w) ∩ F 6= ∅ if and only if w ∈ Li
2 Proving DFA Lower Bounds
Even length strings with at least 2 as
Problem
Design an automaton for the language L≥2aeven = {w ∈ {a, b}∗ | w has even length and contains at
least 2 as}.
Solution
What do you need to remember? We need to remember the numbers of as we have seen (either
0, 1, or ≥ 2), and the parity (odd or even) of the number of symbols we have seen. So the states
will be 〈0, e〉 (no as seen, and even number of total symbols), 〈0, o〉 (no as seen and total symbols
seen is odd), 〈1, e〉 (one a seen and even number of symbols), 〈1, o〉 (one a seen and odd number of
symbols), 〈2, e〉 (at least 2 as seen and even number of total symbols), and 〈2, o〉 (at least 2 as seen
and an odd number of symbols). The DFA is as follows.
〈0, e〉
〈0, o〉
〈1, e〉
〈1, o〉
〈2, e〉
〈2, o〉
b b a
a
b b a
a
a, b a, b
Figure 3: DFA recognizing L≥2aeven
Tightness of DFA construction
5
Proposition 5. Any DFA recognizing L≥2aeven has at least 6 states.
Proof Idea
We will identify 6 strings w1, w2, w3, w4, w5, w6 that must take any DFA recognizing L
≥2a
even to dif-
ferent states.
• How do we find such strings? Based on our intuition of what the DFA must remember in
order to solve the problem.
• How do we prove that they must go to different states? We will argue that if some pair of
strings (say wi and wj) go to the same state in some DFA M , then M cannot recognize the
language L≥2aeven. The crux of the argument is as follows. Suppose M ends up in the same state
(say q) after reading wi and wj . Since the DFA behavior only depends on the current state
(and not on how the current state was reached), M will give the same answer (either accept
or reject) on strings wiu and wju, no matter what u is. Now, if we find a string u such that
wiu ∈ L≥2aeven and wju 6∈ L≥2aeven then M gives an answer on wiu and wju (either both accept or
both reject) that is inconsistent with what the problem L≥2aeven requires it to do.
We are now ready to formally prove the proposition based on the above idea.
Proof. Consider the strings w1 = , w2 = b, w3 = a, w4 = ab, w5 = aa, w6 = aab. Our intuition
tells us that a DFA recognizing L≥2aeven must remember different things for each of these strings: for
w1 the fact that we have seen no as and an even number of symbols; for w2 the fact that we have
seen no as but an odd number of symbols; for w3 the fact that we have seen an a and an odd
number of symbols; for w4 the fact that we have seen an a and an even number of symbols; for w5
the fact that we have seen at least 2 as and an even number of symbols; for w6 the fact that we
have seen at least 2 as and an odd number of symbols.
Suppose (for contradiction) the proposition does not hold. That is, there is a DFA M with < 6
states that recognizes L≥2aeven. Let the initial state of M be (say) q0. Now, by pigeon hole principle,
there must be two strings wi, wj ∈ {w1, w2, w3, w4, w5, w6} such that M , starting in state q0, goes
to the same state on both wi and wj , i.e., for some q, δˆM (q0, wi) = {q} = δˆM (q0, wj). We will show
that then M cannot recognize L≥2aeven, contradicting our assumption that M does recognize L≥2aeven and
thus proving our proposition. How does one prove this? Observe that if δˆM (q0, wi) = δˆM (q0, wj)
then no matter what u is, δˆM (q0, wiu) = δˆM (q0, wju), which means that either M accepts both wiu
and wju, or rejects both of them. Now if we find a u such that wiu ∈ L≥2aeven and wju 6∈ L≥2aeven then
it means that M cannot recognize L≥2aeven. We will identify u based on what wi and wj are.
For every pair of strings (among w1, w2, w3, w4, w5, w6) we need to find a “witness” string u
with the above properties. That gives us 15 cases to consider, but we will combine many of the
cases together.
• Case wi = w5 and wj ∈ {w1, w2, w3, w4, w6}. Suppose δˆM (q0, w5) = δˆM (q0, wj). Then for
all u, either w5u and wju are both accepted by M or neither one is. Take u = . Now
w5u = w5 ∈ L≥2aeven, whereas wju 6∈ L≥2aeven (when wj ∈ {w1, w2, w3, w4, w6}). Thus, M cannot
recognize L≥2aeven giving us the desired contradiction.
• Case wi = w1, and wj ∈ {w2, w4, w6}. Once again, if δˆM (q0, w1) = δˆM (q0, wj) then for every u,
M either accepts both w1u and wju or neither one. If we take u = aa, then w1u = aa ∈ L≥2aeven,
but wju 6∈ L≥2aeven when wj ∈ {w2, w4, w6}, giving us the desired contradiction.
6
• Case wi = w3 and wj ∈ {w2, w4, w6}. Similar to the previous case we can take u = aa.
• Case wi = w1 and wj = w3. Take u = ab.
• Case wi = w2 and wj = w4. Take u = a.
• Case wi = w2 and wj = w6. Take u = b.
• Case wi = w4 and wj = w6. Take u = b.
A One k-positions from end
Problem
Design an automaton for the language Lk = {w | kth character from end of w is 1}
Solution
What do you need to remember? The last k characters seen so far!
Formally, Mk = (Q, {0, 1}, δ, q0, F )
• States = Q = {〈w〉 | w ∈ {0, 1}k}
• δ(〈w〉, b) = 〈w2w3 . . . wkb〉 where w = w1w2 . . . wk
• q0 = 〈0k〉
• F = {〈1w2w3 . . . wk〉 | wi ∈ {0, 1}}
Lower Bound on DFA size
Proposition 6. Any DFA recognizing Lk has at least 2
k states.
Proof. Let M , with initial state q0, recognize Lk and assume (for contradiction) that M has < 2
k
states.
• Number of strings of length k = 2k
• There must be two distinct string w0 and w1 of length k such that for some state q, q0 w0−→M q
and q0
w1−→M q.
Let i be the first position where w0 and w1 differ. Without loss of generality assume that w0
has 0 in the ith position and w1 has 1.
w00
i−1 = . . .
k︷ ︸︸ ︷
0 . . . 0i−1
w10
i−1 = . . .︸︷︷︸
i−1
1 . . .︸︷︷︸
k−i
0i−1
7
w00
i−1 6∈ Lk and w10i−1 ∈ Lk. Thus, M cannot accept both w00i−1 and w10i−1.
So far, w00
i−1 6∈ Ln, w10i−1 ∈ Ln, q0 w0−→M q, and q0 w1−→M q.
q0
w00i−1−→ M q1 iff q 0
i−1−→M q1
iff q0
w10i−1−→ M q1
Thus, M accepts or rejects both w00
i−1 and w10i−1. Contradiction!
8
