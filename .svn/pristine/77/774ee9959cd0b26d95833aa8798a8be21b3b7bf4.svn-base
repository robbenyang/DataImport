Announcements
MP3 available, due 10/8, 11:59p, EC due 10/1, 11:59p.
Exam 1: 10/1, 7p, rooms TBA
struct listNode {
   LIT data;
   listNode * next;
   listNode(LIT newData):        
data(newData), next(NULL){}
};
void printReverse(listNode *   curr) {
if (curr!=NULL){
printReverse(curr->next);
cout << curr->data;
   }
}
8 4 2 1 3
Running time?
Example 3:  Find kth position (we’ll need this later)
Analysis:    Find kth in array:
3 7 4 2 8
//returns pointer to node k steps forward from *curr
listNode * findKth(listNode *   curr, int k) {
}
Abstract Data Types (an example):
ToDo List
Groc List
top 20 
movie 
List
Class List
List
template<class LIT>
class List {
public:
List();
//~List();
int getSize() const;
void insert(int loc, LIT e);
void remove(int loc);
LIT const & getItem(int loc) const;
private:
//my little secret
};
int main() {
List<int> myList;
myList.insert(1,4);
myList.insert(1,6);
myList.insert(1,8);
myList.insert(3,0);
myList.insert(4,myList.getItem(2));
cout << myList.getSize() << endl;
myList.remove(2);
cout << myList.getItem(3) << endl;
return 0;
}
ADT List, implementation 1:
ToDo List
Groc List
top 20 
movie 
List Class List
List
template<class LIT>
class List {
public:
List():size(0){}
//~List();
int getSize() const;
void insert(int loc, LIT e);
void remove(int loc);
LIT const & getItem(int loc) const;
private:
LIT items[8];
int size;
};
template<class LIT>
int List<LIT>::getSize() const {
   return size;
}
template<class LIT>
void List<LIT>::insert(int loc, LIT e){
if ((size + 1) < 8) {
   LIT go = e;
   int it = loc-1;
   while (it < size+1){
     LIT temp = items[it];
     items[it] = go;
     go = temp;
     it ++;
   }
   size ++;
}}
template<class LIT>
void List<LIT>::remove(int loc) {
if (size > 0) {
   int it = loc-1;
   while (it < size){
     items[it] = items[it+1];
     it ++;
   }
   size --;
}}
template<class LIT>
LIT const & List<LIT>::getItem(int loc) 
const {return items[loc -1];}
0 1 2 3 4 5 6 7
Don
’t loo
k at 
this 
code
!
Don
’t loo
k at 
this 
code
!
Implementing a list using an array:
0 1 2 3 4 5 6 7
0 1 2 3 4 5 6 7
template<class LIT>
class List {
public:
List():size(0),head(NULL){}
~List(); // also copy constructor, assignment op
int getSize() const;
void insert(int loc, LIT e);
void remove(int loc);
LIT const & getItem(int loc) const;
private:
listNode * head; 
int size;
listNode * Find(listNode * place, int k);
struct listNode {
   LIT data;
   listNode * next;
   listNode(LIT newData):data(newData),next(NULL){}
}
}
template<class LIT>
listNode * List<LIT>::Find(listNode * place, int k){
if ((k==0) || (place==NULL))
   return place;
else
   return Find(k-1, place->next);
}
ADT List, implementation 2:
Insert new node in kth position:
3 6 4
void List<LIT>::insert(int loc, LIT e) {
}
Analysis:    insert new kth in array:
Insert new node in kth position with sentinel:
X 3 6 4
Wow, this is convenient!  How do we make it happen?
template<class LIT>
List<LIT>::List(){
}
void List<LIT>::insert(int loc, LIT e) {
     listNode * curr = Find(head, loc-1);
     listNode * newN = new listNode(e);
     newN->next = curr ->next; 
     curr->next = newN;
}
Remove node in fixed position (given a pointer to node you wish to remove):
Solution #1:
X 4 2 8
void List<LIT>::removeCurrent(listNode * curr) {
}
Remove node in fixed position (given a pointer to node you wish to remove):
X 4 2 8
Constant time hack:
void List<LIT>::removeCurrent(listNode * curr) {
}
Summary – running times for List functions:
      SLL  Array
Insert/Remove at front:  O(1)  O(1)
Insert at given location:  O(1)  O(1)
Remove at given location:  O(1) hack O(n) shift
Insert at arbitrary location:  O(1)   O(n) shift
Remove at arbitrary location: O(n) find O(n) shift
