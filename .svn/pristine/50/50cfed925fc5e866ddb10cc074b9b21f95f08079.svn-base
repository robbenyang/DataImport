Program Optimization 
Through Loop Vectorization 
Topics covered 
•  What are the microprocessor vector extensions 
or SIMD (Single Instruction Multiple Data Units) 
2 
!
•  Overcoming limitations to SIMD-Vectorization 
–  Data Dependences 
–  Data Alignment 
–  Aliasing 
–  Non-unit strides 
–  Conditional Statements 
•  Vectorization with intrinsics  
Simple Example 
•  Loop vectorization transforms a program so that the 
same operation is performed at the same time on several 
vector elements 
for (i=0; i<n; i++)  
  c[i] = a[i] + b[i]; 
! Register File 
X1 
Y1 
Z1 
32 bits 
32 bits 
+ 
32 
bits 
Scalar Unit Vector 
Unit 
lw $t0, 0($a0) 
lw  $t1, 0($a1) 
add $t3, $t0, $t1 
sw $t3, 0($a3) 
  
lwv $vt0, 0($a0) 
lwv $vt1, 0($a1) 
addv $vt3, $vt0, $vt1 
swv %vt3, $0($a3) 
3 
SIMD Vectorization 
•  The use of SIMD units can speed up the program.  
•  Intel SSE and IBM Altivec have 128-bit vector registers and 
functional units 
–  4 32-bit single precision floating point numbers 
–  2 64-bit double precision floating point numbers 
–  4 32-bit integer numbers 
–  2 64 bit integer 
–  8 16-bit integer or shorts 
–  16 8-bit bytes or chars 
•  Assuming a single ALU, these SIMD units can execute 4 single 
precision floating point number or 2 double precision operations in 
the time it takes to do only one of these operations by a scalar unit. 
•  Newer processors, such as Sandy or Ivy Bridge have AVX that 
support 256-bit vector registers. 
 
!
4 
Experimental results  
•  Results are shown for  different platforms with 
their compilers: 
–  Report generated by the compiler 
–  Execution Time for each platform 
 
  
5 
Platform 2: IBM Power 7 
IBM Power 7, 3.55 GHz 
IBM xlc compiler, version 11.0 
OS Red Hat Linux Enterprise 5.4 
Platform 1: Intel Nehalem  
Intel Core i7 CPU 920@2.67GHz 
Intel ICC compiler, version 11.1 
OS Ubuntu Linux 9.04 
The examples use single precision floating point numbers  
 
Executing Our Simple Example 
for (i=0; i<n; i++)  
  c[i] = a[i] + b[i]; 
! Register File 
X
1 
Y1 
Z1 
32 bits 
+ 
32 bits 
Scalar Unit Vector 
Unit 
Intel Nehalem 
Exec. Time scalar code: 6.1  
Exec. Time vector code: 3.2  
Speedup: 1.8 
 
IBM Power 7 
Exec. Time scalar code: 2.1 
Exec. Time vector code: 1.0  
Speedup: 2.1 
 
6 
How do we access the SIMD  units? 
•  Three choices 
1.  Assembly Language 
 
 
2.  Macros or Vector Intrinsics 
3.  C code and a vectorizing compiler 
7 
for (i=0; i<LEN; i++)  
  c[i] = a[i] + b[i]; 
void example(){   
__m128 rA, rB, rC;  
 for (int i = 0; i <LEN; i+=4){     
    rA = _mm_load_ps(&a[i]);     
    rB = _mm_load_ps(&b[i]);     
    rC = _mm_add_ps(rA,rB);    
   _mm_store_ps(&C[i], rC);   
}} 
 
     ..B8.5  
 movaps    a(,%rdx,4), %xmm0 
 addps     b(,%rdx,4), %xmm0 
 movaps    %xmm0, c(,%rdx,4) 
 addq      $4, %rdx 
 cmpq      $rdi, %rdx 
 jl        ..B8.5 
Why use compiler vectorization? 
1.  Easier  
2.  Portable across vendors and machines 
–  Although compiler directives differ across compilers 
3.  Better performance of the compiler generated code  
–  Compiler applies other transformations 
8 
Compilers make your codes (almost) machine independent  
How well do compilers vectorize? 
                 Compiler 
Loops 
XLC ICC GCC 
Total 159 
  Vectorized 74 75 32 
  Not vectorized 85 84 127 
Average Speed Up 1.73 1.85 1.30 
9 
                 Compiler 
Loops 
XLC but 
not ICC 
ICC but 
not XLC 
Vectorized 25 26 
How well do compilers vectorize? 
                 Compiler 
Loops 
XLC ICC GCC 
Total 159 
  Vectorized 74 75 32 
  Not vectorized 85 84 127 
Average Speed Up 1.73 1.85 1.30 
10 
                 Compiler 
Loops 
XLC but 
not ICC 
ICC but 
not XLC 
Vectorized 25 26 
By adding manual vectorization the average speedup  
was 3.78 (versus 1.73 obtained by the XLC compiler)  
Compiler Vectorization 
•  Compilers can vectorize for us, but they may fail: 
1.  Code cannot be vectorized due to data 
dependences: vectorization will produce incorrect 
results. 
 
2.  Code can be vectorized, but the compiler fail to 
vectorize the code in its current form 
1.  Programmer can use compiler directives to give the 
compiler the necessary information 
2.  Programmer can transform the code  
11 
Example 
12 
 
void test(float* A,float* B,float* C,float* D, float* E) 
{!! ! 
  for (int i = 0; i <LEN; i++){!! ! ! 
   A[i]=B[i]+C[i]+D[i]+E[i]; 
!!} 
} 
Compiler directives 
13 
 
void test(float* A, float* B, float* 
C, float* D, float* E) 
{!! ! 
  for (int i = 0; i <LEN; i++){!! ! ! 
   A[i]=B[i]+C[i]+D[i]+E[i]; 
!!} 
} 
Intel Nehalem 
Compiler report: Loop was not 
vectorized. 
Exec. Time scalar code: 5.6 
Exec. Time vector code: -- 
Speedup: -- 
Intel Nehalem 
Compiler report: Loop was 
vectorized. 
Exec. Time scalar code: 5.6 
Exec. Time vector code: 2.2 
Speedup: 2.5 
 
void test(float* __restrict__ A,  
float* __restrict__ B,  
float* __restrict__ C,  
float* __restrict__ D,  
float* __restrict__ E) 
{!! ! 
  for (int i = 0; i <LEN; i++){!! ! ! 
   A[i]=B[i]+C[i]+D[i]+E[i]; 
!!} 
} 
Compiler directives 
14 
 
void test(float* A, float* B, float* 
C, float* D, float* E) 
{!! ! 
  for (int i = 0; i <LEN; i++){!! ! ! 
   A[i]=B[i]+C[i]+D[i]+E[i]; 
!!} 
} 
Power 7 
Compiler report: Loop was not 
vectorized.  
Exec. Time scalar code: 2.3 
Exec. Time vector code: -- 
Speedup: -- 
Power 7 
Compiler report: Loop was 
vectorized. 
Exec. Time scalar code: 1.6 
Exec. Time vector code: 0.6 
Speedup: 2.7 
 
void test(float* __restrict__ A,  
float* __restrict__ B,  
float* __restrict__ C,  
float* __restrict__ D,  
float* __restrict__ E) 
{!! ! 
  for (int i = 0; i <LEN; i++){!! ! ! 
   A[i]=B[i]+C[i]+D[i]+E[i]; 
!!} 
} 
Vectorization is not always legal 
•  Vectorization of some codes could produce 
incorrect results 
•  Compilers (and programmers) can compute data 
dependences to determine if a program can be 
vectorized 
 
15 
Definition of Dependence 
•  A statement S is said to be data dependent on 
statement T if 
–  T executes before S in the original sequential/scalar program 
–  S and T access the same data item 
–  At least one of the accesses is a write.  
16 
Tour on Data Dependences 
Flow dependence (True dependence) 
Anti dependence 
Output dependence 
S1: X = A+B 
S2: C= X+A 
S1: A = X + B 
S2: X= C + D 
S1: X = A+B 
S2: X= C + D 
S1 
S2 
S1 
S2 
S1 
S2 
17 
Data Dependence 
 
•  Dependences indicate an execution order that 
must be honored. 
•  Executing statements in the order of the 
dependences guarantee correct results. 
•  Statements not dependent on each other can be 
reordered, executed in parallel, or coalesced into 
a vector operation. 
18 
Data Dependences 
19 
S1: A = B + D 
S2: C = A + T 
S3: Z = P + T 
S1 
S2 
S3 
Data Dependences 
20 
S1: A = B + D 
S2: C = A + T 
S3: Z = P + T 
S1 
S2 
S3 
S1: A = B + D 
S3: Z = P + T 
S2: C = A + T 
S2: C = A + T 
S1: A = B + D 
S3: Z = P + T 
Dependences in Loops (I) 
•  Dependences in loops are easy to understand if the loops are 
unrolled. Now the dependences are between statement “executions”. 
for (i=0; i<n; i++){ 
  a[i] = b[i] + 1; 
  c[i] = a[i] + 2; 
} 
S1 
21 
S2 
Dependences in Loops (I) 
for (i=0; i<n; i++){ 
  a[i] = b[i] + 1; 
  c[i] = a[i] + 2; 
} 
S1 
S2 
i=0 
22 
 
 
S1: a[0] = b[0] + 1 
S2: c[0] = a[0] + 2 
 
 
 
S1: a[1] = b[1] + 1 
S2: c[1] = a[1] + 2 
 
 
 
S1: a[2] = b[2] + 1 
S2: c[2] = a[2] + 2 
 
i=1 i=2 
Dependences in Loops (I) 
for (i=0; i<n; i++){ 
  a[i] = b[i] + 1; 
  c[i] = a[i] + 2; 
} 
S1 
S2 
S1 
S2 
iteration: 
instances of S1: 
instances of S2: 
S1 
S2 
S1 
S2 
S1 
S2 
0 1 2 3 ! 
! 
23 
Dependences in Loops (I) 
for (i=0; i<n; i++){ 
  a[i] = b[i] + 1; 
  c[i] = a[i] + 2; 
} 
S1 
S2 
S1 
S2 
iteration: 
instances of S1: 
instances of S2: 
S1 
S2 
S1 
S2 
S1 
S2 
0 1 2 3 ! 
! 
24 
     Loop independent dependence 
Dependences in Loops (I) 
for (i=0; i<n; i++){ 
  a[i] = b[i] + 1; 
  c[i] = a[i] + 2; 
} 
S1 
S2 
S1 
S2 
iteration: 
instances of S1: 
instances of S2: 
S1 
S2 
S1 
S2 
S1 
S2 
0 1 2 3 ! 
! 
25 
S1 
S2 
For the whole loop 
Dependences in Loops (I) 
for (i=0; i<n; i++){ 
  a[i] = b[i] + 1; 
  c[i] = a[i] + 2; 
} 
S1 
S2 
S1 
S2 
iteration: 
instances of S1: 
instances of S2: 
S1 
S2 
S1 
S2 
S1 
S2 
0 1 2 3 ! 
! 
26 
S1 
S2 
For the whole loop 
0 
Dependences in Loops (I) 
for (i=0; i<n; i++){ 
  a[i] = b[i] + 1; 
  c[i] = a[i] + 2; 
} 
S1 
S2 
S1 
S2 
iteration: 
instances of S1: 
instances of S2: 
S1 
S2 
S1 
S2 
S1 
S2 
0 1 2 3 ! 
! 
27 
S1 
S2 
For the whole loop 
0 
distance 
Dependences in Loops (I) 
for (i=0; i<n; i++){ 
  a[i] = b[i] + 1; 
  c[i] = a[i] + 2; 
} 
S1 
S2 
28 
For the dependences shown here, we assume  
that arrays do not overlap in memory (no aliasing).  
Compilers must know that there is no aliasing in order to  
vectorize.  
 
Dependences in Loops (II) 
for (i=1; i<n; i++){ 
  a[i] = b[i] + 1; 
  c[i] = a[i-1] + 2; 
} 
S1 
29 
S2 
Dependences in Loops (II) 
for (i=1; i<n; i++){ 
  a[i] = b[i] + 1; 
  c[i] = a[i-1] + 2; 
} 
S1 
S2 
i=1 
30 
 
 
S1: a[1] = b[1] + 1 
S2: c[1] = a[0] + 2 
 
 
 
S1: a[2] = b[2] + 1 
S2: c[2] = a[1] + 2 
 
 
 
S1: a[3] = b[3] + 1 
S2: c[3] = a[2] + 2 
 
i=2 i=3 
Dependences in Loops (II) 
for (i=1; i<n; i++){ 
  a[i] = b[i] + 1; 
  c[i] = a[i-1] + 2; 
} 
S1 
31 
S1 
S2 
iteration: 
instances of S1: 
instances of S2: 
S1 
S2 
S1 
S2 
S1 
S2 
1 2 3 4 ! 
! 
S2 
Dependences in Loops (II) 
for (i=1; i<n; i++){ 
  a[i] = b[i] + 1; 
  c[i] = a[i-1] + 2; 
} 
S1 
32 
S1 
S2 
iteration: 
instances of S1: 
instances of S2: 
S1 
S2 
S1 
S2 
S1 
S2 
1 2 3 4 ! 
! 
Loop carried dependence 
S2 
Dependences in Loops (II) 
for (i=1; i<n; i++){ 
  a[i] = b[i] + 1; 
  c[i] = a[i-1] + 2; 
} 
S1 
33 
S1 
S2 
iteration: 
instances of S1: 
instances of S2: 
S1 
S2 
S1 
S2 
S1 
S2 
1 2 3 4 ! 
! 
S1 
S2 
For the whole loop 
S2 
Dependences in Loops (II) 
for (i=1; i<n; i++){ 
  a[i] = b[i] + 1; 
  c[i] = a[i-1] + 2; 
} 
S1 
34 
S1 
S2 
iteration: 
instances of S1: 
instances of S2: 
S1 
S2 
S1 
S2 
S1 
S2 
1 2 3 4 ! 
! 
S1 
S2 
For the whole loop 
1 
S2 
Dependences in Loops (II) 
•  Dependences in loops are easy to understand if loops are unrolled. Now the 
dependences are between statement “executions” 
for (i=1; i<n; i++){ 
  a[i] = b[i] + 1; 
  c[i] = a[i-1] + 2; 
} 
S1 
35 
S1 
S2 
iteration: 
instances of S1: 
instances of S2: 
S1 
S2 
S1 
S2 
S1 
S2 
1 2 3 4 ! 
! 
S1 
S2 
For the whole loop 
1 
distance 
Dependences in Loops (III) 
for (i=0; i<n; i++){ 
  a = b[i] + 1; 
  c[i] = a + 2; 
} 
S1 
S2 
36 
Dependences in Loops (III) 
for (i=0; i<n; i++){ 
  a = b[i] + 1; 
  c[i] = a + 2; 
} 
S1 
S2 
37 
i=0 
 
 
S1: a= b[0] + 1 
S2: c[0] = a + 2 
 
 
 
S1: a = b[1] + 1 
S2: c[1] = a + 2 
 
 
 
S1: a = b[2] + 1 
S2: c[2] = a+ 2 
 
i=1 i=2 
Dependences in Loops (III) 
for (i=0; i<n; i++){ 
  a = b[i] + 1; 
  c[i] = a + 2; 
} 
S1 
S2 
38 
i=0 
 
 
S1: a= b[0] + 1 
S2: c[0] = a + 2 
 
 
 
S1: a = b[1] + 1 
S2: c[1] = a + 2 
 
 
 
S1: a = b[2] + 1 
S2: c[2] = a+ 2 
 
i=1 i=2 
     Loop independent dependence 
     Loop carried dependence 
Dependences in Loops (III) 
S1 
S2 
iteration: 
instances of S1: 
instances of S2: 
S1 
S2 
S1 
S2 
S1 
S2 
0 1 2 3 ! 
for (i=0; i<n; i++){ 
  a = b[i] + 1; 
  c[i] = a + 2; 
} 
S1 
S2 
39 
Dependences in Loops (III) 
S1 
S2 
iteration: 
instances of S1: 
instances of S2: 
S1 
S2 
S1 
S2 
S1 
S2 
0 1 2 3 ! 
for (i=0; i<n; i++){ 
  a = b[i] + 1; 
  c[i] = a + 2; 
} 
S1 
S2 
40 
S1 
S2 
Loop Vectorization 
•  Loop Vectorization is not always a legal transformation.  
–  Compilers can vectorize when there are only forward 
dependences 
–  Compilers cannot vectorize when there is a cycle in the data 
dependences (with the exception of self-antidependence), 
unless a transformation is applied to remove the cycle 
–  Codes with only backward dependences can be vectorized, but 
need to be transformed 
41 
forward  
dependence 
S1 
S2 
S1 
S2 
backward  
dependence 
S1 
S2 
cycle 
S1 
S1 
cycle 
Loop Vectorization  
•  When vectorizing a loop with several statements the 
compiler needs to strip-mine the loop and then apply 
loop distribution  
for (i=0; i<LEN; i++){ 
  a[i]=b[i]+(float)1.0; 
  c[i]=b[i]+(float)2.0; 
} 
S1 
S2 
45 
for (i=0; i<LEN; i+=strip_size){ 
 for (j=i; j<i+strip_size; j++) 
   a[j]=b[j]+(float)1.0; 
 for (j=i; j<i+strip_size; j++) 
   c[j]=b[j]+(float)2.0; 
} 
 
S2 S2 S2 S2 S2 S2 S2 S2 
S1 S1 S1 S1 
i=0 i=1 i=2 i=3 
S1 S1 S1 S1 
i=4 i=5 i=6 i=7 
Acyclic Dependence Graphs: 
Forward Dependences 
!
for (i=0; i<LEN; i++) { 
  a[i]= b[i] + c[i] 
  d[i] = a[i] + (float) 1.0; 
} 
 
 
S1
S2
S1 
S2 
forward  
dependence 
46 
S1 
S2 
S1 
S2 
S1 
S2 
S1 
S2 
i=0 i=1 i=2 i=3 
for (i=0; i<LEN; i++) { 
  a[i]= b[i] + c[i] 
  d[i] = a[i] + (float) 1.0; 
} 
47 
Intel Nehalem 
Compiler report: Loop was 
vectorized 
Exec. Time scalar code: 10.2 
Exec. Time vector code:   6.3 
Speedup: 1.6 
IBM Power 7 
Compiler report: Loop was SIMD 
vectorized 
Exec. Time scalar code: 3.1 
Exec. Time vector code: 1.5 
Speedup: 2.0 
Acyclic Dependence Graphs: 
Forward Dependences 
for (i=0; i<LEN; i++) { 
  a[i]= b[i] + c[i] 
  d[i] = a[i+1] + (float) 1.0; 
} 
 
 
S1 
S2 
48 
S1: a[0] = b[0] + c[0] 
S2: d[0] = a[1] + 1 
S1: a[1] = b[0] + c[0] 
S2: d[1] = a[2] + 1 
 
i=0 
i=1 
Acyclic Dependenden Graphs 
 Backward Dependences (I) 
for (i=0; i<LEN; i++) { 
  a[i]= b[i] + c[i] 
  d[i] = a[i+1] + (float) 1.0; 
} 
 
 S1 
S2 
S1 
S2 backward  
dependence 
49 
S1: a[0] = b[0] + c[0] 
S2: d[0] = a[1] + 1 
S1: a[1] = b[0] + c[0] 
S2: d[1] = a[2] + 1 
 
i=0 
i=1 
S1 
S2 
S1 
S2 
S1 
S2 
S1 
S2 
This loop cannot be vectorized as it is 
Acyclic Dependenden Graphs 
 Backward Dependences (I) 
S1 
S2 
for (i=0; i<LEN; i++) { 
  d[i] = a[i+1]+(float)1.0; 
  a[i]= b[i] + c[i]; 
} 
 
 
S2 
S1 
S1 
S2 
backward  
depedence 
S2 
S1 
forward  
depedence 
50 
Acyclic Dependenden Graphs 
 Backward Dependences (I) 
S1 
S2 
S1 
S2 
S1 
S2 
S2 
S1 
S2 
S1 
S2 
S1 
Reorder of statements 
for (i=0; i<LEN; i++) { 
 a[i]= b[i] + c[i] 
 d[i] = a[i+1] + (float) 1.0; 
} 
 
 
for (i=0; i<LEN; i++) { 
  a[i]= b[i] + c[i]; 
  d[i] = a[i+1]+(float)1.0; 
} 
 
 
for (i=0; i<LEN; i++) { 
  d[i] = a[i+1]+(float)1.0; 
  a[i]= b[i] + c[i]; 
} 
 
 
51 
Intel Nehalem 
Compiler report: Loop was not 
vectorized. Existence of vector 
dependence 
Exec. Time scalar code: 12.6 
Exec. Time vector code: -- 
Speedup: -- 
Intel Nehalem 
Compiler report: Loop was vectorized  
Exec. Time scalar code: 10.7 
Exec. Time vector code: 6.2 
Speedup: 1.72 
Speedup vs non-reordered code:2.03 
Acyclic Dependenden Graphs 
 Backward Dependences (I) 
S1 
S2 
S1 
S2 
for (int i=0;i<LEN-1;i++){     
  a[i]=a[i+1]+b[i]; 
} 
S1 
S1 
for (int i=1;i<LEN;i++){     
  a[i]=a[i-1]+b[i]; 
} 
S1 
Self-antidependence 
can be vectorized 
Self true-dependence 
can not  vectorized  
(as it is) 
a[0]=a[1]+b[0] 
a[1]=a[2]+b[1] 
a[2]=a[3]+b[2] 
a[3]=a[4]+b[3] 
a[1]=a[0]+b[1] 
a[2]=a[1]+b[2] 
a[3]=a[2]+b[3] 
a[4]=a[3]+b[4] 
S1
52 
Cycles in the DG (III) 
for (int i=0;i<LEN-1;i++){     
  a[i]=a[i+1]+b[i]; 
} 
S1 
for (int i=1;i<LEN;i++){     
  a[i]=a[i-1]+b[i]; 
} 
S1
53 
Intel Nehalem 
Compiler report: Loop was 
vectorized 
Exec. Time scalar code: 6.0 
Exec. Time vector code: 2.7 
Speedup: 2.2 
Intel Nehalem 
Compiler report: Loop was not 
vectorized. Existence of vector 
dependence 
Exec. Time scalar code: 7.2 
Exec. Time vector code: -- 
Speedup: -- 
S1 S1 
Cycles in the DG (III) 
