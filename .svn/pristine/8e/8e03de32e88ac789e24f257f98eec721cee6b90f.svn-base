1 
MP2 available,  
 MP2- Extra Credit due 9/10, Due 9/17, 11:59p.   
 
 
 
Announcements 
Parameter passing summary:  
struct stu { 
string n; 
PNG mug; 
bool pt; // print flag 
}; 
bool ps1(stu s){ 
if (!s.pt) 
cout << s.n; 
return true; 
} 
stu a; 
… // init a 
a.pt = ps1(a); 
cout << a.pt; 
E
x
a
m
p
le
 o
f 
u
s
e
 
F
u
n
c
ti
o
n
 d
e
fn
 void ps3(stu & s){ 
if (!s.pt) 
cout << s.n; 
s.pt = true; 
} 
stu c; 
… // init c 
ps3(c); 
cout << c.pt; 
void ps2(stu * s){ 
if (!s->pt) 
cout << s->n; 
s->pt = true; 
} 
stu * b; 
… // init *b 
ps2(b); 
cout << b->pt; 
Return values:  
struct student { 
string name; 
PNG mug; 
bool printed; // print flag 
}; 
bool print_student1(student s){ 
if (!s.printed) 
cout << s.name << endl; 
return true; 
} 
int main() { 
    student a; 
    bool b = print_student1(a); 
} 
What happens when we 
run code like this: ? 
Return by ___________ or ____________ or _____________ . 
Returns:  
student c; 
student * d; 
… // initialize c 
d = print_student5(c); 
E
x
a
m
p
le
 o
f 
u
s
e
 
F
u
n
c
ti
o
n
 d
e
fn
 student * print_student5(student s){ 
student w = s; 
if (!w.printed){ 
   cout << w.name << endl; 
   w.printed = true; 
} 
return &w; 
} 
struct student { 
string name; 
PNG mug; 
bool printed; // print flag 
}; 
Returns:  
student c,d; 
… // initialize c 
d = print_student5(c); 
E
x
a
m
p
le
 o
f 
u
s
e
 
F
u
n
c
ti
o
n
 d
e
fn
 student & print_student5(student s){ 
student w = s; 
if (!w.printed){ 
   cout << w.name << endl; 
   w.printed = true; 
} 
return w; 
} 
struct student { 
string name; 
PNG mug; 
bool printed; // print flag 
}; 
Lesson: don’t return 1) a pointer to a local variable, nor 2) a local variable by reference. 
Constructors reprise: 
class sphere{ 
public: 
sphere(); 
sphere(double r); 
sphere(const sphere & orig); 
void setRadius(double newRad); 
double getDiameter() const; 
… 
private: 
double theRadius; 
int numAtts; 
string * atts; 
}; 
… 
//default constructor, alt syntax 
sphere::sphere() 
{ 
 
 
 
 
 
} 
… 
What do you want 
the object to look like 
when you declare it? 
 
sphere a; 
Copy constructor - utility: 
int main(){ 
 
 
 
 
}; 
class sphere{ 
public: 
sphere(); 
sphere(double r); 
sphere(const sphere & orig); 
void setRadius(double newRad); 
double getDiameter() const; 
… 
private: 
double theRadius; 
int numAtts; 
string * atts; 
}; 
U
s
e
 2
: 
sphere myFun(sphere s){ 
   //play with s 
   return s; 
} 
 
int main(){ 
  sphere a, b; 
   // initialize a 
   b = myFun(a); 
   return 0; 
} 
U
s
e
 1
: 
Copy constructor: 
class sphere{ 
public: 
sphere(); 
sphere(double r); 
sphere(const sphere & orig); 
void setRadius(double newRad); 
double getDiameter() const; 
… 
private: 
double theRadius; 
int numAtts; 
string * atts; 
}; 
… 
//copy constructor 
sphere::sphere(const sphere & orig) 
{ 
 
 
 
 
 
 
} 
… 
class sphere{ 
public: 
sphere(); 
sphere(double r); 
sphere(const sphere & orig); 
void setRadius(double newRad); 
double getDiameter() const; 
… 
private: 
double theRadius; 
int numAtts; 
string * atts; 
}; 
int main(){ 
  sphere s; 
   …// initialize s 
   sphere t(s); //invokes CC 
   return 0; 
} 
Poser: cctor - why pbr? 
… 
//copy constructor 
sphere::sphere(const sphere & orig): 
theRadius(orig.theRadius),numatts(orig.numAtts) 
{ 
  atts = new string[numAtts]; 
  for(int i=0; i<numAtts;i++) 
    atts[i]= orig.atts[i]; 
} 
… 
red 
shiny 
juicy 
s 
1.0 
3 
