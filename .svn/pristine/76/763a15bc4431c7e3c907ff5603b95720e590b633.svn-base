• Exact key values:
• Start at the root
• Proceed down, to the leaf
• Range queries:
• As above
• Then sequential traversal
Searching a B+ Tree
Indexing (27 of 66)
Select name
From people
Where age = 25
Select name
From people
Where 20 <= age
and  age <= 30
B+ Trees (8 of 26)
•Typical order: 100.  Typical fill‐factor: 67%.
• average fanout = 133
•Typical capacities:
• Height 4: 1334 = 312,900,700 records
• Height 3: 1333 =     2,352,637 records
•Can often hold top levels in buffer pool:
• Level 1 =           1 page  =     8 Kbytes
• Level 2 =      133 pages =     1 Mbyte
• Level 3 = 17,689 pages = 133 MBytes       
B+ Trees in Practice
Indexing (28 of 66)B+ Trees (9 of 26)
Insert (K, P)
• Find leaf where K belongs, insert
• If no overflow (2d keys or less), halt
• If overflow (2d+1 keys), split node, insert in parent:
• If leaf, keep K3 too in right node
•When root splits, new root has 1 key only 
• that’s why root is special for degree satisfaction
Insertion in a B+ Tree
Indexing (29 of 66)
K1 K2 K3 K4 K5
P0 P1 P2 P3 P4 p5
K1 K2
P0 P1 P2
K4 K5
P3 P4 p5
(K3,    ) to parent
B+ Trees (10 of 26)
Insertion in a B+ Tree
Indexing (30 of 66)
80
20 60 100 120 140
10 15 18 20 30 40 50 60 65 80 85 90
10 15 18 20 30 40 50 60 65 80 85 90
Insert K=19
B+ Trees (11 of 26)
Insertion in a B+ Tree
Indexing (31 of 66)
80
20 60 100 120 140
10 15 18 19 20 30 40 50 60 65 80 85 90
10 15 18 20 30 40 50 60 65 80 85 9019
After insertion
B+ Trees (12 of 26)
Insertion in a B+ Tree
Indexing (32 of 66)
80
20 60 100 120 140
10 15 18 19 20 30 40 50 60 65 80 85 90
10 15 18 20 30 40 50 60 65 80 85 9019
Now insert 25
B+ Trees (13 of 26)
Insertion in a B+ Tree
Indexing (33 of 66)
80
20 60 100 120 140
10 15 18 19 20 25 30 40 50 60 65 80 85 90
10 15 18 20 25 30 40 60 65 80 85 9019
After insertion
50
B+ Trees (14 of 26)
Insertion in a B+ Tree
Indexing (34 of 66)
80
20 60 100 120 140
10 15 18 19 20 25 30 40 50 60 65 80 85 90
10 15 18 20 25 30 40 60 65 80 85 9019
But now have to split !
50
B+ Trees (15 of 26)
Insertion in a B+ Tree
Indexing (35 of 66)
80
20 30 60 100 120 140
10 15 18 19 20 25 60 65 80 85 90
10 15 18 20 25 30 40 60 65 80 85 9019
After the split
50
30 40 50
B+ Trees (16 of 26)
Deletion from a B+ Tree
Indexing (36 of 66)
80
20 30 60 100 120 140
10 15 18 19 20 25 60 65 80 85 90
10 15 18 20 25 30 40 60 65 80 85 9019
Delete 30
50
30 40 50
B+ Trees (17 of 26)
Deletion from a B+ Tree
Indexing (37 of 66)
80
20 30 60 100 120 140
10 15 18 19 20 25 60 65 80 85 90
10 15 18 20 25 40 60 65 80 85 9019
After deleting 30
50
40 50
May change to 
40, or not
B+ Trees (18 of 26)
Deletion from a B+ Tree
Indexing (38 of 66)
80
20 30 60 100 120 140
10 15 18 19 20 25 60 65 80 85 90
10 15 18 20 25 40 60 65 80 85 9019
Now delete 25
50
40 50
B+ Trees (19 of 26)
Deletion from a B+ Tree
Indexing (39 of 66)
80
20 30 60 100 120 140
10 15 18 19 20 60 65 80 85 90
10 15 18 20 40 60 65 80 85 9019
After deleting 25
Need to rebalance
Rotate
50
40 50
B+ Trees (20 of 26)
Deletion from a B+ Tree
Indexing (40 of 66)
80
19 30 60 100 120 140
10 15 18 19 20 60 65 80 85 90
10 15 18 20 40 60 65 80 85 9019
Now delete 40
50
40 50
B+ Trees (21 of 26)
Deletion from a B+ Tree
Indexing (41 of 66)
80
19 30 60 100 120 140
10 15 18 19 20 60 65 80 85 90
10 15 18 20 60 65 80 85 9019
After deleting 40
Rotation not possible
Need to merge nodes
50
50
B+ Trees (22 of 26)
Deletion from a B+ Tree
Indexing (42 of 66)
80
19 60 100 120 140
10 15 18 19 20 50 60 65 80 85 90
10 15 18 20 60 65 80 85 9019
Final tree
50
B+ Trees (23 of 26)
• Idea:
• Avoid duplicate keys
• Have record pointers in non‐leaf nodes
•Note: Textbook’s B‐Tree means B+‐tree!
Variation on B+tree: B‐tree (no +)
Indexing (43 of 66)B+ Trees (24 of 26)
to record to record to record
with K1 with K2 with K3
to keys to keys to keys to keys
< K1 K1<x<K2 K2<x<k3 >k3
Indexing (44 of 66)
K1 P1 K2 P2 K3 P3
B+ Trees (25 of 26)

B‐tree example n=2
Indexing (45 of 66)
6
5
1
2
5
1
4
5
1
6
5
8
5
1
0
5
2
5
4
5
1
0
2
0
3
0
4
0
1
1
0
1
2
0
9
0
1
0
0
7
0
8
0
1
7
0
1
8
0
5
0
6
0
1
3
0
1
4
0
1
5
0
1
6
0
• Sequence pointers not useful now! 
B+ Trees (26 of 26)

Hash Tables
Indexing (46 of 66)Hash Tables (0 of 20)
• Secondary storage hash tables are much like main memory ones
• Recall basics:
• There are n buckets
• A hash function f(k) maps a key k to {0, 1, …, n‐1}
• Store in bucket f(k) a pointer to record with key k
• Secondary storage: bucket = block, use overflow blocks when needed
Hash Tables
Indexing (47 of 66)Hash Tables (1 of 20)
• Assume 1 bucket (block) stores 2 keys + pointers
• h(e)=0
• h(b)=h(f)=1
• h(g)=2
• h(a)=h(c)=3
Hash Table Example
Indexing (48 of 66)
e
b
f
g
a
c
0
1
2
3
Hash Tables (2 of 20)
• Search for a:
• Compute h(a)=3
• Read bucket 3
• 1 disk access
Searching in a Hash Table
Indexing (49 of 66)
e
b
f
g
a
c
0
1
2
3
Hash Tables (3 of 20)
• Place in right bucket, if space
• E.g. h(d)=2
Insertion in Hash Table
Indexing (50 of 66)
e
b
f
g
d
a
c
0
1
2
3
Hash Tables (4 of 20)
• Create overflow block, if no space
• E.g. h(k)=1
• More over‐
flow blocks
may be needed
Insertion in Hash Table
Indexing (51 of 66)
e
b
f
g
d
a
c
0
1
2
3
k
Hash Tables (5 of 20)
• Excellent, if no overflow blocks
• Degrades considerably when number of keys exceeds the number of 
buckets (I.e. many overflow blocks).
Hash Table Performance
Indexing (52 of 66)Hash Tables (6 of 20)
• Allows hash table to grow, to avoid performance degradation
• Assume a hash function h that returns numbers in {0, …, 2k – 1}
• Start with n = 2i << 2k , only look at first i most significant bits
Extensible Hash Table
Indexing (53 of 66)Hash Tables (7 of 20)
• E.g. i=1, n=2, k=4
• Note: we only look at the first bit (0 or 1)
Extensible Hash Table
Indexing (54 of 66)
0(010)
1(011)
i=1 1
1
0
1
Hash Tables (8 of 20)
• Insert 1110
Insertion in Extensible Hash Table
Indexing (55 of 66)
0(010)
1(011)
1(110)
i=1 1
1
0
1
Hash Tables (9 of 20)
• Now insert 1010
• Need to extend table, split blocks
• i becomes 2
Insertion in Extensible Hash Table
Indexing (56 of 66)
0(010)
1(011)
1(110), 1(010)
i=1 1
1
0
1
Hash Tables (10 of 20)
• Now insert 1010 (cont.)
Insertion in Extensible Hash Table
Indexing (57 of 66)
0(010)
10(11)
10(10)
i=2 1
2
00
01
10
11
11(10) 2
Hash Tables (11 of 20)
• Now insert 0000, then 0101
• Need to split block
Insertion in Extensible Hash Table
Indexing (58 of 66)
0(010)
0(000), 0(101)
10(11)
10(10)
i=2 1
2
00
01
10
11
11(10) 2
Hash Tables (12 of 20)
• After splitting the block
Insertion in Extensible Hash Table
Indexing (59 of 66)
00(10)
00(00)
10(11)
10(10)
i=2
2
2
00
01
10
11
11(10) 2
01(01) 2
Hash Tables (13 of 20)
• No overflow blocks: access always one read
• BUT:
• Extensions can be costly and disruptive
• After an extension table may no longer fit in memory
Performance Extensible Hash Table
Indexing (60 of 66)Hash Tables (14 of 20)
• Idea: extend only one entry at a time
• Problem: n= no longer a power of 2
• Let i be #bits necessary to address n buckets.
• 2i‐1 < n <= 2i
• After computing h(k), use last i bits:
• If last i bits represent a number >= n, change msb from 1 to 0 (get a number 
< n)
Linear Hash Table
Indexing (61 of 66)Hash Tables (15 of 20)
• N=3
Linear Hash Table Example
Indexing (62 of 66)
(01)00
(11)00
(10)10
i=2
00
01
10
(01)11 BIT FLIP
Hash Tables (16 of 20)
• Insert 1000: overflow blocks…
Linear Hash Table Example
Indexing (63 of 66)
(01)00
(11)00
(10)10
i=2
00
01
10
(01)11
(10)00
Hash Tables (17 of 20)
• Extension: independent on overflow blocks
• Extend n:=n+1 when average number of records per block exceeds 
(say) 80%
Linear Hash Tables
Indexing (64 of 66)Hash Tables (18 of 20)
•From n=3 to n=4
•Only need to touch
one block (which one ?)
Linear Hash Table Extension
Indexing (65 of 66)
(01)00
(11)00
(10)10
i=2
00
01
10
(01)11
(01)11
(01)11
i=2
00
01
10
(10)10
(01)00
(11)00
11
Hash Tables (19 of 20)
• From n=3 to n=4 finished
• Extension from n=4
to n=5 (new bit)
• Need to touch every
single block (why ?)
Linear Hash Table Extension
Indexing (66 of 66)
(01)11
i=2
00
01
10
(10)10
(01)00
(11)00
11
Hash Tables (20 of 20)
