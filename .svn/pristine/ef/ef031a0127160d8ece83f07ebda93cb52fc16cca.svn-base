Kevin	  C.	  Chang
Transaction  Management
Database	  Systems
	  
More	  about	  transaction	  management	  from	  
Oracle’s	  Document:	  
http://docs.oracle.com/cd/B28359_01/server.
111/b28318/transact.htm#CNCPT016	  
	  
• Transaction
• Transaction	  management
• ACID
• Recovery
• Log
• Undo	  logging
• Redo	  logging
• Undo/redo	  logging
Concepts	  You	  Will	  Learn
Transaction	  Management	  (1	  of	  61)Default	  Section	  (1	  of	  2)
	  
	  
The  Big  Picture:  Where  We  Are
Data	  Access
Data	  Modeling
Data/Query	  Processing
Data	  Acquisition
Relational NonRelational
St
ru
ct
ur
ed
Se
m
iS
tr
uc
tu
re
d
Transaction	  Management
N
oS
Q
L  
D
at
ab
as
es
XM
L  
D
at
ab
as
es
U
nt
ru
ct
ur
ed
Relational  Databases
• SQL
• Relational  Algebra
• Query  Optimization
• Query  Execution
• Indexing
• Concurrency  Control
• Logging  Recovery
Database  Systems Toolkits
M
ap
  R
ed
uc
e
(P
ar
al
le
l)
St
or
m
  
(S
tr
ea
m
)
Information  Extraction
ER  à Relational  Model
Query	  Language
	  
We	  have	  gone	  through:	  query	  language,	  
data/query	  processing,	  data	  access,	  data	  
modeling.	  We	  will	  talk	  about	  data	  acquisition	  
later.	  	  
Now	  for	  the	  Transaction	  Management,	  which	  
is	  a	  very	  unique	  concept	  in	  database	  and	  
correspond	  to	  concurrency	  control	  and	  
logging	  recovery.	  
Industry	  is	  debating	  whether	  to	  support	  
transaction	  management	  on	  non-­‐relational	  
toolkits	  
	  
Why	  Do	  We	  Learn	  This?
Transaction  Management  (3  of  61)Why  Do  We  Learn  This?  (0  of  2)
	  
Because	  we	  need	  to	  make	  sure	  that	  data	  are	  
processed	  correctly.	  
Correctly:	  Database	  is	  the	  abstraction	  of	  the	  
real	  world	  and	  we	  don’t	  want	  the	  real	  world	  
to	  go	  wrong.	  
Why  Do  We  Learn  This?
Transaction  Management  (4  of  61)
5
Why  Do  We  Learn  This?  (1  of  2)
	  
	  
• End	  users	  don't	  see	  the	  DB	  directly
• They	  are	  only	  vaguely	  aware	  of	  its	  design
• SQL	  is	  not	  a	  suitable	  end-­‐user	  interface
• End	  users	  interact	  with	  DB	  programs
• May	  need	  more	  than	  one	  query
• May	  need	  to	  do	  calculations,	  realize	  “business	  rules”,	  etc.
• Executing	  DB	  programs:
• May	  be	  many	  users	  simultaneously
• Thus	  many	  simultaneous	  executions	  of	  these	  programs
• Expect	  “correct”	  operation
• A	  user	  should	  not	  have	  to	  wait	  forever
• A	  user	  should	  not	  be	  affected	  by	  errors	  of	  others
Users	  and	  DB	  Programs	  à
Transaction	  Managements
Transaction	  Management	  (5	  of	  61)Why	  Do	  We	  Learn	  This?	  (2	  of	  2)
	  
SQL	  is	  one	  question	  at	  time.	  It’s	  always	  long	  
and	  is	  not	  going	  to	  be	  sufficient.	  Usually	  
programs	  need	  multiple	  queries/steps.	  End	  
users	  usually	  see	  applications	  rather	  than	  DB	  
directly.	  
E.g.:	  Imagine	  there	  are	  many	  users	  withdraw	  
money	  from	  ATM.	  It	  needs	  to	  be	  completed	  
simultaneously.	  We	  want	  to	  interleave.	  
Interleaving:	  users	  and	  programs	  on	  top	  of	  
our	  computing	  resource	  
Why	  do	  we	  want	  to	  interleave?	  
1.Fairness:	  It’s	  about	  different	  users.	  Users	  are	  
equally	  important.	  Users	  should	  feel	  they	  are	  
the	  only	  one	  using	  the	  system.	  
2.	  Utilize:	  	  while	  waiting	  on	  disk	  seeks,	  CPU	  
resources	  should	  allocate	  to	  other	  users.	  =>	  
Make	  sure	  that	  we	  are	  using	  our	  resources	  in	  
an	  efficient	  way.	  
Transactions
Transaction  Management  (6  of  61)Transactions  (0  of  4)
	  
	  
Definition:	  A	  transaction	  is	  the	  execution	  of	  a	  DB	  
program.
• DB	  applications	  are	  designed	  as	  a	  set	  of	  
transactions
• Typical	  transaction
• starts	  with	  data	  from	  user	  or	  from	  another	  transaction
• includes	  DB	  reads/writes
• ends	  with	  display	  of	  data	  or	  form,	  or	  with	  request	  to	  start	  
another	  transaction
Definition	  of	  "Transaction"
Transaction	  Management	  (7	  of	  61)Transactions	  (1	  of	  4)
	  
Transaction	  -­‐-­‐-­‐	  a	  unit	  of	  change	  in	  the	  
database.	  	  
It	  starts	  with	  data	  from	  user	  or	  from	  another	  
transaction.	  Then	  the	  database	  will	  do	  some	  
calculation	  such	  as	  adding	  the	  amount	  to	  be	  
deposit.	  And	  at	  the	  end,	  with	  the	  display	  of	  
data.	  
• Edgar	  Codd?
• Jim	  Gray?
• Al	  Gore?
Behind	  the	  Scene:	  
Who	  invented	  Transaction?
Transaction	  Management	  (8	  of	  61)Transactions	  (2	  of	  4)
	  
-­‐	  Jim	  Gray	  is	  the	  key	  person	  here	  
-­‐	  More	  read	  here	  if	  you	  are	  interested:	  
http://en.wikipedia.org/wiki/Jim_Gray_%28co
mputer_scientist%29	  
Transaction  Management  (9  of  61)Transactions  (3  of  4)
	  
Example:	  everything	  in	  reality	  is	  recorded	  on	  
the	  database.	  If	  there	  is	  something	  changes	  in	  
the	  reality,	  then	  the	  database	  need	  to	  be	  
changed.	  This	  is	  transaction.	  	  
	  
Sumerians	  6000	  years	  ago	  invented	  writing	  
for	  transaction	  processing	  on	  clay	  tablets	  
And  He  is  a  Key  Contributor
Transaction  Management  (10  of  61)
From: Jim Gray at IBM: the transaction processing revolution. Bruce G. Lindsay.
ACM SIGMOD Record. 37(2). June 2008.Transactions  (4  of  4)
	  
Fundamental	  contributions	  to	  database	  and	  
transaction	  processing.	  
Defined	  the	  key	  transaction	  properties:	  
atomicity,	  consistency,	  isolation	  and	  durability	  
(ACID).	  
Correctness	  of	  Transactions
Transaction  Management  (11  of  61)Correctness  of  Transactions  (0  of  12)
	  
	  
• Transactions	  must	  be	  "atomic"
• Their	  effect	  is	  all	  or	  none
• DB	  must	  be	  consistent	  before	  and	  after	  the	  transaction	  
executes	  (not	  necessarily	  during!)
• EITHER
• a	  transaction	  executes	  fully	  and	  "commits"	  to	  all	  the	  
changes	  it	  makes	  to	  the	  DB	  
• OR	  it	  must	  be	  as	  though	  that	  transaction	  never	  executed	  
at	  all
Atomicity
Transaction	  Management	  (12	  of	  61)Correctness	  of	  Transactions	  (1	  of	  12)
	  
-­‐	  Situation:	  Suppose	  you	  are	  at	  ATM	  and	  get	  
money	  back	  through	  several	  steps.	  If	  there	  is	  
something	  wrong	  within	  those	  steps,	  should	  it	  
go	  back	  so	  that	  everything	  doesn’t	  happen	  
(you	  take	  money	  away	  but	  the	  balance	  is	  still	  
unchanged)	  or	  should	  it	  go	  forward	  to	  the	  end	  
of	  everything	  that	  have	  happened	  (the	  
balance	  is	  changed	  but	  you	  haven’t	  get	  your	  
money)?	  
-­‐	  If	  a	  transaction	  fails,	  it	  should	  either	  execute	  
fully	  (commits)	  or	  go	  back	  to	  the	  original	  state	  
(rollback/abort)	  
	  
	  
• User	  view:	  “Transfer	  money	  from	  savings	  to	  
checking”
• Program:	  
• read	  savings;	  
• verify	  balance	  is	  adequate;
• update	  savings	  balance;	  
• read	  checking;
• update	  checking	  balance;
A	  Typical	  Transaction
Transaction	  Management	  (13	  of	  61)Correctness	  of	  Transactions	  (2	  of	  12)
	  
	  
• A	  transactions	  which	  only	  READs	  expects	  DB	  to	  be	  
consistent,	  and	  cannot	  cause	  it	  to	  become	  
otherwise.
• When	  a	  transaction	  which	  does	  any	  WRITE	  finishes,	  
it	  must	  either
• COMMIT:	  "I'm	  done	  and	  the	  DB	  is	  consistent	  again"	  OR
• ABORT	  (ROLLBACK):	  "I'm	  done	  but	  I	  goofed:	  my	  changes	  
must	  be	  undone."
"Commit"	  and	  "Abort"
Transaction	  Management	  (14	  of	  61)Correctness	  of	  Transactions	  (3	  of	  12)
	  
	  
• A	  DB	  may	  have	  many	  simultaneous	  users
• simultaneous	  users	  implies	  simultaneous	  transactions	  
implies	  simultaneous	  DB	  access
• multiprogramming/multiprocessing
• Things	  can	  go	  wrong!
• transactions	  can	  conflict	  with	  one	  another
• programs	  may	  crash,	  OS	  may	  crash,	  disk	  may	  crash
• company	  loses	  customer,	  gets	  sued,	  goes	  bankrupt,	  etc.
Complications
Transaction	  Management	  (15	  of	  61)Correctness	  of	  Transactions	  (4	  of	  12)
	  
Situation:	  Suppose	  you	  and	  your	  brother	  	  Alex	  
and	  you	  deposit	  $100.	  However,	  Alex	  is	  
hungry.	  So	  he	  takes	  this	  $100	  out.	  If	  you	  
change	  your	  mind	  that	  you	  don’t	  want	  to	  
deposit	  money	  any	  more,	  It	  can’t	  roll	  back	  
because	  Alex	  has	  already	  taken	  this	  $100	  out.	  
So,	  we	  need	  to	  make	  sure	  it	  interleave	  with	  a	  
way	  that	  if	  it	  goes	  wrong,	  we	  can	  still	  rollback.	  
When	  the	  system	  declares	  that	  the	  
transaction	  to	  disk	  is	  successful,	  we	  want	  to	  
make	  sure	  that	  even	  the	  disk	  fails,	  the	  result	  is	  
still	  permanent	  and	  it	  still	  work.	  Be	  careful	  
with	  this	  kind	  of	  things!	  
• Can't	  be	  allowed	  to	  become	  inconsistent
• A	  DB	  that's	  1%	  inaccurate	  is	  100%	  unusable.
• Can't	  lose	  data
• Can't	  become	  unavailable
Can	  you	  name	  information	  processing	  systems	  that	  
are	  more	  error	  tolerant?
But	  DB	  Must	  Not	  Crash
Transaction	  Management	  (16	  of	  61)Correctness	  of	  Transactions	  (5	  of	  12)
	  
We	  want	  to	  make	  a	  reliable	  system.	  Slight	  
error	  can	  make	  a	  system	  completely	  
unusable.	  Therefore	  we	  have	  to	  make	  a	  
system	  failure	  tolerant	  as	  much	  as	  
possible.	  
Financial	  system	  can	  be	  some	  examples	  of	  
higher	  failure	  tolerant	  system.	  Example:	  
Banking	  records	  cannot	  lose	  their	  data,	  which	  
is	  very	  important!	  
	  
• Part	  of	  the	  DBMS
• Main	  duties:
• Starts	  transactions
• locate	  and	  start	  the	  right	  program
• ensure	  timely,	  fair	  scheduling
• Logs	  their	  activities
• especially	  start/stop,	  writes,	  commits,	  aborts
• Detects	  or	  avoids	  conflicts
• Takes	  recovery	  actions
Transaction	  Manager	  
(or	  TP	  Monitor)
Transaction	  Management	  (17	  of	  61)Correctness	  of	  Transactions	  (6	  of	  12)
	  
Think	  about	  it	  like	  component	  for	  controlling	  
processes	  in	  operation	  systems:	  
o Start	  transactions	  
o Logs	  transactions	  
o Detects/avoid	  issues	  
o Executes	  recovery	  processes	  
DBMS	  will	  handle	  this,	  and	  so	  as	  a	  
programmer	  we	  have	  to	  write	  a	  program	  
correct	  to	  avoid	  problems.	  
DBMS  Architecture
Transaction  Management  (18  of  61)
Query Executor
Buffer Manager
Storage Manager
Storage
Transaction Manager
Logging & 
Recovery
Concurrency 
Control
Buffer: 
data, indexes, log, etc
Lock Tables
Main Memory
User/Web Forms/Applications/DBA
query transaction
Query Optimizer
Query Rewriter
Query Parser
Records
data, metadata, indexes, log, etc
DDL Processor
DDL commands
Indexes
Correctness  of  Transactions  (7  of  12)
	  
Diagram	  of	  a	  typical	  DBMS	  architecture.	  
Question:	  What	  else	  is	  happening	  besides	  the	  
query?	  	  
	  
First	  part	  of	  DBMS	  architecture	  is	  the	  query	  
part,	  and	  it	  is	  about	  querying	  and	  fetching	  the	  
requested	  data.	  Transaction	  part	  is	  in	  the	  
middle,	  and	  it	  handles	  logging	  and	  
concurrency	  issues.	  
DBMS	  is	  like	  an	  operating	  system	  in	  that	  it	  
needs	  its	  way	  to	  handle	  virtual	  memory.	  
DBMS	  needs	  buffer	  memory	  for	  its	  specific	  
work	  so	  that	  reliability	  and	  recovery	  is	  
ensured,	  independent	  from	  OS	  virtual	  
memory.	  
	  
	  
• Transaction	  starts/stops
• DB	  writes:	  "before"	  and/or	  "after"	  images	  of	  DB	  
records
• befores can	  be	  used	  to	  rollback	  an	  aborted	  transaction
• afters can	  be	  used	  to	  redo	  a	  transaction	  (recovery	  from	  
catastrophe)
• COMMITs	  and	  ABORTs
The	  log	  itself	  is	  as	  critical	  as	  the	  DB!
What’s	  on	  the	  Log	  File?
Transaction	  Management	  (19	  of	  61)Correctness	  of	  Transactions	  (8	  of	  12)
	  
Logging	  keeps	  tracks	  of	  executions	  and	  is	  
crucial	  for	  recovery	  
Without	  log	  files	  recovery	  will	  have	  no	  idea	  
where	  and	  what	  went	  wrong!	  
	  
• Recovery
• Taking	  action	  to	  restore	  the	  DB	  to	  a	  consistent	  state
• Concurrency	  Control
• Making	  sure	  simultaneous	  transactions	  don't	  interfere	  
with	  one	  another
The	  Big	  TP	  Issues
Transaction	  Management	  (20	  of	  61)Correctness	  of	  Transactions	  (9	  of	  12)
	  
2	  Big	  Main	  Issues:	  
• Recovery	  
• Concurrency	  Control:	  How	  to	  run	  
multiple	  transactions?	  
Concurrency	  control	  can	  be	  a	  key	  
factor	  in	  measuring	  performance	  
of	  database	  system.	  
E.g.:	  How	  many	  users	  can	  access	  Facebook?	  
How	  many	  people	  can	  use	  bank	  accounts?	  
	  
• Atomicity
• Consistency	  Preservation
• Isolation
• Durability
The	  ACID	  Properties
Transaction	  Management	  (21	  of	  61)Correctness	  of	  Transactions	  (10	  of	  12)
	  
Famous	  Acronym	  To	  Remember:	  4	  properties	  
transaction	  management	  will	  satisfy	  
Atomicity	  
Consistency	  Preservation	  
Isolation	  
Durability	  
The  ACID  Properties:  From  Oracle  Wiki
Transaction  Management  (22  of  61)Correctness  of  Transactions  (11  of  12)
	  
Atomicity	  –	  All	  or	  nothing	  which	  means	  either	  
all	  actions	  must	  be	  completed	  or	  no	  
transactions	  will	  be	  completed.	  
Consistency	  –	  Starting	  from	  a	  state	  that	  
satisfies	  all	  constraints,	  then	  must	  end	  in	  a	  
state	  that	  also	  satisfies	  all	  the	  constraints.	  
Isolation	  –	  Although	  a	  database	  is	  capable	  of	  
doing	  millions	  of	  transaction,	  before	  it	  
commits	  the	  transactions	  are	  not	  to	  be	  visible.	  
In	  other	  words,	  transactions	  must	  not	  affect,	  
and	  must	  not	  be	  affected	  by	  any	  other	  
transactions.	  
Durability	  –	  Committed	  transactions	  are	  
permanent,	  no	  one	  should	  be	  allowed	  to	  be	  
change	  transaction	  and	  should	  survive	  system	  
failure	  no	  matter	  what	  
Question:	  Of	  the	  4,	  which	  of	  these	  is	  a	  
programmer’s	  responsibility?	  
Answer:	  Consistency	  
 
Behind  the  Scene:  It’s  Your  Turn!
Transaction  Management  (23  of  61)
So,	  who	  coined	  “ACID”?
Correctness  of  Transactions  (12  of  12)
	  
	  
Refer	  to	  
http://en.wikipedia.org/wiki/ACID	  
	  
	  
Recovery
Transaction  Management  (24  of  61)Recovery  (0  of  8)
	  
Question:	  How	  do	  we	  recover	  our	  system	  
when	  things	  go	  wrong?	  
Q:  What  Might  Go  Wrong?
Transaction  Management  (25  of  61)Recovery  (1  of  8)
	  
Application	  can	  be	  buggy,	  MySQL	  may	  have	  
bugs,	  windows	  can	  go	  wrong,	  and	  disk	  can	  
also	  have	  problems.	  	  Programmers	  can	  also	  be	  
buggy.	  
Tornadoes	  in	  Champaign	  →	  store	  data	  in	  
California(	  another	  place	  )	  
Disk	  Failure:	  Can	  be	  resolved	  by	  redundancy	  
of	  disks,	  RAID,	  or	  Hadoop,	  etc.	  
What	  should	  we	  do	  if	  things	  go	  wrong?	  We	  
can	  lose	  everything	  stored	  in	  memory.	  
 
• Each	  transaction	  has	  internal	  state
• When	  system	  crashes,	  internal	  state	  is	  lost
• Don’t	  know	  which	  parts	  executed	  and	  which	  didn’t
• Remedy:	  use	  a	  log
• A	  file	  that	  records	  every	  single	  action	  of	  the	  transaction
System	  Failures
Transaction	  Management	  (26	  of	  61)Recovery	  (2	  of	  8)
	  
Data	  stored	  in	  memory	  may	  be	  lost	  when	  
operating	  system	  crashes,	  we	  need	  to	  only	  
worry	  about	  data	  in	  the	  main	  memory.	  	  Things	  
may	  not	  always	  get	  saved!	  
Solution:	  Use	  a	  log	  file	  to	  keep	  track	  of	  every	  
transaction	  
• Start	  Transaction	  
• Oracle	  	  
• autocommit	  is	  off	  by	  default,	  so	  a	  new	  transaction	  is	  started	  after	  each	  
COMMIT	  or	  ROLLBACK
• MySQL
• START	  TRANSACTION
• End	  Transaction
• COMMIT	  or	  ROLLBACK
Transactions
Transaction	  Management	  (27	  of	  61)Recovery	  (3	  of	  8)
	  
Ways	  to	  start	  and	  end	  a	  transaction:	  
• Commit:	  Things	  are	  done,	  and	  
making	  sure	  that	  things	  are	  safely	  
applied.	  
• Rollback:	  Remove	  the	  cache	  (abort	  all	  
changes)	  and	  go	  back	  to	  the	  previous	  
state.	  
	  
• Database	  is	  composed	  of	  elements
• Usually	  1	  element	  =	  1	  block
• Can	  be	  smaller	  (=1	  record)	  or	  larger	  (=1	  relation)
• Each	  transaction	  reads/writes	  some	  elements
Transaction	  Abstraction
Transaction	  Management	  (28	  of	  61)Recovery	  (4	  of	  8)
	  
We	  only	  care	  about	  the	  changes	  we	  are	  going	  
to	  make	  on	  the	  table,	  and	  we	  only	  care	  about	  
elements.	  Element	  can	  be	  considered	  as	  a	  
block.	  
In	  each	  transaction	  we	  only	  care	  about	  the	  
reads	  and	  writes(the	  value	  on	  the	  disk)	  
	  
• There	  exists	  a	  notion	  of	  correctness	  for	  the	  
database
• Explicit	  constraints	  (e.g.	  foreign	  keys)
• Implicit	  conditions	  (e.g.	  sum	  of	  sales	  =	  sum	  of	  invoices)
• Correctness	  principle:	  
Transaction	  will	  be	  programmed	  such	  that:	  
if	  a	  transaction	  starts	  in	  a	  correct	  database	  state,	  it	  
ends	  in	  a	  correct	  database	  state.
• Consequence:	  we	  only	  need	  to	  guarantee	  that	  
transactions	  are	  atomic,	  and	  run	  (as	  if)	  in	  isolation.
Correctness	  Principle
Transaction	  Management	  (29	  of	  61)Recovery	  (5	  of	  8)
	  
Notions	  of	  correctness	  for	  database	  
o Explicit	  constraints	  
o Implicit	  constraints	  
As	  a	  programmer	  you	  must	  make	  sure	  
transaction	  starts	  in	  correct	  database	  state	  
and	  end	  in	  correct	  database	  state.	  	  Also	  
transaction	  to	  be	  atomic	  because	  concurrent	  
programming	  is	  hard.	  
	  
• INPUT(X)
• read	  element	  X	  to	  memory	  buffer
• READ(X,t)
• copy	  element	  X	  to	  transaction	  local	  variable	  t
• WRITE(X,t)
• copy	  transaction	  local	  variable	  t	  to	  element	  X
• OUTPUT(X)
• write	  element	  X	  to	  disk
Primitive	  Operations	  of	  Transactions
Transaction	  Management	  (30	  of	  61)Recovery	  (6	  of	  8)
	  
Four	  primitive	  operations	  of	  transactions:	  We	  
have	  buffers	  to	  ensure	  the	  safeness	  of	  our	  
transactions	  
INPUT(X)	  –	  Get	  element	  X	  to	  memory	  buffer	  
which	  is	  local	  memory	  
READ(X,	  t)	  –	  Copy	  element	  X	  to	  local	  variable	  t	  
WRITE(X,	  t)	  –	  Copy	  transaction	  local	  variable	  
to	  element	  X	  
OUTPUT(X)	  –	  Write	  element	  X	  to	  the	  disk	  
	  
READ(A,t);	  	  	  	  t	  :=	  t*2;	  	  	  WRITE(A,t);	  	  	  	  READ(B,t);	  	  	  	  t	  :=	  t*2;	  	  	  WRITE(B,t)
Example
Transaction	  Management	  (31	  of	  61)
Action t Mem A Mem B Disk A Disk B
INPUT(A) 8 8 8
READ(A,t) 8 8 8 8
t:=t*2 16 8 8 8
WRITE(A,t) 16 16 8 8
INPUT(B) 16 16 8 8 8
READ(B,t) 8 16 8 8 8
t:=t*2 16 16 8 8 8
WRITE(B,t) 16 16 16 8 8
OUTPUT(A) 16 16 16 16 8
OUTPUT(B) 16 16 16 16 16Recovery	  (7	  of	  8)
	  
Example	  of	  using	  primitive	  operations	  
Everything	  in	  the	  end	  must	  be	  consistent	  
If	  not	  consistent,	  either	  try	  to	  redo	  the	  step	  to	  
go	  forward	  or	  go	  back	  to	  the	  beginning	  of	  the	  
transaction(Try	  to	  commit	  or	  rollback)	  
Example:	  This	  can	  be	  wrong	  when	  system	  
stops	  after	  OUTPUT(A),	  two	  values	  of	  Disk	  A	  
and	  Disk	  B	  will	  no	  longer	  be	  the	  same.	  There	  
should	  be	  some	  solution	  in	  this	  kind	  of	  case.	  
We	  use	  log.	  
	  
• An	  append-­‐only	  file	  containing	  log	  records
• Note:	  multiple	  transactions	  run	  concurrently,	  log	  
records	  are	  interleaved
• After	  a	  system	  crash,	  use	  log	  to:
• Redo	  some	  transaction	  that	  did	  commit.
• Undo	  other	  transactions	  that	  did	  not	  commit.
The	  Log
Transaction	  Management	  (32	  of	  61)Recovery	  (8	  of	  8)
	  
Log	  is	  a	  special	  storage,	  or	  sequence	  of	  
history.	  Only	  appending	  is	  possible	  when	  
writing	  on	  the	  log	  file.	  This	  should	  be	  put	  in	  
very	  secure	  place,	  and	  it	  should	  never	  be	  lost.	  
It	  is	  the	  sequence	  of	  records	  that	  happened	  in	  
the	  transaction.	  
Logging	  is	  crucial	  for	  undo	  and	  redo	  
operations	  
After	  a	  system	  crash,	  recovery	  will	  use	  the	  log	  
to	  either	  undo	  or	  redo	  (go	  back	  or	  move	  on	  
forward).	  
	  
Undo	  Logging
Transaction  Management  (33  of  61)Undo  Logging  (0  of  13)
	  
	  
Log	  records
• <START	  T>	  
• transaction	  T	  has	  begun
• <COMMIT	  T>	  
• T	  has	  committed
• <ABORT	  T>
• T	  has	  aborted
• <T,X,v>
• T	  has	  updated	  element	  X,	  and	  its	  old value	  was	  v
Undo	  Logging
Transaction	  Management	  (34	  of	  61)Undo	  Logging	  (1	  of	  13)
	  
Four	  kinds	  of	  log	  records	  to	  remember	  
<Start	  T>	  -­‐	  A	  transition	  T	  has	  started	  
<Commit	  T>	  -­‐	  Transition	  T	  was	  committed	  
<Abort	  T>	  -­‐	  Transaction	  T	  was	  aborted	  
<T,X,v>	  -­‐	  Transaction	  T	  updated	  an	  element	  X,	  
and	  the	  old	  value	  was	  v	  (this	  is	  important	  
because	  when	  a	  we	  want	  to	  undo	  a	  step	  we	  
know	  the	  value	  it	  was	  before)	  
These	  types	  of	  log	  records	  will	  be	  in	  the	  log	  file	  
for	  system	  recovery	  to	  use	  
	  
U1:	  If	  T	  modifies	  X,	  then	  <T,X,v>	  entry	  must	  be	  
written	  to	  log	  before	  X	  is	  written	  to	  disk
U2:	  If	  T	  commits,	  then	  <COMMIT	  T>	  entry	  must	  be	  
written	  to	  log	  only	  after	  all	  changes	  by	  T	  are	  written	  
to	  disk
• Hence:	  OUTPUTs	  are	  done	  early	  (before	  commit)
Undo-­‐Logging	  Rules
Transaction	  Management	  (35	  of	  61)Undo	  Logging	  (2	  of	  13)
	  
Two	  logging	  rules	  to	  know	  
U1	  –	  Before	  writing	  commit,	  the	  old	  value	  
must	  be	  remembered.	  (To	  prepare	  past	  
values).	  E.g.:	  When	  transaction	  T	  modifies	  
element	  X,	  the	  log	  record	  <T,X,v>	  needs	  to	  be	  
written	  in	  the	  log	  file	  before	  X	  is	  written	  to	  the	  
disk	  
U2	  –	  If	  I	  commit,	  value	  must	  be	  on	  the	  disk	  
already.	  (To	  ensure	  that	  we	  have	  go	  with	  the	  
correct	  data).	  E.g.:	  If	  transaction	  T	  commits	  
then	  the	  record	  <COMMIT	  T>	  must	  be	  in	  the	  
log	  file	  only	  after	  all	  changes	  by	  T	  are	  written	  
on	  disk	  
Situation:	  Imagine	  a	  transaction	  T	  gets	  a	  value	  
X	  from	  disk	  and	  multiplies	  it	  by	  2,	  X	  =	  2X,	  and	  
then	  goes	  back	  on	  disk.	  	  Where	  should	  the	  
commit	  be?	  	  
Answer:	  At	  the	  end	  of	  the	  transaction	  after	  X	  
is	  written	  back	  to	  disk.	  (RULE	  U2)	  Before	  
anything	  is	  written	  to	  disk,	  there	  must	  be	  a	  log	  
record.	  (RULE	  U1)	  
Transaction  Management  (36  of  61)
Action T Mem A Mem B Disk A Disk B Log
<START T>
REAT(A,t) 8 8 8 8
t:=t*2 16 8 8 8
WRITE(A,t) 16 16 8 8 <T,A,8>
READ(B,t) 8 16 8 8 8
t:=t*2 16 16 8 8 8
WRITE(B,t) 16 16 16 8 8 <T,B,8>
OUTPUT(A) 16 16 16 16 8
OUTPUT(B) 16 16 16 16 16
<COMMIT T>
Undo  Logging  (3  of  13)
	  
Timeline	  of	  a	  Transaction	  T	  
o Log	  
o -­‐>Rule	  U1	  
o w(x)	  
o -­‐>Rule	  U2	  
o Commit	  
Question:	  What	  does	  write	  mean?	  
Answer:	  When	  buffer	  is	  flushed	  onto	  the	  disk	  
Commit	  can	  only	  happen	  after	  the	  disk	  
has	  been	  updated	  
Question:	  suppose	  we	  have	  a	  crash	  after	  
output	  (A)	  what	  do	  we	  do?	  
Answer:	  Go	  back	  to	  the	  beginning	  and	  start	  
over	  
	  
	  
After	  system’s	  crash,	  run	  recovery	  manager	  
• Idea	  1.	  Decide	  for	  each	  transaction	  T	  whether	  it	  is	  
completed	  or	  not
• <START	  T>….<COMMIT	  T>….	  	  	  =	  yes
• <START	  T>….<ABORT	  T>…….	  	  	  =	  yes
• <START	  T>………………………	  	  	  =	  no
• Idea	  2.	  Undo	  all	  modifications	  by	  incompleted
transactions
Recovery	  with	  Undo	  Log
Transaction	  Management	  (37	  of	  61)Undo	  Logging	  (4	  of	  13)
	  
Main	  Purpose	  of	  a	  Log	  is	  for	  Recovery!	  
3	  types	  of	  transactions	  
o <START	  T><COMMIT	  T>	  
o <START	  T><ABORT	  T>	  
o <START	  T>	  
Commit	  /	  Abort	  is	  good	  indicator	  that	  the	  
transaction	  successfully	  ended.	  
If	  no	  commit	  or	  abort,	  not	  a	  complete	  
transaction	  and	  we	  MUST	  undo	  all	  
modifications	  with	  incomplete	  
transactions!	  
Recovery	  manager:
• Read	  log	  from	  the	  end;	  cases:
• <COMMIT	  T>:	  	  mark	  T	  as	  completed
• <ABORT	  T>:	  mark	  T	  as	  completed
• <T,X,v>:	  if	  T	  is	  not	  completed
then	  write	  X=v	  to	  disk
else	  ignore	  /*	  committed	  or	  aborted	  xact.	  */
• <START	  T>:	  ignore
Recovery	  with	  Undo	  Log
Transaction	  Management	  (38	  of	  61)Undo	  Logging	  (5	  of	  13)
	  
Question:	  Where	  do	  we	  start	  the	  undo	  from?	  
Answer:	  At	  the	  end	  of	  the	  undo	  log	  and	  work	  
backwards	  with	  every	  incomplete	  transaction	  
	  
Recovery  with  Undo  Log
Transaction  Management  (39  of  61)
…
…
<T6,X6,v6>
…
…
<START T5>
<START T4>
<T1,X1,v1>
<T5,X5,v5>
<T4,X4,v4>
<COMMIT T5>
<T3,X3,v3>
<T2,X2,v2>
Undo  Logging  (6  of  13)
	  
Diagram	  Example	  
Start	  recovering	  from	  the	  bottom	  to	  the	  top.	  
Track	  all	  the	  way	  back	  until	  the	  beginning	  of	  
the	  data.	  
From	  the	  diagram,	  only	  T5	  is	  committed	  and	  
all	  the	  others	  are	  partial	  transactions	  so	  we	  
need	  to	  undo.	  	  We	  scan	  from	  the	  end	  of	  the	  
log	  and	  undo	  T1,	  T2,	  T3,	  T4,	  and	  T6.	  
Question:	  How	  far?	  
Answer:	  As	  far	  as	  the	  beginning	  of	  database	  
which	  may	  be	  a	  very	  long	  time!	  
	  
• Note:	  all	  undo	  commands	  are	  idempotent
• If	  we	  perform	  them	  a	  second	  time,	  no	  harm	  is	  done
• E.g.	  if	  there	  is	  a	  system	  crash	  during	  recovery,	  simply	  
restart	  recovery	  from	  scratch
Recovery	  with	  Undo	  Log
Transaction	  Management	  (40	  of	  61)Undo	  Logging	  (7	  of	  13)
	  
Key	  Point:	  Undo	  commands	  are	  idempotent,	  
which	  means	  doing	  the	  commands	  will	  not	  
harm	  the	  database	  because	  the	  end	  result	  will	  
be	  the	  same	  
When	  do	  we	  stop	  reading	  the	  log	  ?
• We	  cannot	  stop	  until	  we	  reach	  the	  beginning	  of	  the	  
log	  file
• This	  is	  impractical
• Better	  idea:	  use	  checkpointing
Recovery	  with	  Undo	  Log
Transaction	  Management	  (41	  of	  61)Undo	  Logging	  (8	  of	  13)
	  
Reading	  until	  the	  beginning	  of	  the	  log	  file	  can	  
be	  inefficient	  and	  take	  up	  time.	  
Question:	  How	  can	  we	  solve	  this	  issue?	  
Answer:	  Use	  of	  checkpoints	  	  
Checkpoint	  the	  database	  periodically
• Stop	  accepting	  new	  transactions
• Wait	  until	  all	  curent	  transactions	  complete
• Flush	  log	  to	  disk
• Write	  a	  <CKPT>	  log	  record,	  flush
• Resume	  transactions
Checkpointing
Transaction	  Management	  (42	  of	  61)Undo	  Logging	  (9	  of	  13)
	  
Periodically	  check	  when	  things	  are	  complete,	  
concept	  of	  a	  checkpoint	  
Going	  back	  to	  each	  checkpoint	  we	  know	  that	  
everything	  before	  that	  is	  functioning	  properly	  
We	  want	  to	  get	  rid	  of	  incomplete	  
transactions,	  procedure	  for	  using	  checkpoint	  
periodically:	  
o Stop	  accepting	  new	  transactions	  
o Wait	  until	  all	  current	  transactions	  
are	  finished	  
o Flush	  log	  to	  disk	  
o Use	  <CKPT>	  log	  record,	  flush	  
o Resume	  the	  transactions	  
A	  little	  bit	  expensive	  to	  use	  this	  method!	  
Discussed	  next	  lecture….	  
Undo  Recovery  with  Checkpointing
Transaction  Management  (43  of  61)
…
…
<T9,X9,v9>
…
…
(all completed)
<CKPT>
<START T2>
<START T3
<START T5>
<START T4>
<T1,X1,v1>
<T5,X5,v5>
<T4,X4,v4>
<COMMIT T5>
<T3,X3,v3>
<T2,X2,v2>
During recovery,
Can stop at first
<CKPT>
transactions T2,T3,T4,T5
other transactions
Undo  Logging  (10  of  13)
	  
	  
• Problem	  with	  checkpointing:	  database	  freezes	  
during	  checkpoint
• Would	  like	  to	  checkpoint	  while	  database	  is	  
operational
• =nonquiescent	  checkpointing
Nonquiescent	  Checkpointing
Transaction	  Management	  (44	  of	  61)Undo	  Logging	  (11	  of	  13)
	  
	  
• Write	  a	  <START	  CKPT(T1,…,Tk)>
where	  T1,…,Tk	  are	  all	  active	  transactions
• Continue	  normal	  operation
• When	  all	  of	  T1,…,Tk	  have	  completed,	  write	  <END	  
CKPT>
Nonquiescent	  Checkpointing
Transaction	  Management	  (45	  of	  61)Undo	  Logging	  (12	  of	  13)
	  
	  
Undo  Recovery  with  Nonquiescent  
Checkpointing
Transaction  Management  (46  of  61)
…
…
…
…
…
…
<START CKPT T4, T5, T6>
…
…
…
…
<END CKPT>
…
…
…
T4, T5, T6, plus
later transactions
earlier completed trans plus
T4, T5, T6
later transactions
Q: why do we need 
<END CKPT> ?Undo  Logging  (13  of  13)
	  
	  
	  
Redo	  Logging
Transaction  Management  (47  of  61)Redo  Logging  (0  of  8)
	  
	  
Log	  records
• <START	  T>	  =	  transaction	  T	  has	  begun
• <COMMIT	  T>	  =	  T	  has	  committed
• <ABORT	  T>=	  T	  has	  aborted
• <T,X,v>=	  T	  has	  updated	  element	  X,	  and	  its	  new
value	  is	  v
Redo	  Logging
Transaction	  Management	  (48	  of	  61)Redo	  Logging	  (1	  of	  8)
	  
	  
R1:	  If	  T	  modifies	  X,	  then	  both	  <T,X,v>	  and	  <COMMIT	  
T>	  must	  be	  written	  to	  disk	  before	  X	  is	  written	  to	  
disk
• Hence:	  OUTPUTs	  are	  done	  late (after	  commit)
Redo-­‐Logging	  Rules
Transaction	  Management	  (49	  of	  61)Redo	  Logging	  (2	  of	  8)
	  
	  
Transaction  Management  (50  of  61)
Action T Mem A Mem B Disk A Disk B Log
<START T>
REAT(A,t) 8 8 8 8
t:=t*2 16 8 8 8
WRITE(A,t) 16 16 8 8 <T,A,16>
READ(B,t) 8 16 8 8 8
t:=t*2 16 16 8 8 8
WRITE(B,t) 16 16 16 8 8 <T,B,16>
<COMMIT T>
OUTPUT(A) 16 16 16 16 8
OUTPUT(B) 16 16 16 16 16
Redo  Logging  (3  of  8)
	  
	  
After	  system’s	  crash,	  run	  recovery	  manager	  
• Step	  1.	  Decide	  for	  each	  transaction	  T	  whether	  it	  is	  
completed	  or	  not
• <START	  T>….<COMMIT	  T>….	  	  	  	  =	  yes
• <START	  T>….<ABORT	  T>…….	  	  	  	  =	  yes
• <START	  T>………………………	  	  	  =	  no
• Step	  2.	  Read	  log	  from	  the	  beginning,	  redo	  all	  
updates	  of	  committed transactions
Recovery	  with	  Redo	  Log
Transaction	  Management	  (51	  of	  61)Redo	  Logging	  (4	  of	  8)
	  
	  
Recovery  with  Redo  Log
Transaction  Management  (52  of  61)
<START T1>
<T1,X1,v1>
<START T2>
<T2, X2, v2>
<START T3>
<T1,X3,v3>
<COMMIT T2>
<T3,X4,v4>
<T1,X5,v5>
…
…
Redo  Logging  (5  of  8)
	  
	  
• Write	  a	  <START	  CKPT(T1,…,Tk)>
where	  T1,…,Tk	  are	  all	  active	  transactions
• Flush	  to	  disk	  all	  blocks	  of	  committed	  transactions	  
(dirty	  blocks),	  while	  continuing	  normal	  operation
• When	  all	  blocks	  have	  been	  written,	  write	  <END	  
CKPT>
Nonquiescent	  Checkpointing
Transaction	  Management	  (53	  of	  61)Redo	  Logging	  (6	  of	  8)
	  
	  
Redo  Recovery  with  Nonquiescent  
Checkpointing
Transaction  Management  (54  of  61)
…
<START T1>
…
<COMMIT T1>
…
…
<START CKPT T4, T5, T6>
…
…
…
…
<END CKPT>
…
…
…
<START CKPT T9, T10>
…
Step 1: look for
The last
<END CKPT>
Step 2: redo
from <START Ti> for 
Ti in {T4, T5, T6}.
All OUTPUTs 
of T1 are
known to be on disk
Redo  Logging  (7  of  8)
	  
	  
• Undo	  logging:
• OUTPUT	  must	  be	  done	  early
• If	  <COMMIT	  T>	  is	  seen,	  T	  definitely	  has	  written	  all	  its	  data	  
to	  disk	  (hence,	  don’t	  need	  to	  undo)
• Redo	  logging
• OUTPUT	  must	  be	  done	  late
• If	  <COMMIT	  T>	  is	  not	  seen,	  T	  definitely	  has	  not	  written	  
any	  of	  its	  data	  to	  disk	  (hence	  there	  is	  not	  dirty	  data	  on	  
disk)
• Would	  like	  more	  flexibility	  on	  when	  to	  OUTPUT:	  
undo/redo	  logging	  (next)
Comparison	  Undo/Redo
Transaction	  Management	  (55	  of	  61)Redo	  Logging	  (8	  of	  8)
	  
	  
Undo/redo	  Logging
Transaction  Management  (56  of  61)Undo/redo  Logging  (0  of  5)
	  
	  
Log	  records,	  only	  one	  change
• <T,X,u,v>=	  T	  has	  updated	  element	  X,	  its	  old value	  
was	  u,	  and	  its	  new value	  is	  v
Undo/Redo	  Logging
Transaction	  Management	  (57	  of	  61)Undo/redo	  Logging	  (1	  of	  5)
	  
	  
UR1:	  If	  T	  modifies	  X,	  then	  <T,X,u,v>	  must	  be	  written	  
to	  disk	  before	  X	  is	  written	  to	  disk
Note:	  we	  are	  free	  to	  OUTPUT	  early	  or	  late	  (I.e.	  before	  
or	  after	  <COMMIT	  T>)
Undo/Redo-­‐Logging	  Rule
Transaction	  Management	  (58	  of	  61)Undo/redo	  Logging	  (2	  of	  5)
	  
	  
Transaction  Management  (59  of  61)
Action T Mem A Mem B Disk A Disk B Log
<START T>
REAT(A,t) 8 8 8 8
t:=t*2 16 8 8 8
WRITE(A,t) 16 16 8 8 <T,A,8,16>
READ(B,t) 8 16 8 8 8
t:=t*2 16 16 8 8 8
WRITE(B,t) 16 16 16 8 8 <T,B,8,16>
OUTPUT(A) 16 16 16 16 8
<COMMIT T>
OUTPUT(B) 16 16 16 16 16
Undo/redo  Logging  (3  of  5)
	  
	  
After	  system’s	  crash,	  run	  recovery	  manager	  
• Redo	  all	  committed	  transaction,	  top-­‐down
• Undo	  all	  uncommitted	  transactions,	  bottom-­‐up
Recovery	  with	  Undo/Redo	  Log
Transaction	  Management	  (60	  of	  61)Undo/redo	  Logging	  (4	  of	  5)
	  
	  
Recovery  with  Undo/Redo  Log
Transaction  Management  (61  of  61)
<START T1>
<T1,X1,v1>
<START T2>
<T2, X2, v2>
<START T3>
<T1,X3,v3>
<COMMIT T2>
<T3,X4,v4>
<T1,X5,v5>
…
…
Undo/redo  Logging  (5  of  5)
	  
	  
	  
