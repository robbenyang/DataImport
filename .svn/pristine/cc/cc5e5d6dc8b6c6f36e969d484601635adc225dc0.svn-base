Kevin C. Chang
SQL1: The Basics
CS411 Database Systems
Why Do We Learn This?
SQL1: The Basics (1 of 50)Why Do We Learn This? (0 of 3)
SQL Introduction
SQL1: The Basics (2 of 50)
Standard language for querying and manipulating data
Structured   Query   Language
Many standards out there: SQL92, SQL2, SQL3, SQL99
Vendors support various subsets of these, but all of what we’ll
be talking about.
Why Do We Learn This? (1 of 3)
• Chamberlin, D. D. and Boyce, R. F. 1974. SEQUEL: A structured English query language. 
In Proceedings of the 1974 ACM SIGFIDET (Now Sigmod) Workshop on Data 
Description, Access and Control (Ann Arbor, Michigan, May 01 ‐ 03, 1974). FIDET '74. 
ACM, New York, NY, 249‐264.
Behind the Scene: The Birth of SQL
SQL1: The Basics (3 of 50)Why Do We Learn This? (2 of 3)
• SQL is a very‐high‐level language, in which the programmer is able to 
avoid specifying a lot of data‐manipulation details that would be 
necessary in languages like C++.
• What makes SQL viable is that its queries are “optimized” quite well, 
yielding efficient query executions.
Why SQL?
SQL1: The Basics (4 of 50)Why Do We Learn This? (3 of 3)
Single‐Relation Queries
SQL1: The Basics (5 of 50)Single‐Relation Queries (0 of 9)
• The principal form of a query is:
SELECT    desired attributes
FROM       one or more tables
WHERE    condition about tuples of the tables
Select‐From‐Where Statements
SQL1: The Basics (6 of 50)Single‐Relation Queries (1 of 9)
Beers(name, manf)
Bars(name, addr, license)
Drinkers(name, addr, phone)
Likes(drinker, beer)
Sells(bar, beer, price)
Frequents(drinker, bar)
Running Example
SQL1: The Basics (7 of 50)Single‐Relation Queries (2 of 9)
• Using Beers(name, manf), what beers are made by Anheuser‐Busch?
SELECT name
FROM Beers
WHERE manf = ‘Busch’;
Example
SQL1: The Basics (8 of 50)Single‐Relation Queries (3 of 9)
• Begin with the relation in the FROM clause.
• Apply the selection indicated by the WHERE clause.
• Apply the extended projection indicated by the SELECT clause.
Meaning of Single‐Relation Query
SQL1: The Basics (9 of 50)Single‐Relation Queries (4 of 9)
• When there is one relation in the FROM clause, * in the SELECT clause 
stands for “all attributes of this relation.”
• Example using Beers(name, manf):
SELECT *
FROM Beers
WHERE manf = ‘busch’;
“Everything” In SELECT Clause: STAR
SQL1: The Basics (10 of 50)Single‐Relation Queries (5 of 9)
• If you want the result to have different attribute names, use “AS <new 
name>” to rename an attribute.
• Example based on Beers(name, manf):
SELECT name AS beer, manf
FROM Beers
WHERE manf = ‘Busch’
Renaming Attributes
SQL1: The Basics (11 of 50)Single‐Relation Queries (6 of 9)
• Any expression that makes sense can appear as an element of a SELECT 
clause.
• Example: from Sells(bar, beer, price):
SELECT bar, beer, price * 120 AS priceInYen
FROM Sells;
Expressions in SELECT Clauses
SQL1: The Basics (12 of 50)Single‐Relation Queries (7 of 9)
• Composing conditions:
• Use AND, OR, NOT, and parentheses.
• From Sells(bar, beer, price), find the price Joe’s Bar charges for Bud:
SELECT bar, beer, price
FROM Sells
WHERE bar = ‘joe bar’ AND price < 5.0;
SELECT bar, beer, price
FROM Sells
WHERE (bar = ‘joe bar’ AND price < 5.0) or (beer = ‘sam adam’);
Complex Conditions in WHERE Clause
SQL1: The Basics (13 of 50)Single‐Relation Queries (8 of 9)
• Each condition
• Attribute names of the relation(s) used in the FROM.
• Comparison operators:  =, <>, <, >, <=, >=
• Apply arithmetic operations:  stockprice*2
• Operations on strings (e.g., “||”  for concatenation).
• Pattern matching:    s LIKE p
Pattern: % = “any string”; _ = “any character.”
SELECT name, phone FROM Drinkers
WHERE phone LIKE ‘%333-_ _ _ _’;
• Lexicographic order on strings.
SELECT name, city FROM Drinkers
WHERE name < ‘c’;
• Special stuff for comparing dates and times. 
• SQL is case‐insensitive.  In general, upper and lower case characters are the 
same, except inside quoted strings.
Selection Conditions
SQL1: The Basics (14 of 50)Single‐Relation Queries (9 of 9)
Null Values
SQL1: The Basics (15 of 50)Null Values (0 of 6)
SELECT bar, beer
FROM Sells
WHERE price < 5.00  OR  price >= 5.00;
vs.
SELECT bar, beer FROM Sells; 
What Should This Query Return?
SQL1: The Basics (16 of 50)Null Values (1 of 6)
• Tuples in SQL relations can have NULL as a value for one or more 
components.
• Meaning depends on context.  Two common cases:
• Missing value : e.g., we know Joe’s Bar has some address, but we don’t know 
what it is.
• Inapplicable : e.g., the value of attribute spouse for an unmarried person.
NULL Values
SQL1: The Basics (17 of 50)Null Values (2 of 6)
• The logic of conditions in SQL is really 3‐valued logic: TRUE, FALSE, 
UNKNOWN.
• When any value is compared with NULL, the truth value is UNKNOWN.
• But a query only produces a tuple in the answer if its truth value for the 
WHERE clause is TRUE (not FALSE or UNKNOWN).
Comparing NULL’s to Values
SQL1: The Basics (18 of 50)Null Values (3 of 6)
To understand how AND, OR, and NOT work in 3‐valued logic:
• TRUE = 1. 
• FALSE = 0. 
• UNKNOWN = ½.
Operators:
• AND = MIN.
• OR = MAX.
• NOT(x) = 1‐x.
• Ex: TRUE AND (FALSE OR NOT(UNKNOWN)) 
= MIN(1, MAX(0, (1 ‐ ½ ))) 
= MIN(1, MAX(0, ½ ) 
= MIN(1, ½ )  = ½.
Three‐Valued Logic
SQL1: The Basics (19 of 50)Null Values (4 of 6)
• Some common laws, like the commutatively of AND, hold in 3‐valued logic.
• But others do not:
• Ex: ,” p OR NOT p = TRUE (“law of excluded middle”)
• When p = UNKNOWN, the left side is  MAX( ½, (1 – ½ )) = ½ which is not 1 or TRUE.
Reason: 2‐Valued Laws != 3‐Valued Laws
SQL1: The Basics (20 of 50)Null Values (5 of 6)
Can test for NULL explicitly:
• x IS NULL
• x IS NOT NULL
SELECT bar, beer
FROM Sells
WHERE price < 5.00  OR  price >= 5.00 OR price IS NULL
Testing for Null
SQL1: The Basics (21 of 50)Null Values (6 of 6)
Multi‐Relation Queries
SQL1: The Basics (22 of 50)Multi‐Relation Queries (0 of 8)
• Interesting queries often combine data from more than one relation.
• We can address several relations in one query by listing them all in 
the FROM clause.
• Distinguish attributes of the same name by “<relation>.<attribute>”
Multi‐relation Queries
SQL1: The Basics (23 of 50)Multi‐Relation Queries (1 of 8)
•Find the beers liked by at least one person who 
frequents Joe’s Bar.
•Tip: Always prefix with relation name to make it 
clear/easier to read.
SELECT Likes.beer
FROM Likes, Frequents
WHERE Frequents.bar = ‘joe bar’ AND
Frequents.drinker = Likes.drinker;
Example
SQL1: The Basics (24 of 50)Multi‐Relation Queries (2 of 8)
• Almost the same as for single‐relation queries:
1. Start with the product of all the relations in the FROM clause.
2. Apply the selection condition from the WHERE clause.
3. Project onto the list of attributes and expressions in the SELECT clause.
Semantics
SQL1: The Basics (25 of 50)Multi‐Relation Queries (3 of 8)
• Sometimes, a query needs to use two copies of the same relation.
• Distinguish copies by following the relation name by the name of a 
tuple‐variable, in the FROM clause.
• It’s always an option to rename relations this way, even when not 
essential.
Explicit Tuple‐Variables
SQL1: The Basics (26 of 50)Multi‐Relation Queries (4 of 8)
SELECT s1.bar, s1.beer, s1.price
FROM Sells s1, Sells s2
WHERE s1.beer = s2.beer AND
s1.price > s2.price * 1.2;
Example
SQL1: The Basics (27 of 50)Multi‐Relation Queries (5 of 8)
SELECT a1, a2, …, ak
FROM    R1 AS x1, R2 AS x2, …, Rn AS xn
WHERE  Conditions
1. Nested loops:
Meaning (Semantics) of SQL Queries
SQL1: The Basics (28 of 50)
Answer = {}
for x1 in R1 do
for x2 in R2 do
…..
for xn in Rn do
if Conditions on (x1, x2, …, xn)
then Answer = Answer U {(a1,…,ak)
return Answer
Multi‐Relation Queries (6 of 8)
2. Relational algebra:
a1,…,ak (  Conditions (R1 x R2 x … x Rn))
Select‐From‐Where queries are precisely Select‐Project‐Join
Meaning (Semantics) of SQL Queries
SQL1: The Basics (29 of 50)Multi‐Relation Queries (7 of 8)
Behind the Scene: The Very FIRST SQL
SQL1: The Basics (30 of 50)
The first JOIN SQL
Multi‐Relation Queries (8 of 8)
Subqueries
SQL1: The Basics (31 of 50)Subqueries (0 of 9)
• A parenthesized SELECT‐FROM‐WHERE statement (subquery) can be 
used as a value in a number of places, including FROM and WHERE 
clauses.
• Example: in place of a relation in the FROM clause, we can place 
another query, and then query its result.
• Better use a tuple‐variable to name tuples of the result.
Subqueries
SQL1: The Basics (32 of 50)Subqueries (1 of 9)
• If a subquery is guaranteed to produce one tuple with one 
component, then the subquery can be used as a value.
• “Single” tuple often guaranteed by key constraint.
• A run‐time error occurs if there is no tuple or more than one tuple.
Subqueries that Return Scalar
SQL1: The Basics (33 of 50)Subqueries (2 of 9)
• From Sells(bar, beer, price), find the bars that serve Sam Adam for the 
same price Joe charges for Bud.
• Two queries would surely work:
1. Find the price Joe charges for Bud.
2. Find the bars that serve Sam Adam at that price.
Example
SQL1: The Basics (34 of 50)Subqueries (3 of 9)
SELECT bar
FROM Sells
WHERE beer = ‘sam adam’ AND
price = (SELECT price
FROM Sells
WHERE bar = ‘joe Bar’
AND beer = ‘bud’);
Query + Subquery Solution
SQL1: The Basics (35 of 50)Subqueries (4 of 9)
• <tuple> IN <relation> is true if and only if the tuple is a member of 
the relation.
• <tuple> NOT IN <relation> means the opposite.
• IN‐expressions can appear in WHERE clauses.
• The <relation> is often a subquery.
• Ex: Find the name and manufacturer of each beer that Alex likes.
SELECT *
FROM Beers
WHERE name IN (SELECT beer FROM Likes WHERE drinker = ‘alex’);
The IN Operator
SQL1: The Basics (36 of 50)Subqueries (5 of 9)
• EXISTS( <relation> ) is true if and only if the <relation> is not empty.
• Being a boolean‐valued operator, EXISTS can appear in WHERE 
clauses.
• Example: From Beers(name, manf), find those beers that are the only 
beer by their manufacturer.
The Exists Operator
SQL1: The Basics (37 of 50)Subqueries (6 of 9)
SELECT name
FROM Beers b1
WHERE NOT EXISTS(
SELECT *
FROM Beers
WHERE manf = b1.manf AND
name <> b1.name);
What Does This Query Do?
SQL1: The Basics (38 of 50)Subqueries (7 of 9)
• x = ANY( <relation> ) is a boolean condition meaning that x equals at least 
one tuple in the relation.
• Similarly, = can be replaced by any of the comparison operators.
• Example: x >= ANY( <relation> ) means x is not smaller than all tuples in the 
relation.
• Note tuples must have one component only.
The Operator ANY
SQL1: The Basics (39 of 50)Subqueries (8 of 9)
• Similarly, x <> ALL( <relation> ) is true if and only if for every tuple t
in the relation, x is not equal to t.
• That is, x is not a member of the relation.
• The <> can be replaced by any comparison operator.
• Example: x >= ALL( <relation> ) means there is no tuple larger than x
in the relation.
SELECT beer
FROM Sells
WHERE price >= ALL(
SELECT price
FROM Sells);
The Operator ALL
SQL1: The Basics (40 of 50)Subqueries (9 of 9)
Relation as Bags
SQL1: The Basics (41 of 50)Relation as Bags (0 of 9)
• Union:  {a,b,b,c} U {a,b,b,b,e,f,f} = {a,a,b,b,b,b,b,c,e,f,f}
• add the number of occurrences
• Difference: {a,b,b,b,c,c} – {b,c,c,c,d} = {a,b,b}
• subtract the number of occurrences
• Intersection: {a,b,b,b,c,c}   {b,b,c,c,c,c,d} = {b,b,c,c}
• minimum of the two numbers of occurrences
• Selection: preserve the number of occurrences
• Projection: preserve the number of occurrences (no duplicate 
elimination)
• Cartesian product, join: no duplicate elimination
Relational Algebra: Operations on Bags 
(and why we care)
SQL1: The Basics (42 of 50)
Read Section 5.3 of the book for more detail
Relation as Bags (1 of 9)
• The SELECT‐FROM‐WHERE statement uses bag semantics
• Selection: preserve the number of occurrences
• Projection: preserve the number of occurrences (no duplicate elimination)
• Cartesian product, join: no duplicate elimination 
Bag Semantics for SFW Queries
SQL1: The Basics (43 of 50)Relation as Bags (2 of 9)
• Union, intersection, and difference of relations are expressed by the 
following forms, each involving subqueries:
• ( subquery ) UNION ( subquery )
• ( subquery ) INTERSECT ( subquery )
• ( subquery ) EXCEPT ( subquery )
Union, Intersection, and Difference
SQL1: The Basics (44 of 50)Relation as Bags (3 of 9)
(SELECT * FROM Likes)
INTERSECT
(SELECT drinker, beer
FROM Sells, Frequents
WHERE Frequents.bar = Sells.bar
);
Example: Intersect
SQL1: The Basics (45 of 50)Relation as Bags (4 of 9)
• Although the SELECT‐FROM‐WHERE statement uses bag semantics, 
the default for union, intersection, and difference is set semantics.
• That is, duplicates are eliminated as the operation is applied.
Bag Semantics for Set Operations in SQL
SQL1: The Basics (46 of 50)Relation as Bags (5 of 9)
• When doing projection in relational algebra, it is easier to avoid 
eliminating duplicates.
• Just work tuple‐at‐a‐time.
• When doing intersection or difference, it is most efficient to sort the 
relations first.
• At that point you may as well eliminate the duplicates anyway.
Motivation: Efficiency
SQL1: The Basics (47 of 50)Relation as Bags (6 of 9)
• Force the result to be a set by   
SELECT DISTINCT . . .
• Force the result to be a bag (i.e., don’t eliminate duplicates) by ALL, as in        
. . . UNION ALL . . .
Controlling Duplicate Elimination
SQL1: The Basics (48 of 50)Relation as Bags (7 of 9)
• From Sells(bar, beer, price), find all the different prices charged for 
beers:
SELECT DISTINCT price
FROM Sells;
• Notice that without DISTINCT, each price would be listed as many 
times as there were bar/beer pairs at that price.
Example: DISTINCT
SQL1: The Basics (49 of 50)Relation as Bags (8 of 9)
•Using relations Frequents(drinker, bar) and 
Likes(drinker, beer):
(SELECT drinker FROM Frequents)
EXCEPT ALL
(SELECT drinker FROM Likes);
• Lists drinkers who frequent more bars than they 
like beers, and does so as many times as the 
difference of those counts.
Example: ALL
SQL1: The Basics (50 of 50)Relation as Bags (9 of 9)
