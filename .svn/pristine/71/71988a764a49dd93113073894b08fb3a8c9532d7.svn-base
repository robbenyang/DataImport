9/17/13 1 
Programming Languages and 
Compilers (CS 421) 
Elsa L Gunter 
2112 SC, UIUC 
http://courses.engr.illinois.edu/cs421 
Based in part on slides by Mattox Beckman, as updated 
by Vikram Adve and Gul Agha 
9/17/13 2 
Continuations 
n  A programming technique for all forms 
of “non-local” control flow: 
n  non-local jumps 
n  exceptions 
n  general conversion of non-tail calls to tail 
calls 
n  Essentially it’s a higher-order function 
version of GOTO 
9/17/13 3 
Continuations 
n  Idea: Use functions to represent the control 
flow of a program 
n  Method: Each procedure takes a function as 
an extra argument to which to pass its 
result; outer procedure “returns” no result 
n  Function receiving the result called a 
continuation 
n  Continuation acts as “accumulator” for work 
still to be done 
9/17/13 4 
Example of Tail Recursion 
# let rec app fl x = 
    match fl with [] -> x 
     | (f :: rem_fs) -> f (app rem_fs x);; 
val app : ('a -> 'a) list -> 'a -> 'a = <fun> 
# let app fs x = 
    let rec app_aux fl acc= 
        match fl with [] -> acc 
        | (f :: rem_fs) -> app_aux rem_fs  
                                   (fun z -> acc (f z)) 
    in app_aux fs (fun y -> y) x;; 
val app : ('a -> 'a) list -> 'a -> 'a = <fun> 
9/17/13 5 
Example of Tail Recursion 
# let rec app fl x = 
    match fl with [] -> x 
     | (f :: rem_fs) -> f (app rem_fs x);; 
val app : ('a -> 'a) list -> 'a -> 'a = <fun> 
# let app fs x = 
    let rec app_aux fl acc= 
        match fl with [] -> acc 
        | (f :: rem_fs) -> app_aux rem_fs  
                                   (fun z -> acc (f z)) 
    in app_aux fs (fun y -> y) x;; 
val app : ('a -> 'a) list -> 'a -> 'a = <fun> 
9/17/13 6 
Continuation Passing Style 
n  Writing procedures such that all 
procedure calls take a continuation to 
which to give (pass) the result, and 
return no result, is called continuation 
passing style (CPS) 
9/17/13 7 
Example of Tail Recursion & CSP 
# let app fs x = 
    let rec app_aux fl acc= 
        match fl with [] -> acc 
        | (f :: rem_fs) -> app_aux rem_fs  
                                 (fun z -> acc (f z)) 
    in app_aux fs (fun y -> y) x;; 
val app : ('a -> 'a) list -> 'a -> 'a = <fun> 
# let rec appk fl x k = 
    match fl with [] -> k x 
    | (f :: rem_fs) -> appk rem_fs x (fun z -> k (f z));; 
val appk : ('a -> 'a) list -> 'a -> ('a -> 'b) -> 'b 
9/17/13 8 
Continuation Passing Style 
n  A compilation technique to implement non-
local control flow, especially useful in 
interpreters. 
n  A formalization of non-local control flow in 
denotational semantics 
n  Possible intermediate state in compiling 
functional code 
Why CPS? 
n  Makes order of evaluation explicitly clear 
n  Allocates variables (to become registers) for each 
step of computation 
n  Essentially converts functional programs into 
imperative ones 
n  Major step for compiling to assembly or byte 
code 
n  Tail recursion easily identified 
n  Strict forward recursion converted to tail recursion 
n  At the expense of building large closures in heap 
9/17/13 9 
9/17/13 10 
Terms 
n  A function is in Direct Style when it returns its 
result back to the caller. 
n  A Tail Call occurs when a function returns the 
result of another function call without any more 
computations (eg tail recursion) 
n  A function is in Continuation Passing Style when it, 
and every function call in it, passes its result to 
another function. 
n  Instead of returning the result to the caller, we 
pass it forward to another function. 
9/17/13 11 
Example 
n  Simple reporting continuation: 
# let report x = (print_int x; print_newline( ) );; 
val report : int -> unit = <fun> 
n  Simple function using a continuation: 
# let addk a b k = k (a + b);; 
val addk : int -> int -> (int -> ’a) -> ’a = <fun> 
# addk 22 20 report;; 
2 
- : unit = () 
Simple Functions Taking Continuations 
n  Given a primitive operation, can convert it to 
pass its result forward to a continuation 
n  Examples: 
# let subk x y k = k(x + y);; 
val timesk : int -> int -> (int -> 'a) -> 'a = <fun> 
# let eqk x y k = k(x = y);; 
val eqk : 'a -> 'a -> (bool -> 'b) -> 'b = <fun> 
# let timesk x y k = k(x * y);; 
val timesk : int -> int -> (int -> 'a) -> 'a = <fun> 
9/17/13 12 
Nesting Continuations 
# let add_three x y z = x + y + z;; 
val add_three : int -> int -> int -> int = <fun> 
# let add_three x y z= let p = x + y in  p + z;; 
val add_three : int -> int -> int -> int = <fun> 
# let add_three_k x y z k =  
   addk x y (fun p -> addk p z k );; 
val add_three_k : int -> int -> int -> (int -> 'a) 
-> 'a = <fun> 
 
9/17/13 13 
9/17/13 14 
Recursive Functions 
n  Recall: 
# let rec factorial n = 
    if n = 0 then 1 else n * factorial (n - 1);; 
  val factorial : int -> int = <fun> 
# factorial 5;; 
- : int = 120 
9/17/13 15 
Recursive Functions 
# let rec factorial n = 
    let b = (n = 0) in (* First computation *) 
    if b then 1 (* Returned value *) 
    else let s = n – 1 in (* Second computation *) 
           let r = factorial s in  (* Third computation *) 
           n * r in (* Returned value *) ;; 
val factorial : int -> int = <fun> 
# factorial 5;; 
- : int = 120 
9/17/13 16 
Recursive Functions 
# let rec factorialk n k = 
   eqk n 0  
   (fun b ->  (* First computation *) 
    if b then k 1 (* Passed value *) 
    else subk n 1  (* Second computation *) 
    (fun s -> factorialk s  (* Third computation *) 
    (fun r -> timesk n r k))) (* Passed value *) 
val factorialk : int -> int = <fun> 
# factorialk 5 report;; 
120 
- : unit = () 
9/17/13 17 
Recursive Functions 
n  To make recursive call, must build 
intermediate continuation to  
n  take recursive value:  r 
n  build it to final result: n * r 
n  And pass it to final continuation:  
n    times n r k = k (n * r) 
9/17/13 18 
CPS for sum 
# let rec sum list = match list with [ ] -> 0 
    | x :: xs -> x + sum xs ;; 
val sum : int list -> int = <fun> 
9/17/13 19 
CPS for sum 
# let rec sum list = match list with [ ] -> 0 
    | x :: xs -> x + sum xs ;; 
val sum : int list -> int = <fun> 
# let rec sum list = match list with [ ] -> 0 
    | x :: xs -> let r1 = sum xs  in x + r1;; 
9/17/13 20 
CPS for sum 
# let rec sum list = match list with [ ] -> 0 
    | x :: xs -> x + sum xs ;; 
val sum : int list -> int = <fun> 
# let rec sum list = match list with [ ] -> 0 
    | x :: xs -> let r1 = sum xs  in x + r1;; 
val sum : int list -> int = <fun> 
# let rec sumk list k = match list with [ ] -> k 0 
     | x :: xs -> sumk xs  (fun r1 -> addk x r1 k);; 
9/17/13 21 
CPS for sum 
# let rec sum list = match list with [ ] -> 0 
    | x :: xs -> x + sum xs ;; 
val sum : int list -> int = <fun> 
# let rec sum list = match list with [ ] -> 0 
    | x :: xs -> let r1 = sum xs  in x + r1;; 
val sum : int list -> int = <fun> 
# let rec sumk list k = match list with [ ] -> k 0 
     | x :: xs -> sumk xs  (fun r1 -> addk x r1 k);; 
val sumk : int list -> (int -> 'a) -> 'a = <fun> 
# sumk [2;4;6;8] report;; 
20 
- : unit = () 
Example: CPS for length 
let rec length list = match list with [] -> 0 
     | (a :: bs) -> 1 + length bs 
What is the let-expanded version of this? 
9/17/13 22 
Example: CPS for length 
let rec length list = match list with [] -> 0 
     | (a :: bs) -> 1 + length bs 
What is the let-expanded version of this? 
let rec length list = match list with [] -> 0 
     | (a :: bs) -> let r1 = length bs in 1 + r1 
 
9/17/13 23 
Example: CPS for length 
let rec length list = match list with [] -> 0 
     | (a :: bs) -> 1 + length bs 
What is the let-expanded version of this? 
let rec length list = match list with [] -> 0 
     | (a :: bs) -> let r1 = length bs in 1 + r1 
 
9/17/13 24 
Example: CPS for length 
let rec length list = match list with [] -> 0 
     | (a :: bs) -> let r1 = length bs in 1 + r1 
What is the let-expanded version of this? 
let rec lengthk list k = match list with [ ] -> k 0 
    | x :: xs -> lengthk xs (fun r -> addk r 1 k);; 
 
 
9/17/13 25 
9/17/13 26 
CPS for length 
# let rec lengthk list k = match list with [ ] -> k 0 
    | x :: xs -> lengthk xs (fun r -> k (r + 1));; 
val lengthk : 'a list -> (int -> 'b) -> 'b = <fun> 
# let rec lengthk list k = match list with [ ] -> k 0 
    | x :: xs -> lengthk xs (fun r -> addk r 1 k);; 
val lengthk : 'a list -> (int -> 'b) -> 'b = <fun> 
# lengthk [2;4;6;8] report;; 
4 
- : unit = () 
9/17/13 27 
Terminology 
n  Tail Position: A subexpression s of 
expressions e, such that if evaluated, 
will be taken as the value of e 
n  if (x>3) then x + 2 else  x - 4 
n  let x = 5 in  x + 4 
n  Tail Call: A function call that occurs in 
tail position 
n  if (h x) then f x else (x + g x) 
9/17/13 28 
Terminology 
n  Available: A function call that can be 
executed by the current expression 
n  The fastest way to be unavailable is to be 
guarded by an abstraction (anonymous 
function, lambda lifted). 
n  if (h x) then f x else (x + g x) 
n  if (h x) then (fun x -> f x) else (g (x + x)) 
Not available 
9/17/13 29 
CPS Transformation 
n  Step 1: Add continuation argument to any function 
definition: 
n  let f arg = e  ⇒ let f arg k = e 
n  Idea: Every function takes an extra parameter 
saying where the result goes 
n  Step 2: A simple expression in tail position should 
be passed to a continuation instead of returned: 
n  return a ⇒ k a 
n  Assuming a is a constant or variable. 
n  “Simple” = “No available function calls.” 
9/17/13 30 
CPS Transformation 
n  Step 3: Pass the current continuation to every 
function call in tail position 
n  return f arg ⇒ f arg k 
n  The function “isn’t going to return,” so we need 
to tell it where to put the result. 
CPS Transformation 
n  Step 4: Each function call not in tail position needs 
to be converted to take a new continuation 
(containing the old continuation as appropriate) 
n  return op (f arg) ⇒ f arg (fun r -> k(op r)) 
n  op represents a primitive operation 
n  return  f(g arg) ⇒ g arg (fun r-> f r k) 
9/17/13 31 
9/17/13 32 
Example 
Before: 
let rec add_list lst = 
match lst with 
  [ ] -> 0 
| 0 :: xs -> add_list xs 
| x :: xs -> (+) x 
(add_list xs);; 
After: 
let rec add_listk lst k = 
                       (* rule 1 *) 
match lst with 
| [ ] -> k 0 (* rule 2 *) 
| 0 :: xs -> add_listk xs k 
                          (* rule 3 *) 
| x :: xs -> add_listk xs 
           (fun r -> k ((+) x r));; 
                    (* rule 4 *) 
 
Other Uses for Continuations 
n  CPS designed to preserve  order of 
evaluation 
n  Continuations used to express order of 
evaluation 
n  Can be used to change order of evaluation 
n  Implements: 
n  Exceptions and exception handling 
n  Co-routines 
n  (pseudo, aka green) threads 
9/17/13 33 
9/17/13 34 
Exceptions - Example 
# exception Zero;; 
exception Zero 
# let rec list_mult_aux list =  
    match list with [ ] -> 1 
    | x :: xs -> 
     if x = 0 then raise Zero  
                 else x * list_mult_aux xs;; 
val list_mult_aux : int list -> int = <fun> 
9/17/13 35 
Exceptions - Example 
# let list_mult list = 
    try list_mult_aux list with Zero -> 0;; 
val list_mult : int list -> int = <fun> 
# list_mult [3;4;2];; 
- : int = 24 
# list_mult [7;4;0];; 
- : int = 0 
# list_mult_aux [7;4;0];; 
Exception: Zero. 
9/17/13 36 
Exceptions 
n  When an exception is raised 
n  The current computation is aborted 
n  Control is “thrown” back up the call 
stack until a matching handler is 
found 
n  All the intermediate calls waiting for a 
return values are thrown away 
9/17/13 37 
Implementing Exceptions 
# let multkp m n k = 
   let r = m * n in 
    (print_string "product result: "; 
     print_int r; print_string "\n"; 
     k r);; 
val multkp : int -> int -> (int -> 'a) -> 'a 
= <fun> 
9/17/13 38 
Implementing Exceptions 
# let rec list_multk_aux list k kexcp = 
    match list with [ ] -> k 1 
    | x :: xs -> if x = 0 then  kexcp  0 
      else list_multk_aux xs  
              (fun r -> multkp x r k) kexcp;; 
val list_multk_aux : int list -> (int -> 'a) -> (int -> 'a) 
-> 'a = <fun> 
# let rec list_multk list k = list_multk_aux list  k  k;; 
val list_multk : int list -> (int -> 'a) -> 'a = <fun> 
9/17/13 39 
Implementing Exceptions 
# list_multk [3;4;2] report;; 
product result: 2 
product result: 8 
product result: 24 
24 
- : unit = () 
# list_multk [7;4;0] report;; 
0 
- : unit = () 
