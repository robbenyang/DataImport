12/3/13 1 
Programming Languages and 
Compilers (CS 421) 
Elsa L Gunter 
2112 SC, UIUC 
http://courses.engr.illinois.edu/cs421 
Based in part on slides by Mattox Beckman, as updated 
by Vikram Adve and Gul Agha 
12/3/13 2 
Substitution 
n  Defined on α-equivalence classes of 
terms 
n  P [N / x] means replace every free 
occurrence of x in P by N 
n  P called redex; N called residue 
n  Provided that no variable free in N 
becomes bound in P [N / x] 
n  Rename bound variables in P to avoid 
capturing free variables of N 
12/3/13 3 
Substitution 
n  x [N / x] = N 
n  y [N / x] = y if y ≠ x 
n  (e1 e2) [N / x] = ((e1 [N / x] ) (e2 [N / x] )) 
n  (λ x. e) [N / x] = (λ x. e)  
n  (λ y. e) [N / x] = λ y. (e [N / x] ) 
provided y ≠ x and y not free in N 
n  Rename y in redex if necessary 
12/3/13 4 
Example 
(λ y. y z) [(λ x. x y) / z] = ? 
n  Problems?  
n  z in redex in scope of y binding 
n  y free in the residue 
n   (λ y. y z) [(λ x. x y) / z] --α-->    
(λ w.w z) [(λ x. x y) / z] =                
λ w. w (λ x. x y)  
12/3/13 5 
Example 
n  Only replace free occurrences 
n  (λ y. y z (λ z. z)) [(λ x. x) / z] = 
λ y. y (λ x. x) (λ z. z) 
Not 
λ y. y (λ x. x) (λ z. (λ x. x)) 
12/3/13 6 
 β reduction 
n   β Rule:  (λ x. P) N --β--> P [N /x] 
 
n  Essence of computation in the lambda 
calculus 
n  Usually defined on α-equivalence 
classes of terms 
12/3/13 7 
Example 
n  (λ z. (λ x. x y) z) (λ y. y z) 
 --β--> (λ x. x y) (λ y. y z) 
 --β--> (λ y. y z) y --β--> y z 
 
n  (λ x. x x) (λ x. x x)  
 --β--> (λ x. x x) (λ x. x x)  
 --β--> (λ x. x x) (λ x. x x) --β--> …. 
12/3/13 8 
 α β Equivalence 
n  α β equivalence is the smallest 
congruence containing α equivalence 
and β reduction  
n  A term is in normal form if no subterm 
is α equivalent to a term that can be β 
reduced 
n  Hard fact (Church-Rosser): if e1 and e2 
are αβ-equivalent and both are normal 
forms, then they are α equivalent 
12/3/13 9 
Order of Evaluation 
n  Not all terms reduce to normal forms 
n  Not all reduction strategies will produce 
a normal form if one exists 
12/3/13 10 
Lazy evaluation: 
n   Always reduce the left-most application 
in a top-most series of applications (i.e. 
Do not perform reduction inside an 
abstraction) 
 
n  Stop when term is not an application, or 
left-most application is not an 
application of an abstraction to a term 
12/3/13 11 
Example 1 
n  (λ z. (λ x. x)) ((λ y. y y) (λ y. y y)) 
n  Lazy evaluation: 
n  Reduce the left-most application: 
n  (λ z. (λ x. x)) ((λ y. y y) (λ y. y y))         
--β-->  (λ x. x) 
 
12/3/13 12 
Eager evaluation 
n  (Eagerly) reduce left of top application 
to an abstraction 
n  Then (eagerly) reduce argument 
n  Then β-reduce the application 
12/3/13 13 
Example 1 
n  (λ z. (λ x. x))((λ y. y y) (λ y. y y)) 
n  Eager evaluation: 
n  Reduce the rator of the top-most application to 
an abstraction: Done. 
n  Reduce the argument: 
n  (λ z. (λ x. x))((λ y. y y) (λ y. y y)) 
--β--> (λ z. (λ x. x))((λ y. y y) (λ y. y y)) 
--β--> (λ z. (λ x. x))((λ y. y y) (λ y. y y))… 
12/3/13 14 
Example 2 
n  (λ x. x x)((λ y. y y) (λ z. z)) 
n  Lazy evaluation: 
(λ x. x  x )((λ y. y y) (λ z. z)) --β-->  
 
12/3/13 15 
Example 2 
n  (λ x. x x)((λ y. y y) (λ z. z)) 
n  Lazy evaluation: 
(λ x. x  x )((λ y. y y) (λ z. z)) --β-->  
 
12/3/13 16 
Example 2 
n  (λ x. x x)((λ y. y y) (λ z. z)) 
n  Lazy evaluation: 
(λ x. x  x )((λ y. y y) (λ z. z)) --β-->  
((λ y. y  y ) (λ z. z)) ((λ y. y  y ) (λ z. z)) 
12/3/13 17 
Example 2 
n  (λ x. x x)((λ y. y y) (λ z. z)) 
n  Lazy evaluation: 
(λ x. x  x )((λ y. y y) (λ z. z)) --β-->  
((λ y. y  y ) (λ z. z)) ((λ y. y  y ) (λ z. z) 
12/3/13 18 
Example 2 
n  (λ x. x x)((λ y. y y) (λ z. z)) 
n  Lazy evaluation: 
(λ x. x  x )((λ y. y y) (λ z. z)) --β-->  
((λ y. y  y ) (λ z. z)) ((λ y. y  y ) (λ z. z)) 
12/3/13 19 
Example 2 
n  (λ x. x x)((λ y. y y) (λ z. z)) 
n  Lazy evaluation: 
(λ x. x  x )((λ y. y y) (λ z. z)) --β-->  
((λ y. y  y ) (λ z. z)) ((λ y. y  y ) (λ z. z))  
--β--> ((λ z. z ) (λ z. z))((λ y. y  y ) (λ z. z)) 
 
 
12/3/13 20 
Example 2 
n  (λ x. x x)((λ y. y y) (λ z. z)) 
n  Lazy evaluation: 
(λ x. x  x )((λ y. y y) (λ z. z)) --β-->  
((λ y. y  y ) (λ z. z)) ((λ y. y  y ) (λ z. z))  
--β--> ((λ z. z ) (λ z. z))((λ y. y  y ) (λ z. z)) 
 
 
12/3/13 21 
Example 2 
n  (λ x. x x)((λ y. y y) (λ z. z)) 
n  Lazy evaluation: 
(λ x. x  x )((λ y. y y) (λ z. z)) --β-->  
((λ y. y  y ) (λ z. z)) ((λ y. y  y ) (λ z. z))  
--β--> ((λ z. z ) (λ z. z))((λ y. y  y ) (λ z. z)) 
 
 
12/3/13 22 
Example 2 
n  (λ x. x x)((λ y. y y) (λ z. z)) 
n  Lazy evaluation: 
(λ x. x  x )((λ y. y y) (λ z. z)) --β-->  
((λ y. y  y ) (λ z. z)) ((λ y. y  y ) (λ z. z))  
--β--> ((λ z. z ) (λ z. z))((λ y. y  y ) (λ z. z)) 
--β--> (λ z. z ) ((λ y. y  y ) (λ z. z)) 
 
12/3/13 23 
Example 2 
n  (λ x. x x)((λ y. y y) (λ z. z)) 
n  Lazy evaluation: 
(λ x. x  x )((λ y. y y) (λ z. z)) --β-->  
((λ y. y  y ) (λ z. z)) ((λ y. y  y ) (λ z. z))  
--β--> ((λ z. z ) (λ z. z))((λ y. y  y ) (λ z. z)) 
--β--> (λ z. z ) ((λ y. y  y ) (λ z. z)) --β-->  
(λ y. y  y ) (λ z. z)  
12/3/13 24 
Example 2 
n  (λ x. x x)((λ y. y y) (λ z. z)) 
n  Lazy evaluation: 
(λ x. x  x )((λ y. y y) (λ z. z)) --β-->  
((λ y. y  y ) (λ z. z) ) ((λ y. y  y ) (λ z. z))  
--β--> ((λ z. z ) (λ z. z))((λ y. y  y ) (λ z. z)) 
--β--> (λ z. z ) ((λ y. y  y ) (λ z. z)) --β-->  
(λ y. y  y ) (λ z. z)  
12/3/13 25 
Example 2 
n  (λ x. x x)((λ y. y y) (λ z. z)) 
n  Lazy evaluation: 
(λ x. x  x )((λ y. y y) (λ z. z)) --β-->  
((λ y. y  y ) (λ z. z) ) ((λ y. y  y ) (λ z. z))  
--β--> ((λ z. z ) (λ z. z))((λ y. y  y ) (λ z. z)) 
--β--> (λ z. z ) ((λ y. y  y ) (λ z. z)) --β-->  
(λ y. y  y ) (λ z. z) ~β~  λ z. z 
12/3/13 26 
Example 2 
n  (λ x. x x)((λ y. y y) (λ z. z)) 
n  Eager evaluation: 
(λ x. x  x) ((λ y. y y) (λ z. z)) --β-->  
(λ x. x  x) (( λ z. z ) (λ z. z)) --β--> 
(λ x. x  x) (λ z. z) --β-->  
(λ z. z) (λ z. z)  --β-->  λ z. z 
12/3/13 27 
Untyped λ-Calculus 
n  Only three kinds of expressions: 
n  Variables: x, y, z, w, … 
n  Abstraction:  λ x. e    
   (Function creation) 
n  Application:  e1 e2 
12/3/13 28 
How to Represent (Free) Data Structures 
(First Pass - Enumeration Types) 
n  Suppose τ is a type with n constructors: 
C1,…,Cn (no arguments) 
n  Represent each term as an abstraction: 
n  Let Ci →  λ x1 … xn. xi  
n  Think: you give me what to return in 
each case (think match statement) and 
I’ll return the case for the i'th 
constructor 
12/3/13 29 
How to Represent Booleans 
n  bool = True | False 
n  True → λ x1. λ x2. x1    ≡α  λ x. λ y. x 
n  False → λ x1. λ x2. x2    ≡α   λ x. λ y. y 
n  Notation 
n  Will write  
 λ x1 … xn. e for λ x1. … λxn. e 
 e1 e2 … en  for (…(e1 e2 )… en ) 
12/3/13 30 
Functions over Enumeration Types 
n  Write a “match” function 
n  match e with C1 -> x1 
                      | … 
                      | Cn -> xn 
 →   λ x1 … xn e. e x1…xn  
 
n  Think: give me what to do in each case and 
give me a case, and I’ll apply that case 
12/3/13 31 
Functions over Enumeration Types 
n  type τ  = C1|…|Cn 
n  match e with C1 -> x1 
                      | … 
                      | Cn -> xn 
 
n  matchτ = λ x1 … xn e. e x1…xn 
n  e = expression (single constructor) 
   xi is returned if e = Ci 
12/3/13 32 
match for Booleans 
n  bool = True | False 
n  True → λ x1 x2. x1    ≡α  λ x y. x 
n  False → λ x1 x2. x2    ≡α   λ x y. y 
 
n  matchbool = ? 
12/3/13 33 
match for Booleans 
n  bool = True | False 
n  True → λ x1 x2. x1    ≡α  λ x y. x 
n  False → λ x1 x2. x2    ≡α   λ x y. y 
 
n  matchbool = λ x1 x2 e. e x1 x2 
     ≡α  λ x y b. b x y 
12/3/13 34 
How to Write Functions over Booleans 
n   if b then x1 else x2 → 
n    if_then_else b x1 x2 = b x1 x2 
n    if_then_else ≡ λ b x1 x2 . b x1 x2  
12/3/13 35 
How to Write Functions over Booleans 
n  Alternately: 
n   if b then x1 else x2  =  
    match b with True  -> x1 | False -> x2  → 
    matchbool x1 x2 b = 
    (λ x1 x2 b . b x1 x2 ) x1 x2 b = b x1 x2  
n   if_then_else 
   ≡ λ b x1 x2. (matchbool x1 x2 b) 
   = λ b x1 x2. (λ x1 x2 b . b x1 x2 ) x1 x2 b 
   = λ b x1 x2. b x1 x2  
12/3/13 36 
Example: 
not b 
 = match b with True -> False | False -> True  
 → (matchbool) False True b 
 = (λ x1 x2 b . b x1 x2 ) (λ x y. y) (λ x y. x) b 
 = b (λ x y. y)(λ x y. x) 
 
n  not ≡ λ b. b (λ x y. y)(λ x y. x) 
n  Try and, or 
12/3/13 37 
      and                   or 
12/3/13 38 
How to Represent (Free) Data Structures 
(Second Pass - Union Types) 
n  Suppose τ is a type with n constructors: 
type τ  = C1 t11 … t1k | … |Cn tn1 … tnm,  
n  Represent each term as an abstraction: 
n   Ci ti1 … tij, →λ x1 … xn. xi ti1 … tij,  
n   Ci →λ ti1 … tij, x1 … xn . xi ti1 … tij,  
n  Think: you need to give each constructor 
its arguments fisrt 
12/3/13 39 
How to Represent Pairs 
n  Pair has one constructor (comma) that takes 
two arguments 
n   type (α,β)pair = (,) α β 
n  (a , b) --> λ x . x a b 
n  (_ , _) --> λ a b x . x a b 
12/3/13 40 
Functions over Union Types 
n  Write a “match” function 
n  match e with C1 y1 … ym1 -> f1 y1 … ym1 
                      | … 
                      | Cn y1 … ymn -> fn y1 … ymn  
 
n  matchτ →   λ f1 … fn e. e f1…fn  
 
n  Think: give me a function for each case and 
give me a case, and I’ll apply that case to 
the appropriate fucntion with the data in that 
case 
12/3/13 41 
Functions over Pairs 
n  matchpair = λ f p. p f 
n  fst p = match p with (x,y) -> x 
n  fst → λ p. matchpair (λ x y. x) 
   = (λ f p. p f) (λ x y. x) = λ p. p (λ x y. x) 
n  snd → λ p. p (λ x y. y) 
12/3/13 42 
How to Represent (Free) Data Structures 
(Third Pass - Recursive Types) 
n  Suppose τ is a type with n constructors:  
   type τ  = C1 t11 … t1k | … |Cn tn1 … tnm,  
n  Suppose tih : τ   (ie. is recursive) 
n  In place of a value tih have a function to compute 
the recursive value rih x1 … xn 
n  Ci ti1 … rih …tij →  λ x1 … xn . xi ti1 … (rih x1 … xn) … tij  
n  Ci →  λ ti1 … rih …tij  x1 … xn .xi ti1 … (rih x1 … xn) … tij,  
12/3/13 43 
How to Represent Natural Numbers 
n  nat = Suc nat | 0 
n  Suc = λ n f x. f (n f x) 
n  Suc n = λ f x. f (n f x) 
n  0 = λ f x. x 
n  Such representation called   
Church Numerals 
12/3/13 44 
Some Church Numerals 
n  Suc 0 = (λ n f x. f (n f x)) (λ f x. x) --> 
 λ f x. f ((λ f x. x) f x) -->  
 λ f x. f ((λ x. x) x) --> λ f x. f x 
 
Apply a function to its argument once 
12/3/13 45 
Some Church Numerals 
n  Suc(Suc 0) = (λ n f x. f (n f x)) (Suc 0) --> 
(λ n f x. f (n f x)) (λ f x. f x) --> 
 λ f x. f ((λ f x. f x) f x)) -->  
  λ f x. f ((λ x. f x) x)) --> λ f x. f (f x) 
Apply a function twice 
 
In general n = λ f x. f ( … (f x)…) with n 
applications of f 
12/3/13 46 
Primitive Recursive Functions 
n  Write a “fold” function 
n  fold f1 … fn  = match e 
   with C1 y1 … ym1 -> f1 y1 … ym1 
      | … 
      | Ci y1 … rij …yin -> fn y1 … (fold f1 … fn rij) …ymn  
      | …  
      | Cn y1 … ymn -> fn y1 … ymn  
 
n  foldτ →   λ f1 … fn e. e f1…fn  
n  Match in non recursive case a degenerate version 
of fold 
12/3/13 47 
Primitive Recursion over Nat 
n  fold f z n= 
n  match n with 0 -> z 
n            | Suc m -> f (fold f z m) 
 
n  fold ≡ λ f z n. n f z 
 
n  is_zero  n = fold (λ r. False) True n 
n  = (λ f x. f n x) (λ r. False) True 
n  = ((λ r. False) n ) True 
n   ≡ if n = 0 then True else False 
12/3/13 48 
Adding Church Numerals 
n  n ≡ λ f x. f n x    and  m ≡ λ f x. f m x  
 
n  n + m = λ f x. f (n+m) x   
  = λ f x. f n (f m x) = λ f x. n f (m f x) 
 
n  + ≡ λ n m f x. n f (m f x) 
 
n  Subtraction is harder 
12/3/13 49 
Multiplying Church Numerals 
n  n ≡ λ f x. f n x    and  m ≡ λ f x. f m x  
 
n  n * m = λ f x. (f n * m) x  = λ f x. (f m)n x 
=  λ f x. n (m f) x 
 
 * ≡ λ n m f x. n (m f) x 
12/3/13 50 
Predecessor 
n  let pred_aux n = 
 match n with 0 -> (0,0) 
 | Suc m 
-> (Suc(fst(pred_aux m)), fst(pred_aux m) 
= fold (λ r. (Suc(fst r), fst r)) (0,0) n  
n  pred ≡ λ n. snd (pred_aux n) n = 
λ n. snd (fold (λ r.(Suc(fst r), fst r)) (0,0) n) 
12/3/13 51 
Recursion 
n  Want a λ-term Y such that for all term 
R we have 
n  Y R = R (Y R) 
n  Y needs to have replication to 
“remember” a copy of R 
n  Y = λ y. (λ x. y(x x)) (λ x. y(x x))  
n  Y R = (λ x. R(x x)) (λ x. R(x x)) 
        = R ((λ x. R(x x)) (λ x. R(x x))) 
n  Notice: Requires lazy evaluation 
12/3/13 52 
Factorial 
n  Let F = λ f n. if n = 0 then 1 else n * f (n - 1) 
Y F 3 = F (Y F) 3  
= if 3 = 0 then 1 else 3 * ((Y F)(3 - 1)) 
= 3 * (Y F) 2 = 3 * (F(Y F) 2) 
= 3 * (if 2 = 0 then 1 else 2 * (Y F)(2 - 1)) 
= 3 * (2 * (Y F)(1)) = 3 * (2 * (F(Y F) 1)) =…  
= 3 * 2 * 1 * (if 0 = 0 then 1 else 0*(Y F)(0 -1)) 
= 3 * 2 * 1 * 1 = 6 
12/3/13 53 
Y in OCaml 
# let rec y f = f (y f);; 
val y : ('a -> 'a) -> 'a = <fun> 
# let mk_fact =  
   fun f n -> if n = 0 then 1 else n * f(n-1);; 
val mk_fact : (int -> int) -> int -> int = <fun> 
# y mk_fact;; 
Stack overflow during evaluation (looping 
recursion?). 
12/3/13 54 
Eager Eval Y in Ocaml 
# let rec y f x = f (y f) x;; 
val y : (('a -> 'b) -> 'a -> 'b) -> 'a -> 'b = 
<fun> 
# y mk_fact;; 
- : int -> int = <fun> 
# y mk_fact 5;; 
- : int = 120 
n  Use recursion to get recursion 
12/3/13 55 
Some Other Combinators 
n  For your general exposure 
 
n  I = λ x . x 
n  K = λ x. λ y. x 
n  K* = λ x. λ y. y 
n  S = λ x. λ y. λ z. x z (y z) 
