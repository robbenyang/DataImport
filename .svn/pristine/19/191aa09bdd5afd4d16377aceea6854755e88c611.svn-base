MP2 available, due 9/17, 11:59p.
b=a
Announcements
250690176
4
wet
rocky
rotating
inhabited
2.5
3
b
Red
Juicy
crunchy
0.84
1
b, a
dimpoled
a c=b=a
Operator=:
class sphere{
public:
sphere();
sphere(double r);
sphere(const sphere & orig);
~sphere();
sphere & operator=(const sphere & rhs);
…
private:
double theRadius;
int numAtts;
string * attributes;
};
…
// overloaded = 
sphere & sphere::operator=(const sphere & rhs){
   //protect against re-assignment
      //clear lhs
      //copy rhs
   //return a helpful value
}
…
int main(){
  sphere a, b;
     ...
   b = a;
   return 0;
}
The Rule of the Big Three:
If you have a reason to implement any one of 
• _______________________
• _______________________
• _______________________
then you must implement all three.
Object Oriented Programming
Three fundamental characteristics:
encapsulation - separating an object’s data and implementation 
from its interface.
inheritance - 
polymorphism - a function can behave differently, depending on 
the type of the calling object. 
Inheritance: a simple first example
class sphere {
public:
sphere();
sphere(double r);
double getVolume();
void setRadius(double r);
void display();
private:
double theRadius;
};
class ball:public sphere {
public:
ball();
ball(double r string n);
string getName();
void setName(string n);
void display();
private:
string name;
};
inheritance rules:
• 
• 
• 
class sphere {
public:
sphere();
sphere(double r);
…
double getVolume();
void setRadius(double r);
…
void display();
private:
double theRadius;
};
class ball:public sphere {
public:
ball();
ball(double r, string n);
…
string getName();
void setName(string n);
…
void display();
private:
string name;
};
Protected access: like public to derived classes, like private to 
anything else
int main() {
sphere a;
cout << a.surfaceArea;
}
Subclass substitution (via examples):
void printVolume(sphere t){
   cout << t.getVolume() << endl;}
int main() {
   sphere s(8.0);
   ball b(3.2, “pompom”);
   double a = b.getVolume();
   printVolume(s);
   printVolume(b);
}
Base b;
Derived d;
b=d;
d=b;
Base * b;
Derived * d;
b=d;
d=b;
class sphere {
public:
sphere();
sphere(double r);
…
double getVolume();
void setRadius(double r);
…
void display();
private:
double theRadius;
};
class ball:public sphere {
public:
ball();
ball(double r string n);
…
string getName();
void setName(string n);
…
void display();
private:
string name;
};
something to consider:
void sphere::display() {
   cout << “sphere” << endl;
}
sphere s;
ball b;
s.display();
b.display();
void ball::display() {
   cout << “ball” << endl;
}
sphere * sptr;
sptr = &s;
sptr->display();
sphere * sptr;
sptr = &b;
sptr->display();
ex
3
ex
2
ex
1
class sphere {
public:
sphere();
sphere(double r);
…
double getVolume();
void setRadius(double r);
…
        void display();
private:
double theRadius;
};
class ball:public sphere {
public:
ball();
ball(double r string n);
string getName();
void setName(string n);
…
         void display();
private:
string name;
};
“virtual” functions:
void sphere::display() {
   cout << “sphere” << endl;
}
void ball::display() {
   cout << “ball” << endl;
}
if (a==0)
   sptr = &s;
else sptr = &b;
sptr->display();
ex
4
virtual functions – the rules:
A virtual method is one a _____________ can override.
A class’s virtual methods _______ be implemented.  If not, then the 
class is an “abstract base class” and no objects of that type can be 
declared.
A derived class is not required to override an existing implementation 
of an _____________ virtual method.
Constructors ____________ be virtual
Destructors can and ___________virtual
Virtual method return type ___________ be overwritten.
Constructors for derived class:
ball::ball():sphere()
{
   name = “not known”;
}
ball b;
ball::ball(double r, string n):
sphere(r)
{
   name = n;
}
ball b(0.5,”grape”);
class Base{
public:
   Base(){cout<<”Ctor: B"<<endl;} 
   ~Base(){cout<<”Dtor: B"<<endl;}
};
class Derived: public Base{
public:
   Derived(){cout<<”Ctor: D"<<endl;} 
   ~Derived(){cout<<”Dtor: D"<<endl;}
};
“virtual” destructors:
void main(){
   Base * V = new Derived(); 
   delete V;
}
