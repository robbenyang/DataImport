1 Introducing Finite Automata
1.1 Problems and Computation
Decision Problems
Decision Problems
Given input, decide ‚Äúyes‚Äù or ‚Äúno‚Äù
‚Ä¢ Examples: Is x an even number? Is x prime? Is there a path from s to t in graph G?
‚Ä¢ i.e., Compute a boolean function of input
General Computational Problem
In contrast, typically a problem requires computing some non-boolean function, or carrying out an
interactive/reactive computation in a distributed environment
‚Ä¢ Examples: Find the factors of x. Find the balance in account number x.
‚Ä¢ In this course, we will study decision problems because aspects of computability are captured
by this special class of problems
What Does a Computation Look Like?
‚Ä¢ Some code (a.k.a. control): the same for all instances
‚Ä¢ The input (a.k.a. problem instance): encoded as a string over a finite alphabet
‚Ä¢ As the program starts executing, some memory (a.k.a. state)
‚Äì Includes the values of variables (and the ‚Äúprogram counter‚Äù)
‚Äì State evolves throughout the computation
‚Äì Often, takes more memory for larger problem instances
‚Ä¢ But some programs do not need larger state for larger instances!
1.2 Finite Automata: Informal Overview
Finite State Computation
‚Ä¢ Finite state: A fixed upper bound on the size of the state, independent of the size of the input
‚Äì A sequential program with no dynamic allocation using variables that take boolean
values (or values in a finite enumerated data type)
1
‚Äì If t-bit state, at most 2t possible states
‚Ä¢ Not enough memory to hold the entire input
‚Äì ‚ÄúStreaming input‚Äù: automaton runs (i.e., changes state) on seeing each bit of input
An Automatic Door
Front
pad
Rear
pad
door
Figure 1: Top view of Door
closed open
front
neither
rear
both
neither
front
rear
both
Figure 2: State diagram of controller
‚Ä¢ Input: A stream of events <front>, <rear>, <both>, <neither> . . .
‚Ä¢ Controller has a single bit of state.
Finite Automata
Details
Automaton
A finite automaton has: Finite set of states, with start/initial and accepting/final states; Transitions
from one state to another on reading a symbol from the input.
Computation
Start at the initial state; in each step, read the next symbol of the input, take the transition (edge)
labeled by that symbol to a new state.
Acceptance/Rejection: If after reading the input w, the machine is in a final state then w is
accepted; otherwise w is rejected.
2
q0 q1
0 0
1
1
Figure 3: Transition Diagram of automaton
Conventions
‚Ä¢ The initial state is shown by drawing an incoming arrow into the state, with no source.
‚Ä¢ Final/accept states are indicated by drawing them with a double circle.
Example: Computation
‚Ä¢ On input 1001, the computation is
1. Start in state q0. Read 1 and goto q1.
2. Read 0 and goto q1.
3. Read 0 and goto q1.
4. Read 1 and goto q0. Since q0 is not a final state 1001 is rejected.
‚Ä¢ On input 010, the computation is
1. Start in state q0. Read 0 and goto q0.
2. Read 1 and goto q1.
3. Read 0 and goto q1. Since q1 is a final state 010 is accepted.
q0 q1
0 0
1
1
3
1.3 Applications
Finite Automata in Practice
‚Ä¢ grep
‚Ä¢ Thermostats
‚Ä¢ Coke Machines
‚Ä¢ Elevators
‚Ä¢ Train Track Switches
‚Ä¢ Security Properties
‚Ä¢ Lexical Analyzers for Parsers
2 Formal Definitions
2.1 Deterministic Finite Automaton
Defining an Automaton
To describe an automaton, we to need to specify
‚Ä¢ What the alphabet is,
‚Ä¢ What the states are,
‚Ä¢ What the initial state is,
‚Ä¢ What states are accepting/final, and
‚Ä¢ What the transition from each state and input symbol is.
Thus, the above 5 things are part of the formal definition.
Deterministic Finite Automata
Formal Definition
Definition 1. A deterministic finite automaton (DFA) is M = (Q,Œ£, Œ¥, q0, F ), where
‚Ä¢ Q is the finite set of states
‚Ä¢ Œ£ is the finite alphabet
‚Ä¢ Œ¥ : Q√ó Œ£‚Üí Q ‚ÄúNext-state‚Äù transition function
4
0 1
q0 q0 q1
q1 q1 q0
Figure 5: Transition Table representation
‚Ä¢ q0 ‚àà Q initial state
‚Ä¢ F ‚äÜ Q final/accepting states
Given a state and a symbol, the next state is ‚Äúdetermined‚Äù.
Formal Example of DFA
Example 2.
q0 q1
0 0
1
1
Figure 4: Transition Diagram of DFA
Formally the automaton is M = ({q0, q1}, {0, 1}, Œ¥, q0, {q1}) where
Œ¥(q0, 0) = q0 Œ¥(q0, 1) = q1
Œ¥(q1, 0) = q1 Œ¥(q1, 1) = q0
Computation
Definition 3. For a DFA M = (Q,Œ£, Œ¥, q0, F ), string w = w1w2 ¬∑ ¬∑ ¬∑wk, where for each i wi ‚àà Œ£,
and states q1, q2 ‚àà Q, we say q1 w‚àí‚ÜíM q2 if there is a sequence of states r0, r1, . . . rk such that
‚Ä¢ r0 = q1,
‚Ä¢ for each i, Œ¥(ri, wi+1) = ri+1, and
‚Ä¢ rk = q2.
Definition 4. For a DFA M = (Q,Œ£, Œ¥, q0, F ) and string w ‚àà Œ£‚àó, we say M accepts w iff q0 w‚àí‚ÜíM q
for some q ‚àà F .
Useful Notation
5
Definition 5. For a DFA M = (Q,Œ£, Œ¥, q0, F ), let us define a function Œ¥ÀÜM : Q√ó Œ£‚àó ‚Üí P(Q) such
that Œ¥ÀÜM (q, w) = {q‚Ä≤ ‚àà Q | q w‚àí‚ÜíM q‚Ä≤}.
We could say M accepts w iff Œ¥ÀÜM (q0, w) ‚à© F 6= ‚àÖ.
Proposition 6. For a DFA M = (Q,Œ£, Œ¥, q0, F ), and any q ‚àà Q, and w ‚àà Œ£‚àó, |Œ¥ÀÜM (q, w)| = 1.
Acceptance/Recognition
Definition 7. The language accepted or recognized by a DFA M over alphabet Œ£ is L(M) = {w ‚àà
Œ£‚àó |M accepts w}. A language L is said to be accepted/recognized by M if L = L(M).
2.2 Examples
Example I
q0
0, 1
Figure 6: Automaton accepts all strings of 0s and 1s
Example II
q0 q1
0 1
1
0
Figure 7: Automaton accepts strings ending in 1
Example III
6
q0 q1
0 0
1
1
Figure 8: Automaton accepts strings having an odd number of 1s
Example IV
q0 q1
q2q3
1
1
1
1
0 0 0 0
Figure 9: Automaton accepts strings having an odd number of 1s and odd number of 0s
3 Designing DFAs
3.1 General Method
Typical Problem
Problem
Given a language L, design a DFA M that accepts L, i.e., L(M) = L.
Methodology
‚Ä¢ Imagine yourself in the place of the machine, reading symbols of the input, and trying to
determine if it should be accepted.
‚Ä¢ Remember at any point you have only seen a part of the input, and you don‚Äôt know when it
ends.
‚Ä¢ Figure out what to keep in memory. It cannot be all the symbols seen so far: it must fit into
a finite number of bits.
7
3.2 Examples
Strings containing 0
Problem
Design an automaton that accepts all strings over {0, 1} that contain at least one 0.
Solution
What do you need to remember? Whether you have seen a 0 so far or not!
qnoz qzer
1 0, 1
0
Figure 10: Automaton accepting strings with at least one 0.
Even length strings
Problem
Design an automaton that accepts all strings over {0, 1} that have an even length.
Solution
What do you need to remember? Whether you have seen an odd or an even number of symbols.
qe qo
0, 1
0, 1
Figure 11: Automaton accepting strings of even length.
Pattern Recognition
Problem
Design an automaton that accepts all strings over {0, 1} that have 001 as a substring, where u is a
substring of w if there are w1 and w2 such that w = w1uw2.
Solution
What do you need to remember? Whether you
‚Ä¢ haven‚Äôt seen any symbols of the pattern
8
‚Ä¢ have just seen 0
‚Ä¢ have just seen 00
‚Ä¢ have seen the entire pattern 001
Pattern Recognition Automaton
q q0 q00 qp
1
0
1
0
0
1
0, 1
Figure 12: Automaton accepting strings having 001 as substring.
grep Problem
Problem
Given text T and string s, does s appear in T?
Na¬®ƒ±ve Solution
=s?Ô∏∑ Ô∏∏Ô∏∏ Ô∏∑
=s?Ô∏∑ Ô∏∏Ô∏∏ Ô∏∑
=s?Ô∏∑ Ô∏∏Ô∏∏ Ô∏∑
=s?Ô∏∑ Ô∏∏Ô∏∏ Ô∏∑
=s?Ô∏∑ Ô∏∏Ô∏∏ Ô∏∑
T1 T2 T3 . . . Tn Tn+1 . . . Tt
Running time = O(nt), where |T | = t and |s| = n.
grep Problem
Smarter Solution
Solution
‚Ä¢ Build DFA M for L = {w | there are u, v s.t. w = usv}
‚Ä¢ Run M on text T
Time = time to build M + O(t)!
Questions
9
‚Ä¢ Is L regular no matter what s is?
‚Ä¢ If yes, can M be built ‚Äúefficiently‚Äù?
Knuth-Morris-Pratt (1977): Yes to both the above questions.
Multiples
Problem
Design an automaton that accepts all strings w over {0, 1} such that w is the binary representation
of a number that is a multiple of 5.
Solution
What must be remembered? The remainder when divided by 5.
How do you compute remainders?
‚Ä¢ If w is the number n then w0 is 2n and w1 is 2n+ 1.
‚Ä¢ (a.b+ c) mod 5 = (a.(b mod 5) + c) mod 5
‚Ä¢ e.g. 1011 = 11 (decimal) ‚â° 1 mod 5 10110 = 22 (decimal) ‚â° 2 mod 5 10111 = 23 (decimal)
‚â° 3 mod 5
Automaton for recognizing Multiples
q0
q1
q4
q2
q3
0
1
0
1
1
0
1
0
0
1
Figure 13: Automaton recognizing binary numbers that are multiples of 5.
A One k-positions from end
Problem
10
Design an automaton for the language Lk = {w | kth character from end of w is 1}
Solution
What do you need to remember? The last k characters seen so far!
Formally, Mk = (Q, {0, 1}, Œ¥, q0, F )
‚Ä¢ States = Q = {„Äàw„Äâ | w ‚àà {0, 1}‚àó and |w| ‚â§ k}
‚Ä¢ Œ¥(„Äàw„Äâ, b) =
{ „Äàwb„Äâ if |w| < k
„Äàw2w3 . . . wkb„Äâ if w = w1w2 . . . wk
‚Ä¢ q0 = „Äà„Äâ
‚Ä¢ F = {„Äà1w2w3 . . . wk„Äâ | wi ‚àà {0, 1}}
11
