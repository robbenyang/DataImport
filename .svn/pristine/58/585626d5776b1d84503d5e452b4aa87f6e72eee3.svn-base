MP3 available, due 10/8, 11:59p. 
Lab cancelled, but:
Code challenge - 9p, 10/2, Siebel 0224
Laptop-Linux installation - 11a-1p, 10/3, Siebel 2405
Linux tutorial - 5-7p, 10/3, Siebel 0224
GDB tutorial - 3-5p, 10/4, Siebel 0224
Startups at UIUC - 5-7p, 10/4, Siebel 0224
TODAY:  ADT - Stacks
1
Announcements
Stacks: main()
studyHard()
doGoodWork()
mps()
exams()
plan()
code()
wingIt()
plan()
code()
test()
wingIt()
( { } ( ) [ ( ( ) ) { ( ( ) ) ( ) } ] ( ) ) 4 5 + 7 2 - * 3 - 6 /
Stack ADT:
template<class SIT>
class Stack {
public:
Stack();
~Stack(); // also copy 
constructor, assignment op
bool empty() const;
void push(const SIT & e);
SIT pop();
private:
 ?
};
push(3)
push(8)
push(4)
pop()
pop()
push(6)
pop()
push(2)
pop()
pop()
Stack linked memory implementation:
template<class SIT>
class Stack {
public:
Stack();
~Stack(); // etc.
bool empty() const;
void push(const SIT & e);
SIT pop();
private:
    struct stackNode {
        SIT data;
        stackNode * next;
    };
    stackNode * top;
    int size;
};
3
6
4
template<class SIT>
void Stack<SIT>::push(const SIT & d){
stackNode * newNode = new stackNode(d);
newNode->next = top;
top = newNode;
}
template<class SIT>
SIT Stack<SIT>::pop(){
}
Stack - array based implementation:
template<class SIT>
class Stack {
public:
Stack();
~Stack(); // etc.
bool empty() const;
void push(const SIT & e);
SIT pop();
private:
    int capacity;
    int size;
    SIT * items;
};
template<class SIT>
Stack<SIT>::Stack(){
capacity = 4;
size = 0;
items = new SIT[capacity];
}
Stack array based implementation:
template<class SIT>
class Stack {
public:
Stack();
~Stack(); // etc.
bool empty() const;
void push(const SIT & e);
SIT pop();
private:
    int capacity;
    int size;
    SIT * items;
};
template<class SIT>
Stack<SIT>::Stack(){
capacity = 4;
size = 0;
items = new SIT[capacity];
}
template<class SIT>
void Stack<SIT>::push(const SIT & e){
if (size >= capacity) {
  // grow array somehow  
}
items[size] = e;
size ++;
}
3
6
8 top of stack 
items[ size - 1 ]
Stack array based implementation: (what if array fills?)
Analysis holds for array based implementations of Lists, Stacks, 
Queues, Heaps…
x x x x General Idea:  upon an insert 
(push), if the array is full, create a 
larger space and copy the data into 
it.
Main question:  What’s the 
resizing scheme?  We examine 3.
Stack array based implementation: (what if array fills?)
How does this scheme do on a sequence of n pushes?
Stack array based implementation: (what if array fills?)
3 4 6 2
3 4
How does this scheme do on a sequence of n pushes?
Stack array based implementation: (what if array fills?)
How does this scheme do on a sequence of n pushes?
