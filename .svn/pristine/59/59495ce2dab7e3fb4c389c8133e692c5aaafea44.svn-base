1 Computing Using a Stack
Beyond Finite Memory: The Stack
â€¢ So far we considered automata with finite memory
â€¢ Today: automata with access to an infinite stack
â€¢ The stack can contain an unlimited number of characters. But
â€“ can read/erase only the top of the stack: pop
â€“ can add to only the top of the stack: push
â€¢ On longer inputs, automaton may have more items in the stack
Keeping Count Using the Stack
â€¢ An automaton can use the stack to recognize {0n1n | n â‰¥ 0}
â€“ On reading a 0, push it into the stack
â€“ After the 0s, on reading each 1, pop a 0
â€“ (If a 0 comes after a 1, reject)
â€“ If attempt to pop an empty stack, reject
â€“ If stack not empty at the end, reject
â€“ Else accept
Matching Parenthesis Using the Stack
â€¢ An automaton can use the stack to recognize balanced parenthesis
â€¢ e.g. (())() is balanced, but ())() and (() are not
â€“ On seeing a ( push it on the stack
â€“ On seeing a ) pop a ( from the stack
â€“ If attempt to pop an empty stack, reject
â€“ If stack not empty at the end, reject
â€“ Else accept
1
2 Definition of Pushdown Automata
Pushdown Automata (PDA)
a b b a a b
x
y
x
$
finite-state
control
input
stack
Figure 1: A Pushdown Automaton
â€¢ Like an NFA with -transitions, but with a stack
â€“ Stack depth unlimited: not a finite-state machine
â€“ Non-deterministic: accepts if any thread of execution accepts
â€¢ Has a non-deterministic finite-state control
â€¢ At every step:
â€“ Consume next input symbol (or none) and pop the top symbol on stack (or none)
â€“ Based on current state, consumed input symbol and popped stack symbol, do (non-
deterministically):
1. push a symbol onto stack (or push none)
2. change to a new state
q1 q2
a, xâ†’ y
If at q1, with next input symbol a and top of stack x, then can consume a, pop x, push y onto
stack and move to q2 (any of a, x, y may be )
Pushdown Automata (PDA): Formal Definition
A PDA P = (Q,Î£,Î“, Î´, q0, F ) where
â€¢ Q = Finite set of states
â€¢ Î£ = Finite input alphabet
2
â€¢ Î“ = Finite stack alphabet
â€¢ q0 = Start state
â€¢ F âŠ† Q = Accepting/final states
â€¢ Î´ : QÃ— (Î£ âˆª {})Ã— (Î“ âˆª {})â†’ P(QÃ— (Î“ âˆª {}))
3 Examples of Pushdown Automata
Matching Parenthesis: PDA construction
q0 q qF
, â†’ $ , $â†’ 
(, â†’ (
), (â†’ 
â€¢ First push a â€œbottom-of-the-stackâ€ symbol $ and move to q
â€¢ On seeing a ( push it onto the stack
â€¢ On seeing a ) pop if a ( is in the stack
â€¢ Pop $ and move to final state qF
Matching Parenthesis: PDA execution
( ( ) ) ( ) )
$
q
input
stack
) ) ( ) )
(
(
$
q
) ( ) )
(
$
q
( ) )
$
q
) )
(
$
q
3
)$
q
)
$
!
Palindrome: PDA construction
q0 qâ†“ qâ†‘ qF
, â†’ $ , â†’ 
a, â†’ 
, $â†’ 
a, â†’ a a, aâ†’ 
â€¢ First push a â€œbottom-of-the-stackâ€ symbol $ and move to a pushing state
â€¢ Push input symbols onto the stack
â€¢ Non-deterministically move to a popping state (with or without consuming a single input
symbol)
â€¢ If next input symbol is same as top of stack, pop
â€¢ If $ on top of stack move to accept state
Palindrome: PDA execution
m a d a m
$
qâ†“
a d a m
m
$
qâ†“
d a m
a
m
$
qâ†“
a m
a
m
$
qâ†‘
m
m
$
qâ†‘
$
qâ†‘
qF
4
4 Semantics of a PDA
4.1 Computation
Instantaneous Description
In order to describe a machineâ€™s execution, we need to capture a â€œsnapshotâ€ of the machine that
completely determines future behavior
â€¢ In the case of an NFA (or DFA), it is the state
â€¢ In the case of a PDA, it is the state + stack contents
Definition 1. An instantaneous description of a PDA P = (Q,Î£,Î“, Î´, q0, F ) is a pair ã€ˆq, Ïƒã€‰, where
q âˆˆ Q and Ïƒ âˆˆ Î“âˆ—
Computation
Definition 2. For a PDA P = (Q,Î£,Î“, Î´, q0, F ), string w âˆˆ Î£âˆ—, and instantaneous descriptions
ã€ˆq1, Ïƒ1ã€‰ and ã€ˆq2, Ïƒ2ã€‰, we say ã€ˆq1, Ïƒ1ã€‰ wâˆ’â†’P ã€ˆq2, Ïƒ2ã€‰ iff there is a sequence of instanteous descriptions
ã€ˆr0, s0ã€‰, ã€ˆr1, s1ã€‰, . . . ã€ˆrk, skã€‰ and a sequence x1, x2, . . . xk, where for each i, xi âˆˆ Î£ âˆª {}, such that
â€¢ w = x1x2 Â· Â· Â·xk,
â€¢ r0 = q1, and s0 = Ïƒ1,
â€¢ rk = q2, and sk = Ïƒ2,
â€¢ for every i, (ri+1, b) âˆˆ Î´(ri, xi+1, a) such that si = as and si+1 = bs, where a, b âˆˆ Î“ âˆª {} and
s âˆˆ Î“âˆ—
Example of Computation
Example 3.
q0 q qF
, â†’ $ , $â†’ 
(, â†’ (
), (â†’ 
ã€ˆq0, ã€‰ (()(âˆ’â†’ ã€ˆq, (($ã€‰ because
ã€ˆq0, ã€‰ x1=âˆ’â†’ ã€ˆq, $ã€‰ x2=(âˆ’â†’ ã€ˆq, ($ã€‰ x3=(âˆ’â†’ ã€ˆq, (($ã€‰ x4=)âˆ’â†’ ã€ˆq, ($ã€‰ x5=(âˆ’â†’ ã€ˆq, (($ã€‰
5
4.2 Language Recognized
Acceptance/Recognition
Definition 4. A PDA P = (Q,Î£,Î“, Î´, q0, F ) accepts a string w âˆˆ Î£âˆ— iff for some q âˆˆ F and Ïƒ âˆˆ Î“âˆ—,
ã€ˆq0, ã€‰ wâˆ’â†’P ã€ˆq, Ïƒã€‰
Definition 5. The language recognized/accepted by a PDA P = (Q,Î£,Î“, Î´, q0, F ) is L(P ) = {w âˆˆ
Î£âˆ— | P accepts w}. A language L is said to be accepted/recognized by P if L = L(P ).
4.3 Expressive Power
Expressive Power of CFGs and PDAs
CFGs and PDAs have equivalent expressive powers. More formally, . . .
Theorem 6. For every CFG G, there is a PDA P such that L(G) = L(P ). In addition, for every
PDA P , there is a CFG G such that L(P ) = L(G). Thus, L is context-free iff there is a PDA P
such that L = L(P ).
Proof. Skipped.
6
