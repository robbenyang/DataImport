1 Computing Using a Stack
Beyond Finite Memory: The Stack
• So far we considered automata with finite memory
• Today: automata with access to an infinite stack
• The stack can contain an unlimited number of characters. But
– can read/erase only the top of the stack: pop
– can add to only the top of the stack: push
• On longer inputs, automaton may have more items in the stack
Keeping Count Using the Stack
• An automaton can use the stack to recognize {0n1n | n ≥ 0}
– On reading a 0, push it into the stack
– After the 0s, on reading each 1, pop a 0
– (If a 0 comes after a 1, reject)
– If attempt to pop an empty stack, reject
– If stack not empty at the end, reject
– Else accept
Matching Parenthesis Using the Stack
• An automaton can use the stack to recognize balanced parenthesis
• e.g. (())() is balanced, but ())() and (() are not
– On seeing a ( push it on the stack
– On seeing a ) pop a ( from the stack
– If attempt to pop an empty stack, reject
– If stack not empty at the end, reject
– Else accept
1
2 Definition of Pushdown Automata
Pushdown Automata (PDA)
a b b a a b
x
y
x
$
finite-state
control
input
stack
Figure 1: A Pushdown Automaton
• Like an NFA with -transitions, but with a stack
– Stack depth unlimited: not a finite-state machine
– Non-deterministic: accepts if any thread of execution accepts
• Has a non-deterministic finite-state control
• At every step:
– Consume next input symbol (or none) and pop the top symbol on stack (or none)
– Based on current state, consumed input symbol and popped stack symbol, do (non-
deterministically):
1. push a symbol onto stack (or push none)
2. change to a new state
q1 q2
a, x→ y
If at q1, with next input symbol a and top of stack x, then can consume a, pop x, push y onto
stack and move to q2 (any of a, x, y may be )
Pushdown Automata (PDA): Formal Definition
A PDA P = (Q,Σ,Γ, δ, q0, F ) where
• Q = Finite set of states
• Σ = Finite input alphabet
2
• Γ = Finite stack alphabet
• q0 = Start state
• F ⊆ Q = Accepting/final states
• δ : Q× (Σ ∪ {})× (Γ ∪ {})→ P(Q× (Γ ∪ {}))
3 Examples of Pushdown Automata
Matching Parenthesis: PDA construction
q0 q qF
, → $ , $→ 
(, → (
), (→ 
• First push a “bottom-of-the-stack” symbol $ and move to q
• On seeing a ( push it onto the stack
• On seeing a ) pop if a ( is in the stack
• Pop $ and move to final state qF
Matching Parenthesis: PDA execution
( ( ) ) ( ) )
$
q
input
stack
) ) ( ) )
(
(
$
q
) ( ) )
(
$
q
( ) )
$
q
) )
(
$
q
3
)$
q
)
$
!
Palindrome: PDA construction
q0 q↓ q↑ qF
, → $ , → 
a, → 
, $→ 
a, → a a, a→ 
• First push a “bottom-of-the-stack” symbol $ and move to a pushing state
• Push input symbols onto the stack
• Non-deterministically move to a popping state (with or without consuming a single input
symbol)
• If next input symbol is same as top of stack, pop
• If $ on top of stack move to accept state
Palindrome: PDA execution
m a d a m
$
q↓
a d a m
m
$
q↓
d a m
a
m
$
q↓
a m
a
m
$
q↑
m
m
$
q↑
$
q↑
qF
4
4 Semantics of a PDA
4.1 Computation
Instantaneous Description
In order to describe a machine’s execution, we need to capture a “snapshot” of the machine that
completely determines future behavior
• In the case of an NFA (or DFA), it is the state
• In the case of a PDA, it is the state + stack contents
Definition 1. An instantaneous description of a PDA P = (Q,Σ,Γ, δ, q0, F ) is a pair 〈q, σ〉, where
q ∈ Q and σ ∈ Γ∗
Computation
Definition 2. For a PDA P = (Q,Σ,Γ, δ, q0, F ), string w ∈ Σ∗, and instantaneous descriptions
〈q1, σ1〉 and 〈q2, σ2〉, we say 〈q1, σ1〉 w−→P 〈q2, σ2〉 iff there is a sequence of instanteous descriptions
〈r0, s0〉, 〈r1, s1〉, . . . 〈rk, sk〉 and a sequence x1, x2, . . . xk, where for each i, xi ∈ Σ ∪ {}, such that
• w = x1x2 · · ·xk,
• r0 = q1, and s0 = σ1,
• rk = q2, and sk = σ2,
• for every i, (ri+1, b) ∈ δ(ri, xi+1, a) such that si = as and si+1 = bs, where a, b ∈ Γ ∪ {} and
s ∈ Γ∗
Example of Computation
Example 3.
q0 q qF
, → $ , $→ 
(, → (
), (→ 
〈q0, 〉 (()(−→ 〈q, (($〉 because
〈q0, 〉 x1=−→ 〈q, $〉 x2=(−→ 〈q, ($〉 x3=(−→ 〈q, (($〉 x4=)−→ 〈q, ($〉 x5=(−→ 〈q, (($〉
5
4.2 Language Recognized
Acceptance/Recognition
Definition 4. A PDA P = (Q,Σ,Γ, δ, q0, F ) accepts a string w ∈ Σ∗ iff for some q ∈ F and σ ∈ Γ∗,
〈q0, 〉 w−→P 〈q, σ〉
Definition 5. The language recognized/accepted by a PDA P = (Q,Σ,Γ, δ, q0, F ) is L(P ) = {w ∈
Σ∗ | P accepts w}. A language L is said to be accepted/recognized by P if L = L(P ).
4.3 Expressive Power
Expressive Power of CFGs and PDAs
CFGs and PDAs have equivalent expressive powers. More formally, . . .
Theorem 6. For every CFG G, there is a PDA P such that L(G) = L(P ). In addition, for every
PDA P , there is a CFG G such that L(P ) = L(G). Thus, L is context-free iff there is a PDA P
such that L = L(P ).
Proof. Skipped.
6
