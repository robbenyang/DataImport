1 NFA vs. DFA
Expressive Power of NFAs and DFAs
â€¢ Is there a language that is recognized by a DFA but not by any NFAs? No!
â€¢ Is there a language that is recognized by an NFA but not by any DFAs? No!
Main Theorem
Theorem 1. A language L is recognized by a DFA if and only if there is an NFA N such that
L(N) = L.
In other words:
â€¢ For any DFA D, there is an NFA N such that L(N) = L(D), and
â€¢ For any NFA N , there is a DFA D such that L(D) = L(N).
2 NFAs for Regular Languages
Converting DFAs to NFAs
Proposition 2. For any DFA D, there is an NFA N such that L(N) = L(D).
Proof. Is a DFA an NFA? Essentially yes! Syntactically, not quite. The formal definition of DFA
has Î´DFA : QÃ— Î£â†’ Q whereas Î´NFA : QÃ— (Î£ âˆª {})â†’ P(Q).
For DFA D = (Q,Î£, Î´D, q0, F ), define an â€œequivalentâ€ NFA N = (Q,Î£, Î´N , q0, F ) that has the
exact same set of states, initial state and final states. Only difference is in the transition function.
Î´N (q, a) = {Î´D(q, a)}
for a âˆˆ Î£ and Î´N (q, ) = âˆ… for all q âˆˆ Q.
3 NFAs recognize Regular Languages
3.1 Simulating an NFA
Simulating an NFA on Your Computer
NFA Acceptance Problem
Given an NFA N and an input string w, does N accept w?
1
How do we write a computer program to solve the NFA Acceptance problem?
Two Views of Nondeterminsm
Guessing View
At each step, the NFA â€œguessesâ€ one of the choices available; the NFA will guess an â€œaccepting
sequence of choicesâ€ if such a one exists.
Very useful in reasoning about NFAs and in designing NFAs.
Parallel View
At each step the machine â€œforksâ€ threads corresponding to each of the possible next states.
Very useful in simulating/running NFA on inputs.
Algorithm for Simulating an NFA
Algorithm
Keep track of the current state of each of the active threads.
Example 3.
q0 q1
0, 1
1
0, 1
Figure 1: Example NFA N
Consider the input w = 111. The execution (listing only the states of currently active threads)
is
ã€ˆq0ã€‰ 1âˆ’â†’ ã€ˆq0, q1ã€‰ 1âˆ’â†’ ã€ˆq0, q1, q1ã€‰
1âˆ’â†’ ã€ˆq0, q1, q1, q1ã€‰
Algorithm
With optimizations
Observations
â€¢ Exponentially growing memory: more threads for longer inputs. Can we do better?
â€¢ Exact order of threads is not important
â€“ It is unimportant whether the 5th thread or the 1st thread is in state q.
â€¢ If two threads are in the same state, then we can ignore one of the threads
â€“ Threads in the same state will â€œbehaveâ€ identically; either one of the descendent threads
of both will reach a final state, or none of the descendent threads of both will reach a
final state
2
Parsimonious Algorithm in Action
Example 4.
q0 q1
0, 1
1
0, 1
Figure 2: Example NFA N
Consider the input w = 111. The execution (listing only the states of currently active threads)
is
{q0} 1âˆ’â†’ {q0, q1} 1âˆ’â†’ {q0, q1}
1âˆ’â†’ {q0, q1}
3.2 DFAs equivalent to NFAs
Revisiting NFA Simulation Algorithm
â€¢ Need to keep track of the states of the active threads
â€“ Unordered: Without worrying about exactly which thread is in what state
â€“ No Duplicates: Keeping only one copy if there are multiple threads in same state
â€¢ How much memory is needed?
â€“ If Q is the set of states of the NFA N , then we need to keep a subset of Q!
â€“ Can be done in |Q| bits of memory (i.e., 2|Q| states), which is finite!!
Constructing an Equivalent DFA
â€¢ The DFA runs the simulation algorithm
â€¢ DFA remembers the current states of active threads without duplicates, i.e., maintains a
subset of states of the NFA
â€¢ When a new symbol is read, it updates the states of the active threads
â€¢ Accepts whenever one of the threads is in a final state
Example of Equivalent DFA
3
q0 q1
0, 1
1
0, 1
Figure 3: Example NFA N
{q0} {q0, q1}
{q1} {}
0
0, 1
0, 10, 1
1
Figure 4: DFA D equivalent to N
Recall . . .
Definition 5. For an NFA M = (Q,Î£, Î´, q0, F ), string w, and state q1 âˆˆ Q, we say Î´Ë†M (q1, w) to
denote states of all the active threads of computation on input w from q1. Formally,
Î´Ë†M (q1, w) = {q âˆˆ Q | q1 wâˆ’â†’M q}
Formal Construction
Given NFA N = (Q,Î£, Î´, q0, F ), construct DFA det(N) = (Q
â€²,Î£, Î´â€², qâ€²0, F â€²) as follows.
â€¢ Qâ€² = P(Q)
â€¢ qâ€²0 = Î´Ë†N (q0, )
â€¢ F â€² = {A âŠ† Q |A âˆ© F 6= âˆ…}
â€¢ Î´â€²({q1, q2, . . . qk}, a) = Î´Ë†N (q1, a) âˆª Î´Ë†N (q2, a) âˆª Â· Â· Â· âˆª Î´Ë†N (qk, a) or more concisely,
Î´â€²(A, a) =
â‹ƒ
qâˆˆA
Î´Ë†N (q, a)
4
Correctness
Lemma 6. For any NFA N , the DFA det(N) is equivalent to it, i.e., L(N) = L(det(N)).
Proof Idea
Need to show
âˆ€w âˆˆ Î£âˆ—. det(N) accepts w iff N accepts w
âˆ€w âˆˆ Î£âˆ—.Î´Ë†det(N)(qâ€²0, w) âˆ© F â€² 6= âˆ… iff Î´Ë†N (q0, w) âˆ© F 6= âˆ…
âˆ€w âˆˆ Î£âˆ—. for {A} = Î´Ë†det(N)(qâ€²0, w), A âˆ© F 6= âˆ… iff Î´Ë†N (q0, w) âˆ© F 6= âˆ…
We will instead prove a stronger claim. There are two possible ways to strengthen this:
(a) âˆ€w âˆˆ Î£âˆ—. Î´Ë†det(N)(qâ€²0, w) = {A} iff Î´Ë†N (q0, w) = A. In other words, this says that the state
of the DFA after reading some string is exactly the set of states the NFA could be in after
reading the same string.
(b) âˆ€w âˆˆ Î£âˆ—., for all -closed sets A âŠ† Q (-closed to be defined later), Î´Ë†det(N)(A,w) âˆ© F â€² 6= âˆ…
iff for some q âˆˆ A, Î´Ë†N (q, w) âˆ© F 6= âˆ…. In other words, (ignoring the technical condition of
-closed sets) this says that the DFA det(N) accepts w from a state A iff the NFA N accepts
w from some state in A.
Notice that both statements (a) and (b) (modulo the notion of -closure), if proved, would prove
that the construction is correct. Both the strengthenings (a) and (b) can be proved by induction,
and their proofs have subtle differences. We, therefore, present both proofs completely.
Correctness Proof I
Lemma 7. âˆ€w âˆˆ Î£âˆ—. Î´Ë†det(N)(qâ€²0, w) = {A} iff Î´Ë†N (q0, w) = A.
Proof. By induction on |w|
â€¢ Base Case |w| = 0: Then w = . Now
Î´Ë†det(N)(q
â€²
0, ) = {qâ€²0} = {Î´Ë†N (q0, )} defn. of Î´Ë†det(N) and defn. of qâ€²0
â€¢ Induction Hypothesis: Assume inductively that the statement holds âˆ€w. |w| < n
â€¢ Induction Step: If |w| = n then w = ua with |u| = nâˆ’ 1 and a âˆˆ Î£.
Î´Ë†det(N)(q
â€²
0, ua) = {A} iff qâ€²0 uaâˆ’â†’det(N) A
defn. of Î´Ë† and det(N) is deterministic
iff âˆƒB. qâ€²0 uâˆ’â†’det(N) B and B aâˆ’â†’det(N) A
property of âˆ’â†’ proved in lecture 3
iff âˆƒB. Î´Ë†det(N)(qâ€²0, u) = {B} and B aâˆ’â†’det(N) A
det(N) is deterministic and defn. of Î´Ë†
iff âˆƒB. Î´Ë†N (q0, u) = B and A = âˆªqâˆˆB Î´Ë†N (q, a)
ind. hyp. and defn. of transition in det(N)
iff Î´Ë†N (q0, ua) = A
see Lemma below
5
To complete the proof, we need to prove the following lemma
Lemma 8. âˆƒB. Î´Ë†N (q0, u) = B and A = âˆªqâˆˆB Î´Ë†N (q, a) iff Î´Ë†N (q0, ua) = A.
Proof. Observe that A = âˆªqâˆˆB Î´Ë†N (q, a) iff (q âˆˆ A iff âˆƒqâ€² âˆˆ B s.t. qâ€² aâˆ’â†’N q). Thus we have,
Î´Ë†N (q0, u) = B and A = âˆªqâˆˆB Î´Ë†N (q, a)
iff
(q âˆˆ A iff âˆƒqâ€². q0 uâˆ’â†’N qâ€² and qâ€² aâˆ’â†’N q)
Now since we know that q1
uvâˆ’â†’N q2 iff there is qâ€² s.t. q1 uâˆ’â†’N qâ€² and qâ€² vâˆ’â†’N q2, we can conclude
Î´Ë†N (q0, u) = B and A = âˆªqâˆˆB Î´Ë†N (q, a)
iff
(q âˆˆ A iff âˆƒqâ€². q0 uâˆ’â†’N qâ€² and qâ€² aâˆ’â†’N q)
iff
(q âˆˆ A iff q0 uaâˆ’â†’N q)
iff
Î´Ë†N (q0, ua) = A
where the last step is a consequence of the definition of Î´Ë†N .
Correctness Proof II
Definition 9. Let Q be the states of NFA N and let A âŠ† Q. A is said to be -closed iff for every
q âˆˆ A, Î´Ë†N (q, ) âŠ† A. In other words, any state that can be reached from a state in A by following
only -transitions, again belongs to A.
Example 10. Trivial examples of -closed sets include âˆ… and Q. An important example (that will
be critical to this proof of correctness) is the initial state of DFA det(N) qâ€²0 = Î´Ë†N (q0, ).
Lemma 11. For every string w âˆˆ Î£âˆ—, for every A âŠ† Q that is -closed, Î´Ë†det(N)(A,w) âˆ© F â€² 6= âˆ… iff
for some q âˆˆ A, Î´Ë†N (q, w) âˆ© F 6= âˆ….
Discussion
Before proving the lemma, let us highlight one point about the lemma. Ideally, we would have liked
to prove the above lemma without the condition on -closure, i.e., we would have liked to prove
that for every string w, for every A âŠ† Q, Î´Ë†det(N)(A,w)âˆ©F â€² 6= âˆ… iff for some q âˆˆ A, Î´Ë†N (q, w)âˆ©F 6= âˆ….
Unfortunately, this stronger condition does not hold, as you will see in the proof of the base case
below. However, inspite of this, when A is taken to be qâ€²0, which we pointed out is an -closed set,
the above lemma specializes to the statement establishing the correctness of the DFA construction
which is good enough for our purposes.
Proof. We will prove this by induction on |w|.
6
â€¢ Base Case |w| = 0: Then w = . Now for any set A, Î´Ë†det(N)(A, ) = {A}. Thus, Î´Ë†det(N)(A, )âˆ©
F â€² 6= âˆ… iff A âˆ© F 6= âˆ…. If A is -closed then Î´Ë†N (A, ) = A and so we have
Î´Ë†det(N)(A, ) âˆ© F â€² 6= âˆ… iff A(= Î´Ë†N (A, )) âˆ© F 6= âˆ…
Thus, we have established the base case.
Notice that the crucial step where -closedness is used â€” it is in arguing that Î´Ë†N (A, ) = A.
Without this the base case cannot be proved, and in fact does not hold.
â€¢ Induction Hypothesis: Assume inductively that the statement holds âˆ€w. |w| < n
â€¢ Induction Step: If |w| = n then w = au with |u| = nâˆ’ 1 and a âˆˆ Î£ 1.
Now Î´Ë†det(N)(A,w = au) = {C} iff there is a B s.t. Î´â€²(A, a) = B and Î´Ë†det(N)(B, u) = {C}.
The first important observation we make is that if A is -closed then so is B; we will prove
this later after completing this proof. Thus, we can use the induction hypothesis on the
computation on string u from state B.
Î´Ë†det(N)(A,w = au) = {C} and C âˆˆ F â€²
iff
âˆƒB. Î´â€²(A, a) = B, Î´Ë†det(N)(B, u) = {C} and C âˆˆ F â€² defn. of Î´Ë†det(N)
iff
âˆƒB. Î´â€²(A, a) = B, âˆƒq âˆˆ B. Î´Ë†N (q, u) âˆ© F 6= âˆ… B is -closed and ind. hyp. on u
iff
âˆƒB. Î´â€²(A, a) = B, âˆƒq âˆˆ B. âˆƒq2 âˆˆ F. q uâˆ’â†’N q2 defn. of Î´Ë†N
iff
âˆƒq1 âˆˆ A.âˆƒq.âˆƒq2 âˆˆ F. q1 aâˆ’â†’N q and q uâˆ’â†’N q2 defn. of Î´â€² transition of det(N)
iff
âˆƒq1 âˆˆ A.âˆƒq2 âˆˆ F. q1 w=auâˆ’â†’ N q2
iff
âˆƒq1 âˆˆ A. Î´Ë†N (q, w) âˆ© F 6= âˆ…
To complete this proof we need to show
Lemma 12. If A is -closed and Î´â€²(A, a) = B then B is -closed.
Proof. Let q âˆˆ B be an arbitrary element of B. Need to show that if q âˆ’â†’N qâ€² then qâ€² âˆˆ B.
Observe that from the definition of Î´â€², we have q âˆˆ B implies there is q1 âˆˆ A such that q1 aâˆ’â†’N q.
Now if q
âˆ’â†’N qâ€² then we have q1 a=aâˆ’â†’N qâ€². Again by the definition of Î´â€² this means that qâ€² âˆˆ B,
which completes the proof.
Relevant States
1Notice the difference in the form of w when compared to proof I. In proof I we took w = ua in the induction step.
7
The formal definition of the DFA has many states, several of which are unreachable from the initial
state. To make the algorithm simpler for a human to implement (and for the resulting DFA to be
readable), one can include only the reachable states. To do this,
1. Start by drawing the initial state of the DFA.
2. While there are states with missing transitions, draw the missing transitions creating any new
states that maybe needed.
3. Step 2 is repeated until transitions from every state has been drawn.
4. Figure out which states are final, and mark them appropriately.
Another Example
q0
q1
q2
q3
 0
1 
Figure 5: Example NFA N
{q0, q1} {q2, q3}
{q3} {}
1
0 0, 1
0, 1
0, 1
Figure 6: DFA Dâ€² for N (only relevant states)
8
