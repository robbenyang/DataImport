9/2/13 1 
Programming Languages and 
Compilers (CS 421) 
Elsa L Gunter 
2112 SC, UIUC 
http://courses.engr.illinois.edu/cs421 
Based in part on slides by Mattox Beckman, as updated 
by Vikram Adve and Gul Agha 
9/2/13 2 
Consider this code:  
 
let x = 27;; 
let f x = 
      let x = 5 in 
           (fun x -> print_int x) 10;; 
f 12;; 
 
What value is printed? 
 5 
10 
12 
27 
Scoping Question 
9/2/13 3 
Question 
n  Observation: Functions are first-class values 
in this language 
n  Question: What value does the environment 
record for a function variable? 
n  Related question: What is the value of a fun 
expression? 
n  Answer: a closure 
9/2/13 4 
Save the Environment! 
n  A closure is a pair of an environment and an 
association of a sequence of variables (the 
input variables) with an expression (the 
function body), written: 
< (v1,…,vn) → exp, ρ > 
n  Where ρ is the environment in effect when 
the function is defined (for a simple function) 
9/2/13 5 
Closure for plus_x 
n  When plus_x was defined, had environment: 
ρplus_x = {x → 12, …, y → 24, …} 
n  Recall: let plus_x y = y + x 
   is really let plus_x = fun y -> y + x 
n  Closure for plus_x: 
<y → y + x, ρplus_x > 
n  Environment just after plus_x defined: 
 {plus_x → <y → y + x, ρplus_x >} + ρplus_x 
9/2/13 6 
Evaluation of Application of plus_x;; 
n  Have environment: 
 ρ = {plus_x → <y → y + x, ρplus_x >, … , 
                y → 3, …} 
 where ρplus_x  = {x → 12, … , y →   24, …} 
n  Eval (plus_x y, ρ) rewrites to 
n  Eval (app <y → y + x, ρplus_x > 3, ρ) 
rewrites to 
n  Eval (y + x, {y → 3} +ρplus_x ) rewrites to 
n  Eval (3 + 12 , ρplus_x ) = 15 
Functions on tuples 
# let plus_pair (n,m) = n + m;; 
val plus_pair : int * int -> int = <fun> 
# plus_pair (3,4);; 
- : int = 7 
# let double x = (x,x);; 
val double : 'a -> 'a * 'a = <fun> 
# double 3;; 
- : int * int = (3, 3) 
# double "hi";; 
- : string * string = ("hi", "hi") 
9/2/13 7 
9/2/13 8 
Closure for plus_pair 
n  Assume ρplus_pair was the environment just 
before plus_pair defined 
n  Closure for plus_pair: 
<(n,m) → n + m, ρplus_pair> 
n  Environment just after plus_pair defined: 
 {plus_pair → <(n,m) → n + m, ρplus_pair >} 
+ ρplus_pair 
9/2/13 9 
Evaluation of Application with Closures 
n  In environment ρ, evaluate left term to closure,                 
c = <(x1,…,xn) → b, ρ> 
n  (x1,…,xn) variables in (first) argument  
n   Evaluate the right term to values, (v1,…,vn) 
n  Update the environment ρ to 
   ρ’ = {x1 → v1,…, xn →vn}+ ρ 
n  Evaluate body b in environment ρ’ 
9/2/13 10 
Evaluation of Application of plus_pair 
n  Assume environment  
ρ = {x → 3…,  
        plus_pair →<(n,m) →n + m, ρplus_pair>} +        
        ρplus_pair 
n  Eval (plus_pair (4,x), ρ)= 
n  Eval (app <(n,m) →n + m, ρplus_pair> (4,x), ρ)) = 
n  Eval (app <(n,m) →n + m, ρplus_pair> (4,3), ρ)) = 
n  Eval (n + m, {n -> 4, m -> 3} + ρplus_pair) = 
n  Eval (4 + 3, {n -> 4, m -> 3} + ρplus_pair) = 7 
Closure question 
n  If we start in an empty environment, and we 
execute: 
 let f = fun n -> n + 5;; 
 (* 0 *) 
 let pair_map g (n,m) = (g n, g m);; 
 let f = pair_map f;; 
 
What is the environment at (* 0 *)? 
9/3/13 11 
Answer 
let f = fun n -> n + 5;; 
 
ρ0 = {f → <n → n + 5, { }>} 
9/3/13 12 
Closure question 
n  If we start in an empty environment, and we 
execute: 
 let f = fun => n + 5;; 
 let pair_map g (n,m) = (g n, g m);; 
 (* 1 *) 
 let f = pair_map f;; 
 
What is the environment at (* 1 *)? 
9/3/13 13 
Answer 
ρ0 = {f → <n → n + 5, { }>} 
let pair_map g (n,m) = (g n, g m);; 
 
ρ1 = {pair_map →  
         <g →  fun (n,m) -> (g n, g m), 
           {f → <n → n + 5, { }>}>, 
         f → <n → n + 5, { }>} 
 
9/3/13 14 
Closure question 
n  If we start in an empty environment, and we 
execute: 
 let f = fun => n + 5;; 
 let pair_map g (n,m) = (g n, g m);; 
 let f = pair_map f;; 
(* 2*) 
 
What is the environment at (* 2 *)? 
9/3/13 15 
Answer 
ρ1 = {pair_map →  
  <g →  fun (n,m) -> (g n, g m),{f → <n → n + 5, { }>}>, 
  f → <n → n + 5, { }>} 
let f = pair_map f;; 
 
9/3/13 16 
Answer 
ρ1 = {pair_map →  
<g →  fun (n,m) -> (g n, g m),{f → <n → n + 5, { }>}>, 
  f → <n → n + 5, { }>} 
let f = pair_map f;; 
ρ2 = {f → <(n,m) →(g n, g m), 
                 {g → <n → n + 5, { }>, 
                  f → <n → n + 5, { }>}>, 
 pair_map → <g →  fun (n,m) -> (g n, g m), 
                      {f → <n → n + 5, { }>}>} 
 
9/3/13 17 
9/2/13 18 
• Each clause: pattern on 
left, expression on right 
• Each x, y has scope of 
only its clause 
• Use first matching clause 
Match Expressions 
# let triple_to_pair triple = 
  match triple 
  with (0, x, y) -> (x, y) 
  | (x, 0, y) -> (x, y) 
  | (x, y, _) -> (x, y);; 
val triple_to_pair : int * int * int -> int * int = 
<fun> 
9/2/13 19 
Curried vs Uncurried 
n  Recall  
val add_three : int -> int -> int -> int = <fun> 
n  How does it differ from 
# let add_triple (u,v,w) = u + v + w;; 
val add_triple : int * int * int -> int = <fun> 
n  add_three is curried; 
n  add_triple is uncurried 
9/2/13 20 
Curried vs Uncurried 
# add_triple (6,3,2);; 
- : int = 11 
# add_triple 5 4;; 
Characters 0-10: 
  add_triple 5 4;; 
  ^^^^^^^^^^ 
This function is applied to too many arguments, 
maybe you forgot a `;' 
# fun x -> add_triple (5,4,x);; 
: int -> int = <fun> 
9/2/13 21 
Recursive Functions 
# let rec factorial n = 
    if n = 0 then 1 else n * factorial (n - 1);; 
  val factorial : int -> int = <fun> 
# factorial 5;; 
- : int = 120 
# (* rec  is needed for recursive function 
declarations *) 
    
9/2/13 22 
Recursion Example 
Compute n2 recursively using: 
n2 = (2 * n - 1) + (n - 1)2 
 
# let rec nthsq n =         (* rec for recursion *) 
   match n              (* pattern matching for cases *) 
   with 0 -> 0                  (* base case *) 
   | n -> (2 * n -1)           (* recursive case *) 
           + nthsq (n -1);;   (* recursive call *) 
val nthsq : int -> int = <fun> 
# nthsq 3;; 
-  : int = 9 
Structure of recursion similar to inductive proof 
9/2/13 23 
Recursion and Induction 
# let rec nthsq n = match n with 0 -> 0 
        | n -> (2 * n - 1) + nthsq (n - 1) ;; 
n  Base case is the last case; it stops the computation 
n  Recursive call must be to arguments that are 
somehow smaller - must progress to base case 
n  if or match must contain base case 
n  Failure of these may cause failure of termination 
9/2/13 24 
Lists 
n  First example of a recursive datatype (aka 
algebraic datatype) 
n  Unlike tuples, lists are homogeneous in 
type (all elements same type) 
9/2/13 25 
Lists 
n  List can take one of two forms: 
n  Empty list, written [ ] 
n  Non-empty list, written  x :: xs 
n  x is head element, xs is tail list, :: called 
“cons” 
n  Syntactic sugar: [x] == x :: [ ] 
n  [ x1; x2; …; xn] == x1 :: x2 :: … :: xn :: [ ] 
9/2/13 26 
Lists 
# let fib5 = [8;5;3;2;1;1];; 
val fib5 : int list = [8; 5; 3; 2; 1; 1] 
# let fib6 = 13 :: fib5;; 
val fib6 : int list = [13; 8; 5; 3; 2; 1; 1] 
# (8::5::3::2::1::1::[ ]) = fib5;; 
- : bool = true 
# fib5 @ fib6;; 
- : int list = [8; 5; 3; 2; 1; 1; 13; 8; 5; 3; 2; 1; 
1] 
9/2/13 27 
Lists are Homogeneous 
# let bad_list = [1; 3.2; 7];; 
Characters 19-22: 
  let bad_list = [1; 3.2; 7];; 
                             ^^^ 
This expression has type float but is here 
used with type int 
9/2/13 28 
Question 
n  Which one of these lists is invalid? 
1.  [2; 3; 4; 6] 
2.  [2,3; 4,5; 6,7] 
3.  [(2.3,4); (3.2,5); (6,7.2)] 
4.  [[“hi”; “there”]; [“wahcha”]; [ ]; [“doin”]] 
9/2/13 29 
Answer 
n  Which one of these lists is invalid? 
1.  [2; 3; 4; 6] 
2.  [2,3; 4,5; 6,7] 
3.  [(2.3,4); (3.2,5); (6,7.2)] 
4.  [[“hi”; “there”]; [“wahcha”]; [ ]; [“doin”]] 
§  3 is invalid because of last pair 
9/2/13 30 
Functions Over Lists 
# let rec double_up list = 
    match list 
    with [ ] -> [ ]  (* pattern before ->, 
                             expression after *) 
       | (x :: xs) -> (x :: x :: double_up xs);; 
val double_up : 'a list -> 'a list = <fun> 
# let fib5_2 = double_up fib5;; 
val fib5_2 : int list = [8; 8; 5; 5; 3; 3; 2; 2; 1; 
1; 1; 1] 
9/2/13 31 
Functions Over Lists 
# let silly = double_up ["hi"; "there"];; 
val silly : string list = ["hi"; "hi"; "there"; "there"] 
# let rec poor_rev list = 
  match list 
  with [] -> [] 
     | (x::xs) -> poor_rev xs @ [x];; 
val poor_rev : 'a list -> 'a list = <fun> 
# poor_rev silly;; 
- : string list = ["there"; "there"; "hi"; "hi"] 
Question: Length of list 
n  Problem: write code for the length of the list 
n  How to start? 
let length l =  
9/5/13 32 
Question: Length of list 
n  Problem: write code for the length of the list 
n  How to start? 
let length l = 
    match l with 
  
9/5/13 33 
Question: Length of list 
n  Problem: write code for the length of the list 
n  What patterns should we match against? 
let length l = 
    match l with 
9/5/13 34 
Question: Length of list 
n  Problem: write code for the length of the list 
n  What patterns should we match against? 
let length l = 
    match l with [] => 
     | (a :: bs) =>  
9/5/13 35 
Question: Length of list 
n  Problem: write code for the length of the list 
n  What result do we give when l is empty? 
let length l = 
    match l with [] => 0 
     | (a :: bs) =>  
9/5/13 36 
Question: Length of list 
n  Problem: write code for the length of the list 
n  What result do we give when l is not empty? 
let length l = 
    match l with [] => 0 
     | (a :: bs) =>  
9/5/13 37 
Question: Length of list 
n  Problem: write code for the length of the list 
n  What result do we give when l is not empty? 
let length l = 
    match l with [] => 0 
     | (a :: bs) => 1 + length bs 
9/5/13 38 
Same Length 
n  How can we efficiently answer if two lists 
have the same length? 
9/5/13 39 
Same Length 
n  How can we efficiently answer if two lists 
have the same length? 
let same_length list1 list2 = 
    match list1 with [] -> 
       (match list2 with [] -> true 
         | (y::ys) -> false) 
    | (x::xs) ->  
       (match list2 with [] -> false 
         | (y::ys) -> same_length xs ys) 
 9/5/13 40 
9/2/13 41 
Higher Order Functions 
n  A function is higher-order if it takes a 
function as an argument or returns one as 
a result 
n  Example: 
# let compose f g = fun x -> f (g x);; 
val compose : ('a -> 'b) -> ('c -> 'a) -> 'c -> 
'b = <fun> 
n  The type ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b 
is a higher order type because of             
('a -> 'b) and  ('c -> 'a) and  -> 'c -> 'b  
9/2/13 42 
Thrice 
n  Recall: 
# let thrice f x = f (f (f x));; 
val thrice : ('a -> 'a) -> 'a -> 'a = <fun> 
n  How do you write thrice with compose? 
9/2/13 43 
Thrice 
n  Recall: 
# let thrice f x = f (f (f x));; 
val thrice : ('a -> 'a) -> 'a -> 'a = <fun> 
n  How do you write thrice with compose? 
# let thrice f = compose f (compose f f);; 
val thrice : ('a -> 'a) -> 'a -> 'a = <fun> 
n  Is this the only way? 
9/2/13 44 
Partial Application 
# (+);; 
- : int -> int -> int = <fun> 
# (+) 2 3;; 
- : int = 5 
# let plus_two = (+) 2;; 
val plus_two : int -> int = <fun> 
# plus_two 7;; 
- : int = 9 
n  Patial application also called sectioning 
9/2/13 45 
Lambda Lifting 
n  You must remember the rules for evaluation 
when you use partial application 
# let add_two = (+) (print_string "test\n"; 2);; 
test 
val add_two : int -> int = <fun> 
# let add2 =     (* lambda lifted *) 
    fun x -> (+) (print_string "test\n"; 2) x;; 
val add2 : int -> int = <fun> 
9/2/13 46 
Lambda Lifting 
# thrice add_two 5;; 
- : int = 11 
# thrice add2 5;; 
test 
test 
test 
- : int = 11 
n  Lambda lifting delayed the evaluation of the 
argument to (+) until the second argument 
was supplied 
9/2/13 47 
Partial Application and “Unknown Types” 
n  Recall  compose plus_two:  
# let f1 = compose plus_two;; 
val f1 : ('_a -> int) -> '_a -> int = <fun> 
n  Compare to lambda lifted version: 
# let f2 = fun g ->  compose plus_two g;; 
val f2 : ('a -> int) -> 'a -> int = <fun> 
n  What is the difference? 
9/2/13 48 
Partial Application and “Unknown Types” 
n  ‘_a can only be instantiated once for an expression 
# f1 plus_two;; 
- : int -> int = <fun> 
# f1 List.length;; 
Characters 3-14: 
  f1 List.length;; 
     ^^^^^^^^^^^ 
This expression has type 'a list -> int but is here used 
with type int -> int 
9/2/13 49 
Partial Application and “Unknown Types” 
n  ‘a can be repeatedly instantiated 
 
# f2 plus_two;; 
- : int -> int = <fun> 
# f2 List.length;; 
- : '_a list -> int = <fun> 
9/2/13 50 
Functions Over Lists 
# let rec map f list = 
  match list 
  with [] -> [] 
  | (h::t) -> (f h) :: (map f t);; 
val map : ('a -> 'b) -> 'a list -> 'b list = <fun> 
# map plus_two fib5;; 
- : int list = [10; 7; 5; 4; 3; 3] 
# map (fun x -> x - 1) fib6;; 
: int list = [12; 7; 4; 2; 1; 0; 0] 
9/2/13 51 
Iterating over lists 
# let rec fold_left f a list = 
  match list 
  with [] -> a 
  | (x :: xs) -> fold_left f (f a x) xs;; 
val fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a = 
<fun> 
# fold_left 
   (fun () -> print_string) 
   () 
   ["hi"; "there"];; 
hithere- : unit = () 
9/2/13 52 
Iterating over lists 
# let rec fold_right f list b = 
  match list 
  with [] -> b 
  | (x :: xs) -> f x (fold_right f xs b);; 
val fold_right : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b = 
<fun> 
# fold_right 
    (fun s -> fun () -> print_string s) 
    ["hi"; "there"] 
    ();; 
therehi- : unit = () 
9/2/13 53 
Structural Recursion 
n  Functions on recursive datatypes (eg lists) 
tend to be recursive 
n  Recursion over recursive datatypes generally 
by structural recursion 
n  Recursive calls made to components of structure 
of the same recursive type 
n  Base cases of recursive types stop the recursion 
of the function 
9/2/13 54 
Structural Recursion : List Example 
# let rec length list = match list 
  with [ ] -> 0   (* Nil case *) 
  | x :: xs -> 1 + length xs;;  (* Cons case *) 
val length : 'a list -> int = <fun> 
# length [5; 4; 3; 2];; 
- : int = 4 
n  Nil case [ ]  is base case 
n  Cons case recurses on component list xs 
9/2/13 55 
Forward Recursion 
n  In Structural Recursion, split input into 
components and (eventually) recurse 
n  Forward Recursion form of Structural 
Recursion 
n  In forward recursion, first call the function 
recursively on all recursive components, and 
then build final result from partial results 
n  Wait until whole structure has been 
traversed to start building answer 
9/2/13 56 
Forward Recursion: Examples 
# let rec double_up list = 
    match list 
    with [ ] -> [ ] 
       | (x :: xs) -> (x :: x :: double_up xs);; 
val double_up : 'a list -> 'a list = <fun> 
 
# let rec poor_rev list = 
  match list 
  with [] -> [] 
     | (x::xs) -> poor_rev xs @ [x];; 
val poor_rev : 'a list -> 'a list = <fun> 
9/2/13 57 
Encoding Recursion with Fold 
# let rec append list1 list2 = match list1 with 
  [ ] -> list2 | x::xs -> x :: append xs list2;; 
val append : 'a list -> 'a list -> 'a list = <fun> 
 
    Base Case        Operation    Recursive Call  
 
# let append list1 list2 =  
   fold_right (fun x y -> x :: y) list1 list2;; 
val append : 'a list -> 'a list -> 'a list = <fun> 
# append [1;2;3] [4;5;6];; 
 - : int list = [1; 2; 3; 4; 5; 6] 
9/2/13 58 
Mapping Recursion 
n  One common form of structural recursion 
applies a function to each element in the 
structure 
# let rec doubleList list = match list 
   with [ ] -> [ ] 
   | x::xs -> 2 * x :: doubleList xs;; 
val doubleList : int list -> int list = <fun> 
# doubleList [2;3;4];; 
- : int list = [4; 6; 8] 
9/2/13 59 
Mapping Recursion 
n  Can use the higher-order recursive map 
function instead of direct recursion 
# let doubleList list = 
    List.map (fun x -> 2 * x) list;; 
val doubleList : int list -> int list = <fun> 
# doubleList [2;3;4];; 
- : int list = [4; 6; 8] 
n  Same function, but no rec 
9/2/13 60 
Folding Recursion 
n  Another common form “folds” an operation 
over the elements of the structure 
# let rec multList list = match list 
  with [ ] -> 1 
  | x::xs -> x * multList xs;; 
val multList : int list -> int = <fun> 
# multList [2;4;6];; 
- : int = 48 
n  Computes (2 * (4 * (6 * 1))) 
9/2/13 61 
Folding Recursion 
n  multList folds to the right 
n  Same as: 
# let multList list = 
    List.fold_right 
    (fun x -> fun p -> x * p) 
    list 1;; 
val multList : int list -> int = <fun> 
# multList [2;4;6];; 
- : int = 48 
9/2/13 62 
How long will it take? 
n  Remember the big-O notation from CS 225 
and CS 273 
n  Question: given input of size n, how long to 
generate output? 
n  Express output time in terms of input size, 
omit constants and take biggest power 
9/2/13 63 
How long will it take? 
Common big-O times: 
n  Constant time O (1)  
n   input size doesn’t matter 
n  Linear time O (n)  
n  double input ⇒ double time  
n  Quadratic time O (n2 ) 
n  double input ⇒ quadruple time 
n  Exponential time O (2n ) 
n  increment input ⇒ double time  
9/2/13 64 
Linear Time 
n  Expect most list operations to take 
linear time O (n)  
n  Each step of the recursion can be done 
in constant time 
n  Each step makes only one recursive call 
n  List example: multList, append 
n  Integer example: factorial 
9/2/13 65 
Quadratic Time 
n  Each step of the recursion takes time 
proportional to input 
n  Each step of the recursion makes only one 
recursive call. 
n  List example: 
# let rec poor_rev list = match list 
  with [] -> [] 
     | (x::xs) -> poor_rev xs @ [x];; 
val poor_rev : 'a list -> 'a list = <fun> 
9/2/13 66 
Exponential running time 
n  Hideous running times on input of any size 
n  Each step of recursion takes constant time 
n  Each recursion makes two recursive calls 
n  Easy to write naïve code that is exponential 
for functions that can be linear 
9/2/13 67 
Exponential running time 
# let rec naiveFib n = match n 
  with 0 -> 0 
  | 1 -> 1 
  | _ -> naiveFib (n-1) + naiveFib (n-2);; 
val naiveFib : int -> int = <fun> 
9/2/13 68 
Normal 
call 
h 
g 
f 
… 
An Important Optimization 
n  When a function call is made, 
the return address needs to be 
saved to the stack so we know 
to where to return when the 
call is finished 
n  What if f calls g and g calls h, 
but calling h is the last thing g 
does (a tail call)? 
9/2/13 69 
Tail      
call 
h 
f 
… 
An Important Optimization 
n  When a function call is made, 
the return address needs to be 
saved to the stack so we know 
to where to return when the 
call is finished 
n  What if f calls g and g calls h, 
but calling h is the last thing g 
does (a tail call)? 
n  Then h can return directly to f 
instead of g 
9/2/13 70 
Tail Recursion 
n  A recursive program is tail recursive if all 
recursive calls are tail calls 
n  Tail recursive programs may be optimized to 
be implemented as loops, thus removing the 
function call overhead for the recursive calls 
n  Tail recursion generally requires extra 
“accumulator” arguments to pass partial 
results 
n  May require an auxiliary function 
9/2/13 71 
Tail Recursion - Example 
# let rec rev_aux list revlist = 
  match list with [ ] -> revlist 
  | x :: xs -> rev_aux xs (x::revlist);; 
val rev_aux : 'a list -> 'a list -> 'a list = <fun> 
 
# let rev list = rev_aux list [ ];; 
val rev : 'a list -> 'a list = <fun> 
 
n  What is its running time? 
9/2/13 72 
Comparison 
n  poor_rev [1,2,3] = 
n  (poor_rev [2,3]) @ [1] = 
n  ((poor_rev [3]) @ [2]) @ [1] = 
n  (((poor_rev [ ]) @ [3]) @ [2]) @ [1] = 
n  (([ ] @ [3]) @ [2]) @ [1]) = 
n  ([3] @ [2]) @ [1] = 
n  (3:: ([ ] @ [2])) @ [1] = 
n  [3,2] @ [1] = 
n  3 :: ([2] @ [1]) = 
n  3 :: (2:: ([ ] @ [1])) = [3, 2, 1] 
9/2/13 73 
Comparison 
n  rev [1,2,3] = 
n  rev_aux [1,2,3] [ ] = 
n  rev_aux [2,3] [1] = 
n  rev_aux [3] [2,1] = 
n  rev_aux [ ] [3,2,1] = [3,2,1]  
9/2/13 74 
Folding Functions over Lists 
How are the following functions similar? 
# let rec sumlist list = match list with 
  [ ] -> 0 | x::xs -> x + sumlist xs;; 
val sumlist : int list -> int = <fun> 
# sumlist [2;3;4];; 
- : int = 9 
# let rec prodlist list = match list with 
  [ ] -> 1 | x::xs -> x * prodlist xs;; 
val prodlist : int list -> int = <fun> 
# prodlist [2;3;4];; 
- : int = 24 
9/2/13 75 
Folding 
# let rec fold_left f a list = match list 
  with [] -> a | (x :: xs) -> fold_left f (f a x) xs;; 
val fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a = 
<fun> 
fold_left f a [x1; x2;…;xn] = f(…(f (f a x1) x2)…)xn 
 
# let rec fold_right f list b = match list 
  with [ ] -> b | (x :: xs) -> f x (fold_right f xs b);; 
val fold_right : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b = 
<fun> 
fold_right f [x1; x2;…;xn] b = f x1(f x2 (…(f xn b)…)) 
9/2/13 76 
Folding - Forward Recursion 
# let sumlist list = fold_right (+) list 0;; 
val sumlist : int list -> int = <fun> 
# sumlist [2;3;4];; 
- : int = 9 
# let prodlist list = fold_right ( * ) list 1;; 
val prodlist : int list -> int = <fun> 
# prodlist [2;3;4];; 
-  : int = 24 
9/2/13 77 
Folding - Tail Recursion 
-  # let rev list = 
-          fold_left 
-            (fun l -> fun x -> x :: l)     //comb op 
            []             //accumulator cell 
            list 
9/2/13 78 
Folding 
n  Can replace recursion by fold_right in any 
forward primitive recursive definition 
n  Primitive recursive means it only recurses on 
immediate subcomponents of recursive data 
structure 
n  Can replace recursion by fold_left in any tail 
primitive recursive definition 
