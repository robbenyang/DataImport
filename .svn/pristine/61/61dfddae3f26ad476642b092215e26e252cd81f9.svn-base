Two pass algorithms
20
Duplicate elimination (R)
•Simple idea: like sorting, but include no duplicates
•Step 1: sort runs of size M, write
• Cost: 2B(R)
•Step 2: merge M‐1 runs, 
but include each tuple only once
• Cost: B(R)
•Total cost: 3B(R), Assumption: B(R) <= M2
Two‐Pass Algorithms Based on Sorting
21
•Selection?
•Projection?
•Set operations?
• Join?
•Duplicate elimination?
•Grouping?
Q: What can sorting help? And, how?
22
Grouping: city, sum(price) (R)
•Same as before: sort, then compute the sum(price) 
for each group
•As before: compute sum(price) during the merge 
phase.
•Total cost: 3B(R)
•Assumption: B(R) <= M2
Two‐Pass Algorithms Based on Sorting
23
Binary operations: R ∩ S, R U S, R – S
• Idea: sort R, sort S, then do the right thing
•A closer look:
• Step 1: split R into runs of size M, then split S into runs of 
size M.  Cost: 2B(R) + 2B(S)
• Step 2: merge all x runs from R; merge all y runs from S; 
ouput a tuple on a case by cases basis (x + y <= M)
•Total cost: 3B(R)+3B(S)
•Assumption: B(R)+B(S)<= M2
Two‐Pass Algorithms Based on Sorting
24
Join 
•Start by sorting both R and S on the join attribute:
• Cost: 4B(R)+4B(S)  (because need to write to disk)
•Read both relations in sorted order, match tuples
• Cost: B(R)+B(S)
•Difficulty: many tuples in R may match many in S
• If at least one set of tuples fits in M, we are OK
• Otherwise need nested loop, higher cost
•Total cost: 5B(R)+5B(S)
•Assumption: B(R) <= M2, B(S) <= M2
Sort‐Merge Join
25
•Pass 1?
•Pass 2?
Q: Why is sorting‐based “two” pass?
26
• Idea: partition a relation R into buckets, on disk
•Each bucket has size approx. B(R)/M
•Does each bucket fit in main memory ?
• Yes if B(R)/M <= M,   i.e. B(R) <= M2
Two Pass Algorithms Based on Hashing
27
M main memory buffers DiskDisk
Relation R
OUTPUT
2INPUT
1
hash
function
h M-1
Partitions
1
2
M-1
. . .
1
2
B(R)
•Selection?
•Projection?
•Set operations?
• Join?
•Duplicate elimination?
•Grouping?
Q: What can hashing help? And, how?
28
• Recall:  (R) duplicate elimination 
• Step 1. Partition R into buckets
• Step 2. Apply  to each bucket (may read in main memory)
• Cost: 3B(R)
• Assumption:B(R) <= M2
Hash Based Algorithms for  
29
•Recall:  (R) grouping and aggregation
•Step 1. Partition R into buckets
•Step 2. Apply  to each bucket (may read in main 
memory)
•Cost: 3B(R)
•Assumption: B(R) <= M2
Hash Based Algorithms for  
30
•Simple version: main memory hash‐based join
• Scan S, build buckets in main memory
• Then scan R and join
•Requirement: min(B(R), B(S)) <= M
Hash‐based Join
31
•Step 1:
• Hash S into M buckets
• send all buckets to disk
•Step 2
• Hash R into M buckets
• Send all buckets to disk
•Step 3
• Join every pair of buckets
Partitioned Hash Join
32
• Partition both 
relations using hash fn
h:  R tuples in partition 
i will only match S 
tuples in partition i.
• Read in a partition of 
R, hash it using h2 (<> 
h!). Scan matching 
partition of S, search 
for matches.
Partitioned Hash‐Join
Partitions
of R & S
Input buffer
for Ri
Hash table for partition
Si ( < M-1 pages)
B main memory buffersDisk
Output 
buffer
Disk
Join Result
hash
fn
h2
h2
B main memory buffers DiskDisk
Original 
Relation OUTPUT
2INPUT
1
hash
function
h M-1
Partitions
1
2
M-1
. . .
•Cost: 3B(R) + 3B(S)
•Assumption: At least one full bucket of the smaller 
rel must fit in memory: min(B(R), B(S)) <= M2
Partitioned Hash Join
34
• In a clustered index all tuples with the same value 
of the key are clustered on as few blocks as 
possible.
Indexed Based Algorithms
35
a a a a a a a a a a       
•Selection on equality: a=v(R)
•Clustered index on a:  cost B(R)/V(R,a)
•Unclustered index on a: cost T(R)/V(R,a)
Index Based Selection
36
•Example: B(R) = 2000,  T(R) = 100,000, V(R, a) = 20, 
compute the cost of a=v(R)
•Cost of table scan:
• If R is clustered: B(R) = 2000 I/Os
• If R is unclustered: T(R) = 100,000 I/Os
•Cost of index based selection:
• If index is clustered: B(R)/V(R,a) = 100
• If index is unclustered: T(R)/V(R,a) = 5000
•Notice: when V(R,a) is small, then unclustered index 
is useless
Index Based Selection
37
ܴ	 ⋈ ܵ
• Assume S has an index on the join attribute
• Iterate over R, for each tuple fetch corresponding tuple(s) 
from S
• Assume R is clustered. Cost:
• If index is clustered:  B(R) + T(R)B(S)/V(S,a)
• If index is unclustered: B(R) + T(R)T(S)/V(S,a)
Index Based Join
38
•Assume both R and S have a sorted index (B+ tree) 
on the join attribute
•Then perform a merge join (called zig‐zag join)
•Cost: B(R) + B(S)
Index Based Join
39
