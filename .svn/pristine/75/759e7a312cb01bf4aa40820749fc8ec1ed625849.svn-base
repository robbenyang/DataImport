1 Unrestricted Computation
General Computing Machines
• Machines so far: DFAs, NFAs, PDAs
– Limitations on how much memory they can use: fixed amount of memory plus (for
PDAs) a stack
– Limitations on what they can compute/decide: only regular languages or context free
languages
• The complete machine?
– No limitations on memory usage? And maybe other ways to use computational resources
that we haven’t thought of...
∗ Come up with a model that describes all “conceivable” computation
– No limitation on what they can compute?
∗ No! There are far too many languages over {0, 1} than there are “machines” or
programs (as long as machines can be represented digitally)
General Computing Machines
Alonzo Church, Emil Post, and Alan Turing (1936)
Figure 1: Alonzo Church
Figure 2: Emil Post
1
Figure 3: Alan Turing
• Church (λ-calculus), Post (Post’s machine), Turing (Turing machine) independently came up
with formal definitions of mechanical computation
• All equivalent!
• In this course: Turing Machines
2 Turing Machines
2.1 Definition
Turing Machines
X1X2 · · · Xn unionsq unionsq
finite-state
control
tape
head
• Unrestricted memory: an infinite tape
– A finite state machine that reads/writes symbols on the tape
– Can read/write anywhere on the tape
– Tape is infinite in one direction only (other variants possible)
• Initially, tape has input and the machine is reading (i.e., tape head is on) the leftmost input
symbol.
• Transition (based on current state and symbol under head):
– Change control state
– Overwrite a new symbol on the tape cell under the head
2
– Move the head left, or right.
Turing Machines
Formal Definition
A Turing machine is M = (Q,Σ,Γ, δ, q0, qacc, qrej) where
• Q is a finite set of control states
• Σ is a finite set of input symbols
• Γ ⊇ Σ is a finite set of tape symbols. Also, a blank symbol unionsq ∈ Γ \ Σ
• q0 ∈ Q is the initial state
• qacc ∈ Q is the accept state
• qrej ∈ Q is the reject state, where qrej 6= qacc
• δ : Q× Γ→ Q× Γ× {L,R} is the transition function.
Given the current state and symbol being read, the transition function describes the next
state, symbol to be written and direction (left or right) in which to move the tape head.
Transition Function
q1 q2
X → Y, L
δ(q1, X) = (q2, Y, L): Read transition as “the machine when in state q1, and reading symbol X
under the tape head, will move to state q2, overwrite X with Y , and move its tape head to the left”
• In fact δ : (Q \ {qacc, qrej})× Γ→ Q× Γ× {L,R}. No transition defined after reaching qacc or
qrej
• Transitions are deterministic
• Convention: if δ(q,X) is not explicitly specified, it is taken as leading to qrej, i.e., say δ(q,X) =
(qrej,unionsq,R)
Configurations
The configuration (or “instantaneous description”) contains all the information to exactly capture
the “current state of the computation”
X1X2 · · ·Xi−1qXi · · ·Xn
3
• Includes the current state: q
• Position of the tape head: Scanning ith symbol Xi
• Contents of all the tape cells till the rightmost nonblank symbol. This is will always be finitely
many cells. Those symbols are X1X2 · · ·Xn, where Xn 6= unionsq unless the tape head is on it.
Special Configurations
• Start configuration: q0X1 · · ·Xn, where the input is X1 · · ·Xn
• Accept and reject configurations: The state q is qacc or qrej, respectively. These configurations
are halting configurations, because there are no transitions possible from them.
Single Step
Definition 1. We say one configuration (c1) yields another (c2), denoted as c1 ` c2, if one of the
following holds.
• If δ(q,Xi) = (p, Y, L) then
X1X2 · · ·Xi−1qXiXi+1 · · ·Xn ` X1X2 · · ·Xi−2pXi−1Y Xi+1 · · ·Xn
Boundary Cases:
– If i = 1 then qX1X2 · · ·Xn ` pY X2 · · ·Xn
– If i = n and Y = unionsq then X1 · · ·Xn−1qXn ` X1 · · · pXn−1
• If δ(q,Xi) = (p, Y,R) then
X1X2 · · ·Xi−1qXiXi+1 · · ·Xn ` X1X2 · · ·Xi−1Y pXi+1 · · ·Xn
Boundary Case:
– If i = n then X1 · · ·Xn−1qXn ` X1 · · ·Xn−1Y punionsq
Computations
Definition 2. We say c1`∗c2 if the machine can move from c1 to c2 in zero or more steps, i.e.,
c1 = c2 or there exist c
′
1, . . . ,c
′
n such that c1 = c
′
1, c2 = c
′
n and c
′
i ` c′i+1
Acceptance and Recognition
4
Definition 3. A Turing machine M accepts w iff q0w`∗α1qaccα2, where α1, α2 are some strings.
In other words, the machine M when started in its intial state and with w as input, reaches the
accept state.
Note: The machine may not read all the symbols in w. It may pass back and forth over some
symbols of w several times. Finally, w may have been completely overwritten.
Definition 4. For a Turing machine M , define L(M) = {w |M accepts w}. M is said to accept
or recognize a language L if L = L(M).
2.2 Examples
Example 1: TM for {0n1n | n > 0}
Design a TM to accept the language L0n1n = {0n1n | n > 0}
High level description
On input string w
while there are unmarked 0s, do
Mark the left most 0
Scan right till the leftmost unmarked 1;
if there is no such 1 then crash
Mark the leftmost 1
done
Check to see that there are no unmarked 1s;
if there are then crash
accept
Example 1: TM for {0n1n | n > 0}
q0 q1 q2
q3 qacc
0→ A,R
0 → 0,R
B → B,R
1→ B, L
B → B, L
0→ 0, L
A→ A,R
B → B,R
B → B,R
unionsq → unionsq,R
5
• Accepts input 0011:
q00011 ` Aq1011 ` A0q111 ` Aq20B1 ` q2A0B1 ` Aq00B1 ` AAq1B1 ` AABq11 ` AAq2BB ` Aq2ABB ` AAq0BB ` AABq3B ` AABBq3unionsq ` AABBunionsqqaccunionsq
• Rejects input 00:
q000 ` Aq10 ` A0q1unionsq ` A0 unionsq qrejunionsq
Example: {0n1n | n > 0}
Formal Definition
The machine is M = (Q,Σ,Γ, δ, q0, qacc, qrej) where
• Q = {q0, q1, q2, q3, qacc, qrej}
• Σ = {0, 1}, and Γ = {0, 1, A,B,unionsq}
• δ is given as follows
δ(q0, 0) = (q1, A,R) δ(q0, B) = (q3, B,R)
δ(q1, 0) = (q1, 0, R) δ(q1, B) = (q1, B,R)
δ(q1, 1) = (q2, B, L) δ(q2, B) = (q2, B, L)
δ(q2, 0) = (q2, 0, L) δ(q2, A) = (q0, A,R)
δ(q3, B) = (q3, B,R) δ(q3,unionsq) = (qacc,unionsq, R)
In all other cases, δ(q,X) = (qrej,unionsq, R). So for example, δ(q0, 1) = (qrej,unionsq, R).
Example 2: TM for {anbncn | n > 0}
Design a TM to accept the language Lanbncn = {anbncn | n > 0}
High level description
On input string w
while there are unmarked as, do
Mark the left most a
Scan right to reach the leftmost unmarked b;
if there is no such b then crash
Mark the leftmost b
Scan right to reach the leftmost unmarked c;
if there is no such c then crash
Mark the leftmost c
done
Check to see that there are no unmarked cs or cs;
if there are then crash
accept
6
Example 2: TM for {anbncn | n > 0}
q0 q1 q2 q3
q4 qacc
a→A,R
a→a,R
B→B,R
b→B,R
b→b,R
C→C,R
c→C, L
C→C, L
b→b, L
B→B, L
a→a, L
A→A,R
B→B,R
B→B,R
C→C,R
unionsq→unionsq,R
q0aabbcc`∗AaBq3bCc`∗q3AaBbCc ` Aq0aBbCc`∗AAq0BBCC`∗AABBCCq4unionsq ` AABBCCunionsqqaccunionsq
Deciding a Language
• Only halting configurations are those with state qacc or qrej
• A Turing machine may keep running forever on some input
• Then the machine does not accept that input
• So two ways to not accept: reject or never halt
Definition 5. A Turing machine M is said to decide a language L if L = L(M) and M halts on
every input
Deciding a language is more than recognizing it. There are languages which are recognizable,
but not decidable.
7
