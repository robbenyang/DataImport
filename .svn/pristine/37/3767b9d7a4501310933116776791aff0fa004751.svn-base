1 
Pipelining	  the	  MIPS	  Datapath	  
2 
Today’s	  lecture	  
  Pipeline	  implementa:on	  	  
  Single-­‐cycle	  Datapath	  
  Pipelining	  performance	  
  Pipelined	  datapath	  
  Example	  
3 
Single-cycle implementation 
  So far we have built a single-cycle implementation of a subset 
of the MIPS-based instruction set. 
  We have assumed that instructions execute in the same 
amount of time; this determines the clock cycle time. 
  We have implemented the datapath and the control unit.  
 
4 
Full	  Machine	  Datapath	  –	  Lab	  6	  
2 (Add)
32
alu_op[2:0]
write_enable
itype
except
opcode[5:0]
funct[5:0]
MIPS decoder
A[31:0]
alu_op[2:0]
out
[31:0]
B[31:0]
ALU
rsDatarsNum
reset
rdNum
rtDatartNum
rdWriteEnable
rdData
Register File
reset
clk
wr_enable
Rdest
Rt
Rs
zero
negative
overflow
0
1
wr_enable
itype
itype
alu_op[2:0]
reset
enable
Q[31:0]
D[31:0]
PC Register
Sign 
Extender
out[31:0]
in[15:0]
data[31:0]
addr[29:0]
Instruction
Memory
4
inst[31:0]
PC[31:0]
ALU
1
nextPC[31:0]
0
1
itype
inst[25:21]
inst[20:16]
inst[15:11]
inst[20:16]
inst[5:0]
inst[15:0]
inst[31:26]
except
PC
[3
1:
2]
Rt
Rd
imm16
imm32
32
30
32
3
5
5
5
16
32
6
6
32
32
32
32
32
3
3
out[1:0]
0123
control_type
0 1 2 3
2 (Add)
ALU
3
Shift Left 2
out[31:0]
in[29:0]30 32
inst[25:0]
00 (for LSBs)
PC[31:28] (for MSBs)
branch
offset
branch
offset
32
control_type control_type
0 1
slt
01lui
16
16'b0
data_out[31:0]
addr[31:0]
Data
Memory
31'b0
zero
0
1
mem_read
da
ta
_o
ut
[3
1:
24
]
da
ta
_o
ut
[2
3:
16
]
da
ta
_o
ut
[1
5:
8]
da
ta
_o
ut
[7
:0
]
24'b00
1
byte_load
8
lui lui
slt slt
byte_load byte_load
32
26
word_we word_we
byte_we byte_we
word_we
byte_we
data_in[31:0]
word_we
byte_we
reset
32
32
mem_read mem_read
5 
Single-cycle implementation 
  For the following lectures, we will use a simpler implementation of the MIPS-
based instruction set supporting just the following operations. 
Arithmetic: add sub and or slt 
Data Transfer: lw sw 
Control: beq 
6 
Single-cycle datapath 
4 
Shift 
left 2 
PC Add 
Add 
0 
M 
u 
x 
1 
PCSrc 
Read 
address 
Write 
address 
Write 
data 
Data 
memory 
Read 
data 
MemWrite 
MemRead 
1 
M 
u 
x 
0 
MemToReg Read 
address 
Instruction 
memory 
Instruction 
[31-0] 
I [15 - 0] 
I [25 - 21] 
I [20 - 16] 
I [15 - 11] 
0 
M 
u 
x 
1 
RegDst 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
RegWrite 
Sign 
extend 
0 
M 
u 
x 
1 
ALUSrc 
Result 
Zero 
ALU 
ALUOp 
Rs 
Rt 
Rd 
lw $t0, –4($sp) 
7 
Single-cycle datapath 
4 
Shift 
left 2 
PC Add 
Add 
0 
M 
u 
x 
1 
PCSrc 
Read 
address 
Write 
address 
Write 
data 
Data 
memory 
Read 
data 
MemWrite 
MemRead 
1 
M 
u 
x 
0 
MemToReg Read 
address 
Instruction 
memory 
Instruction 
[31-0] 
I [15 - 0] 
I [25 - 21] 
I [20 - 16] 
I [15 - 11] 
0 
M 
u 
x 
1 
RegDst 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
RegWrite 
Sign 
extend 
0 
M 
u 
x 
1 
ALUSrc 
Result 
Zero 
ALU 
ALUOp 
Rs 
Rt 
Rd 
beq $at, $0, offset 
A)	  ALUSrc=0	  	   B)	  ALUSrc=1	  	  
8 
Single-cycle datapath 
4 
Shift 
left 2 
PC Add 
Add 
0 
M 
u 
x 
1 
PCSrc 
Read 
address 
Write 
address 
Write 
data 
Data 
memory 
Read 
data 
MemWrite 
MemRead 
1 
M 
u 
x 
0 
MemToReg Read 
address 
Instruction 
memory 
Instruction 
[31-0] 
I [15 - 0] 
I [25 - 21] 
I [20 - 16] 
I [15 - 11] 
0 
M 
u 
x 
1 
RegDst 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
RegWrite 
Sign 
extend 
0 
M 
u 
x 
1 
ALUSrc 
Result 
Zero 
ALU 
ALUOp 
Rs 
Rt 
Rd 
add $1, $2, $3 
A)  ALUSrc=0	  
	  	  	  	  	  	  RegDst=0	  	  	  
B)	  ALUSrc=0	  
	  	  	  	  	  RegDst=1	  
C)	  ALUSrc=1	  
	  	  	  	  	  RegDst=0	  	  
D)	  ALUSrc=1	  
	  	  	  	  	  RegDst=1	  	  
9 
Pipeline Motivation: Single-cycle datapath 
4 
Shift 
left 2 
PC Add 
Add 
0 
M 
u 
x 
1 
PCSrc 
Read 
address 
Write 
address 
Write 
data 
Data 
memory 
Read 
data 
MemWrite 
MemRead 
1 
M 
u 
x 
0 
MemToReg Read 
address 
Instruction 
memory 
Instruction 
[31-0] 
I [15 - 0] 
I [25 - 21] 
I [20 - 16] 
I [15 - 11] 
0 
M 
u 
x 
1 
RegDst 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
RegWrite 
Sign 
extend 
0 
M 
u 
x 
1 
ALUSrc 
Result 
Zero 
ALU 
ALUOp 2ns 
2ns 
2ns 
1ns 
  How long does it take to execute each instruction? 
2ns 
2ns 
10 
How fast can we clock a pipelined datapath? 
Read 
address 
Instruction 
memory 
Instruction 
[31-0] 
Read 
address 
Write 
address 
Write 
data 
Data 
memory 
Read 
data 
MemWrite 
MemRead 
1 
M 
u 
x 
0 
MemToReg 
Sign 
extend 
0 
M 
u 
x 
1 
ALUSrc 
Result 
Zero 
ALU 
ALUOp 
I [15 - 0] 
I [25 - 21] 
I [20 - 16] 
I [15 - 11] 
0 
M 
u 
x 
1 
RegDst 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
RegWrite 
ID IF EXE MEM WB 
2ns 2ns 2ns 1ns 
11 
Break datapath into 5 stages 
Read 
address 
Instruction 
memory 
Instruction 
[31-0] 
Read 
address 
Write 
address 
Write 
data 
Data 
memory 
Read 
data 
MemWrite 
MemRead 
1 
M 
u 
x 
0 
MemToReg 
Sign 
extend 
0 
M 
u 
x 
1 
ALUSrc 
Result 
Zero 
ALU 
ALUOp 
I [15 - 0] 
I [25 - 21] 
I [20 - 16] 
I [15 - 11] 
0 
M 
u 
x 
1 
RegDst 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
RegWrite 
ID IF EXE MEM WB 
Clock cycle 
1 2 3 4 5 6 7 8 9 
lw  $t0, 4($sp) IF ID EX MEM WB 
lw  $t1, 8($sp) IF ID EX MEM WB 
lw  $t2, 12($sp) IF ID EX MEM WB 
lw  $t3, 16($sp) IF ID EX MEM WB 
lw  $t4, 20($sp) IF ID EX MEM WB 
12 
  Execution time on ideal pipeline: 
  time to fill the pipeline + one cycle per instruction 
  How long for N instructions?  
  Compare with other implementations: 
  Single Cycle: (8ns clock period) 
 
  How much faster is pipelining for N=1000 ? 
Pipelining Performance 
Clock cycle 
1 2 3 4 5 6 7 8 9 
lw  $t0, 4($sp) IF ID EX MEM WB 
lw  $t1, 8($sp) IF ID EX MEM WB 
lw  $t2, 12($sp) IF ID EX MEM WB 
lw  $t3, 16($sp) IF ID EX MEM WB 
lw  $t4, 20($sp) IF ID EX MEM WB 
filling 
13 
Pipeline	  versus	  Single	  Cycle	  implementa:on	  
Latency	  versus	  Throughput	  
Single	  	  
Cycle	  
Mul:ple	  	  
Cycle	  
14 
October 25, 2013 Pipelining 14 
Pipelining other instruction types 
  R-type instructions only require 4 stages: IF, ID, EX, and WB 
  We don’t need the MEM stage 
  What happens if we try to pipeline loads with R-type 
instructions? 
Clock cycle 
1 2 3 4 5 6 7 8 9 
add  $sp, $sp, -4 IF ID EX WB 
sub  $v0, $a0, $a1 IF ID EX WB 
lw  $t0, 4($sp) IF ID EX MEM WB 
or  $s0, $s1, $s2 IF ID EX WB 
lw  $t1, 8($sp) IF ID EX MEM WB 
15 
October 25, 2013 Pipelining 15 
Important Observation 
  Each functional unit can only be used once per instruction 
  Each functional unit must be used at the same stage for all 
instructions: 
  Load uses Register File’s Write Port during  its 5th stage 
  R-type uses Register File’s Write Port during its 4th stage 
Clock cycle 
1 2 3 4 5 6 7 8 9 
add  $sp, $sp, -4 IF ID EX WB 
sub  $v0, $a0, $a1 IF ID EX WB 
lw  $t0, 4($sp) IF ID EX MEM WB 
or  $s0, $s1, $s2 IF ID EX WB 
lw  $t1, 8($sp) IF ID EX MEM WB 
16 
October 25, 2013 Pipelining 16 
A solution: Insert NOP stages 
  Enforce uniformity  
  Make all instructions take 5 cycles. 
  Make them have the same stages, in the same order 
  Some stages will do nothing for some instructions 
  Stores and Branches have NOP stages, too… 
Clock cycle 
1 2 3 4 5 6 7 8 9 
add  $sp, $sp, -4 IF ID EX NOP WB 
sub  $v0, $a0, $a1 IF ID EX NOP WB 
lw  $t0, 4($sp) IF ID EX MEM WB 
or  $s0, $s1, $s2 IF ID EX NOP WB 
lw  $t1, 8($sp) IF ID EX MEM WB 
R-type IF ID EX NOP WB 
store IF ID EX MEM NOP 
branch IF ID EX NOP NOP 
17 
October 25, 2013 Pipelined datapath and control 17 
Single-cycle datapath, slightly rearranged 
 MemToReg 
Read 
address 
Instruction 
memory 
Instruction 
[31-0] Address 
Write 
data 
   Data 
   memory 
Read 
data 
MemWrite 
MemRead 
1 
 
 
0 
4 
Shift 
left 2 
P 
C 
 Add 
1 
0 
PCSrc 
Sign 
extend 
ALUSrc 
Result 
Zero ALU 
ALUOp 
Instr [15 - 0] RegDst 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
RegWrite 
 Add 
Instr [15 - 11] 
Instr [20 - 16] 0 
1 
  0 
  1 
18 
Pipeline registers 
  We’ll add intermediate registers to our pipelined datapath. 
  There’s a lot of information to save, however. We’ll simplify our 
diagrams by drawing just one big pipeline register between each 
stage. 
  The registers are named for the stages they connect. 
  IF/ID  ID/EX  EX/MEM  MEM/WB  
  No register is needed after the WB stage, because after WB the 
instruction is done. 
19 
October 25, 2013 Pipelined datapath and control 19 
Pipelined datapath 
Read 
address 
Instruction 
memory 
Instruction 
[31-0] Address 
Write 
data 
   Data 
   memory 
Read 
data 
MemWrite 
MemRead 
1 
 
 
0 
 MemToReg 
 
 4 
Shift 
left 2 
 Add 
Sign 
extend 
ALUSrc 
Result 
Zero ALU 
ALUOp 
Instr [15 - 0] RegDst 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
RegWrite 
 Add 
Instr [15 - 11] 
Instr [20 - 16] 
0 
1 
  0 
  1 
IF/ID ID/EX EX/MEM MEM/WB 
1 
0 
PCSrc 
P 
C 
20 
October 25, 2013 Pipelined datapath and control 20 
Propagating values forward 
  Any data values required in later stages must be propagated 
through the pipeline registers. 
  The most extreme example is the destination register. 
  The rd field of the instruction word, retrieved in the first 
stage (IF), determines the destination register. But that 
register isn’t updated until the fifth stage (WB). 
  Thus, the rd field must be passed through all of the pipeline 
stages, as shown in red on the next slide. 
  Notice that we can’t keep a single “instruction register,” 
because the pipelined machine needs to fetch a new 
instruction every clock cycle. 
21 
October 25, 2013 Pipelined datapath and control 21 
The destination register 
Read 
address 
Instruction 
memory 
Instruction 
[31-0] Address 
Write 
data 
   Data 
   memory 
Read 
data 
MemWrite 
MemRead 
1 
 
 
0 
 MemToReg 
 
 4 
Shift 
left 2 
 Add 
ALUSrc 
Result 
Zero ALU 
ALUOp 
Instr [15 - 0] RegDst 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
RegWrite 
 Add 
Instr [15 - 11] 
Instr [20 - 16] 0 
1 
  0 
  1 
IF/ID ID/EX EX/MEM MEM/WB 
1 
0 
PCSrc 
P 
C 
Sign 
extend 
Rd	  
Rt	  
22 
October 25, 2013 Pipelined datapath and control 22 
What about control signals? 
  The control signals are generated in the same way as in the 
single-cycle processor—after an instruction is fetched, the 
processor decodes it and produces the appropriate control 
values. 
  But just like before, some of the control signals will not be 
needed until some later stage and clock cycle. 
  These signals must be propagated through the pipeline until 
they reach the appropriate stage. We can just pass them in 
the pipeline registers, along with the other data. 
  Control signals can be categorized by the pipeline stage that 
uses them. 
23 
October 25, 2013 Pipelined datapath and control 23 
Pipelined datapath and control 
Read 
address 
Instruction 
memory 
Instruction 
[31-0] Address 
Write 
data 
   Data 
   memory 
Read 
data 
MemWrite 
MemRead 
1 
 
 
0 
 MemToReg 
 
 4 
Shift 
left 2 
 Add 
ALUSrc 
Result 
Zero ALU 
ALUOp 
Instr [15 - 0] RegDst 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
RegWrite 
 Add 
Instr [15 - 11] 
Instr [20 - 16] 
0 
1 
  0 
  1 
IF/ID 
ID/EX 
EX/MEM 
MEM/WB  Control 
M 
WB 
WB 
P 
C 
1 
0 
PCSrc 
Sign 
extend 
EX 
M 
WB 
24 
What about control signals? 
  The control signals are generated in the same way as in the single-
cycle processor—after an instruction is fetched, the processor 
decodes it and produces the appropriate control values. 
  But, some of the control signals will not be needed until some later 
stage and clock cycle. 
  These signals must be propagated through the pipeline until they 
reach the appropriate stage. We can just pass them in the pipeline 
registers, along with the other data. 
  Control signals can be categorized by the pipeline stage that uses 
them. 
Stage Control signals needed 
EX ALUSrc ALUOp RegDst 
MEM MemRead MemWrite PCSrc 
WB RegWrite MemToReg 
25 
Pipelined datapath and control 
Read 
address 
Instruction 
memory 
Instruction 
[31-0] Address 
Write 
data 
   Data 
   memory 
Read 
data 
MemWrite 
MemRead 
1 
 
 
0 
 MemToReg 
 
 
4 
Shift 
left 2 
 Add 
ALUSrc 
Result 
Zero ALU 
ALUOp 
Instr [15 - 0] RegDst 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
RegWrite 
 Add 
Instr [15 - 11] 
Instr [20 - 16] 0 
1 
  0 
  1 
IF/ID 
ID/EX 
EX/MEM 
MEM/WB  Control 
M 
WB 
WB 
P 
C 
1 
0 
PCSrc 
Sign 
extend 
EX 
M 
WB 
26 
26 
Notes about the diagram 
  The control signals are grouped together in the pipeline 
registers, just to make the diagram a little clearer. 
  Not all of the registers have a write enable signal. 
  Because the datapath fetches one instruction per cycle, the 
PC must also be updated on each clock cycle. Including a 
write enable for the PC would be redundant. 
  Similarly, the pipeline registers are also written on every 
cycle, so no explicit write signals are needed. 
27 
  Here’s a sample sequence of instructions to execute. 
  1000: lw  $8, 4($29) 
  1004: sub $2, $4, $5 
  1008: and $9, $10, $11 
  1012: or  $16, $17, $18 
  1016: add $13, $14, $0 
  We’ll make some assumptions, just so we can show actual data values. 
  Each register contains its number plus 100. For instance, register $8 
contains 108, register $29 contains 129, and so forth. 
  Every data memory location contains 99. 
  Our pipeline diagrams will follow some conventions. 
  An X indicates values that aren’t important, like the constant field of 
an R-type instruction. 
  Question marks ??? indicate values we don’t know, usually resulting 
from instructions coming before and after the ones in our example. 
An example execution sequence 
addresses in 
decimal 
28 
28 
Cycle 1 (filling) 
IF: lw $8, 4($29) MEM: ??? WB: ??? EX: ??? ID: ??? 
Read 
address 
Instruction 
memory 
Instruction 
[31-0] Address 
Write 
data 
   Data 
   memory 
Read 
data 
MemWrite (?) 
MemRead (?) 
1 
 
 
0 
 MemToReg 
(?) 
Shift 
left 2 
 Add 
1 
0 
PCSrc 
ALUSrc (?) 
Result 
Zero ALU 
ALUOp (???) 
RegDst (?) 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
RegWrite (?) 
 Add 
0 
1 
  0 
  1 
IF/ID 
ID/EX 
EX/MEM 
MEM/WB  Control 
M 
WB 
WB 
1000 
_____ 
??? 
??? 
??? 
??? 
??? 
??? 
??? 
??? 
??? 
  ??? 
  ??? 
??? 
??? 
??? 
  ??? 
??? 
??? 
??? 
??? 
??? 
??? 
??? 
??? 
 
 
4 
P 
C 
Sign 
extend 
EX 
M 
WB 
29 
Cycle 2 
ID: lw $8, 4($29) IF: sub $2, $4, $5 MEM: ??? WB: ??? EX: ??? 
Read 
address 
Instruction 
memory 
Instruction 
[31-0] Address 
Write 
data 
   Data 
   memory 
Read 
data 1 
 
 
0 
 
 
4 
Shift 
left 2 
 Add 
PCSrc 
Result 
Zero ALU 
Imm____ 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
 Add 
rd____ 
rt____ 0 
1 
  0 
  1 
IF/ID 
ID/EX 
EX/MEM 
MEM/WB  Control 
M 
WB 
WB 
1004 
rs___ 
rt___ 
1008 
    ___ 
  ___ 
 MemToReg 
(?) 
  ??? 
  ??? 
??? 
??? 
rd__ 
___ 
RegWrite (?) 
MemWrite (?) 
MemRead (?) 
??? 
  ??? 
??? 
ALUSrc (?) 
ALUOp (???) 
RegDst (?) 
??? 
??? 
??? 
??? 
??? 
??? 
??? 
P 
C 
Sign 
extend 
EX 
M 
WB 
1 
0 
30 
Cycle 3 
ID: sub $2, $4, $5 IF: and $9, $10, $11 EX: lw $8, 4($29) MEM: ??? WB: ??? 
 MemToReg 
(?) 
Read 
address 
Instruction 
memory 
Instruction 
[31-0] Address 
Write 
data 
   Data 
   memory 
Read 
data 
MemWrite (?) 
MemRead (?) 
1 
 
 
0 
 
 
4 
Shift 
left 2 
 Add 
PCSrc 
ALUSrc (___) 
Result 
Zero ALU 
ALUOp (___) 
X RegDst (___) 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
 Add 
2 
X 0 
1 
  0 
  1 
IF/ID 
ID/EX 
EX/MEM 
MEM/WB  Control 
M 
WB 
WB 
1008 
4 
5 
1012 
    104 
  105 
___ 
__ 
__ 
__ 
__ 
___ 
 ___ 
 __ 
  ??? 
  ??? 
??? 
??? 
??? 
??? 
RegWrite (?) 
??? 
  ??? 
??? 
P 
C 
Sign 
extend 
1 
0 
EX 
M 
WB 
31 
31 
Cycle 4 
ID: and $9, $10, $11 IF: or $16, $17, $18 EX: sub $2, $4, $5 MEM: lw $8, 4($29) WB: ??? 
Read 
address 
Instruction 
memory 
Instruction 
[31-0] Address 
Write 
data 
   Data 
   memory 
Read 
data 
MemWrite (___) 
MemRead (___) 
1 
 
 
0 
 MemToReg 
(?) 
 
 
4 
Shift 
left 2 
 Add 
PCSrc 
ALUSrc (0) 
Result 
Zero ALU 
ALUOp (sub) 
X RegDst (1) 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
RegWrite (?) 
 Add 
9 
X 0 
1 
  0 
  1 
IF/ID 
ID/EX 
EX/MEM 
MEM/WB  Control 
M 
WB 
WB 
1012 
10 
11 
1016 
    110 
  111 
104 
X 
 105 
X 
2 
2 
 –1 
 ___ 
 __  ___ 
___ 
  ??? 
  ??? 
??? 
??? 
??? 
??? 
P 
C 
Sign 
extend 
EX 
M 
WB 
1 
0 
32 
32 
Cycle 5 (full) 
ID: or $16, $17, $18 IF: add $13, $14, $0 EX: and $9, $10, $11 MEM: sub $2, $4, $5 WB: 
lw $8, 4($29) 
Read 
address 
Instruction 
memory 
Instruction 
[31-0] Address 
Write 
data 
   Data 
   memory 
Read 
data 
MemWrite (0) 
MemRead (0) 
1 
 
 
0 
 MemToReg 
(___) 
 
 
4 
Shift 
left 2 
 Add 
PCSrc 
ALUSrc (0) 
Result 
Zero ALU 
ALUOp (and) 
X RegDst (1) 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
RegWrite (___) 
 Add 
16 
X 0 
1 
  0 
  1 
IF/ID 
ID/EX 
EX/MEM 
MEM/WB  Control 
M 
WB 
WB 
1016 
17 
18 
1020 
    117 
  118 
110 
X 
 111 
X 
9 
9 
 110 
-1 
  105  X 
2 
 ___ 
____ 
 ___ 
___ 
 __ 
__ 
P 
C 
Sign 
extend 
EX 
M 
WB 
1 
0 
33 
33 
Cycle 6 (emptying) 
ID: add $13, $14, $0 IF: ??? EX: or $16, $17, $18 MEM: and $9, $10, $11 WB: sub 
$2, $4, $5 
Read 
address 
Instruction 
memory 
Instruction 
[31-0] Address 
Write 
data 
   Data 
   memory 
Read 
data 
MemWrite (0) 
MemRead (0) 
1 
 
 
0 
 MemToReg 
(0) 
 
 
4 
Shift 
left 2 
 Add 
PCSrc 
ALUSrc (0) 
Result 
Zero ALU 
ALUOp (or) 
X RegDst (1) 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
RegWrite (1) 
 Add 
13 
X 0 
1 
  0 
  1 
IF/ID 
ID/EX 
EX/MEM 
MEM/WB  Control 
M 
WB 
WB 
1020 
14 
0 
   ??? 
    114 
0 
117 
X 
 118 
X 
16 
16 
 119 
110 
  111  X 
9 
  
  
  
 -1 
2 
P 
C 
Sign 
extend 
1 
0 
EX 
M 
WB 
34 
Cycle 7 
ID: ??? IF: ??? EX: add $13, $14, $0 MEM: or $16, $17, $18 WB: and 
$9, $10, $11 
Read 
address 
Instruction 
memory 
Instruction 
[31-0] Address 
Write 
data 
   Data 
   memory 
Read 
data 
MemWrite (0) 
MemRead (0) 
1 
 
 
0 
 MemToReg 
(0) 
 
 
4 
Shift 
left 2 
 Add 
PCSrc 
ALUSrc (0) 
Result 
Zero ALU 
ALUOp (add) 
??? RegDst (1) 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
RegWrite (1) 
 Add 
??? 
??? 0 
1 
  0 
  1 
IF/ID 
ID/EX 
EX/MEM 
MEM/WB  Control 
M 
WB 
WB 
??? 
   ??? 
    ??? 
??? 
114 
X 
 0 
X 
13 
13 
 114 
119 
  118  X 
16 
 X 
110 
110 
9 
110 
9 
P 
C 
Sign 
extend 
??? 
??? 
EX 
M 
WB 
1 
0 
35 
October 25, 2013 Pipelined datapath and control 35 
Cycle 8 
ID: ??? IF: ??? EX: ??? MEM: add $13, $14, $0 WB: or $16, 
$17, $18 
Read 
address 
Instruction 
memory 
Instruction 
[31-0] Address 
Write 
data 
   Data 
   memory 
Read 
data 
MemWrite (0) 
MemRead (0) 
1 
 
 
0 
 MemToReg 
(0) 
 
 
4 
Shift 
left 2 
 Add 
PCSrc 
ALUSrc (?) 
Result 
Zero ALU 
ALUOp (???) 
??? RegDst (?) 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
RegWrite (1) 
 Add 
??? 
??? 0 
1 
  0 
  1 
IF/ID 
ID/EX 
EX/MEM 
MEM/WB  Control 
M 
WB 
WB 
??? 
 ??? 
??? 
??? 
??? 
 ??? 
114 
   0  X 
13 
 X 
119 
119 
16 
119 
16 
P 
C 
Sign 
extend 
    ??? 
???  ??? 
??? 
   ??? 
??? 
??? 
1 
0 
EX 
M 
WB 
36 
36 
Cycle 9 
ID: ??? IF: ??? EX: ??? MEM: ??? WB: add 
$13, $14, $0 
Read 
address 
Instruction 
memory 
Instruction 
[31-0] Address 
Write 
data 
   Data 
   memory 
Read 
data 
MemWrite (?) 
MemRead (?) 
1 
 
 
0 
 MemToReg 
(0) 
 
 
4 
Shift 
left 2 
 Add 
PCSrc 
ALUSrc (?) 
Result 
Zero ALU 
ALUOp (???) 
??? RegDst (?) 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
RegWrite (1) 
 Add 
??? 
??? 0 
1 
  0 
  1 
IF/ID 
ID/EX 
EX/MEM 
MEM/WB  Control 
M 
WB 
WB 
??? 
 ??? 
 ??? 
??? 
??? 
??? 
 ??? 
??? 
   ?  X 
??? 
 X 
114 
114 
13 
114 
13 
P 
C 
Sign 
extend 
    ??? 
??? 
??? 
   ??? 
??? 
??? 
1 
0 
EX 
M 
WB 
37 
37 
That’s a lot of diagrams there 
 
  Compare the last nine slides with the pipeline diagram above. 
  You can see how instruction executions are overlapped. 
  Each functional unit is used by a different instruction in each 
cycle. 
  The pipeline registers save control and data values generated in 
previous clock cycles for later use. 
  When the pipeline is full in clock cycle 5, all of the hardware units 
are utilized. This is the ideal situation, and what makes pipelined 
processors so fast. 
  Try to understand this example or the similar one in the book at the 
end of Section 6.3. 
Clock cycle 
1 2 3 4 5 6 7 8 9 
lw  $t0, 4($sp) IF ID EX MEM WB 
sub  $v0, $a0, $a1 IF ID EX MEM WB 
and  $t1, $t2, $t3 IF ID EX MEM WB 
or  $s0, $s1, $s2 IF ID EX MEM WB 
add  $t5, $t6, $0 IF ID EX MEM WB 
38 
October 25, 2013 Pipelined datapath and control 38 
Summary 
  The pipelined datapath extends the single-cycle processor 
that we saw earlier to improve instruction throughput. 
  Instruction execution is split into several stages. 
  Multiple instructions flow through the pipeline 
simultaneously. 
  Pipeline registers propagate data and control values to later 
stages. 
  The MIPS instruction set architecture supports pipelining with 
uniform instruction formats and simple addressing modes. 
  Next lecture, we’ll start talking about Hazards. 
39 
October 25, 2013 Pipelined datapath and control 39 
Note how everything goes left to right, except … 
Read 
address 
Instruction 
memory 
Instruction 
[31-0] Address 
Write 
data 
   Data 
   memory 
Read 
data 
MemWrite 
MemRead 
1 
 
 
0 
 MemToReg 
 
 4 
Shift 
left 2 
 Add 
Sign 
extend 
ALUSrc 
Result 
Zero ALU 
ALUOp 
Instr [15 - 0] RegDst 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
RegWrite 
 Add 
Instr [15 - 11] 
Instr [20 - 16] 
0 
1 
  0 
  1 
IF/ID ID/EX EX/MEM MEM/WB 
1 
0 
PCSrc 
P 
C 
40 
October 25, 2013 Pipelined datapath and control 40 
Cycle 6 (emptying) 
ID: add $13, $14, $0 IF: ??? EX: or $16, $17, $18 MEM: and $9, $10, $11 WB: sub 
$2, $4, $5 
Read 
address 
Instruction 
memory 
Instruction 
[31-0] Address 
Write 
data 
   Data 
   memory 
Read 
data 
MemWrite (0) 
MemRead (0) 
1 
 
 
0 
 MemToReg 
(0) 
 
 
4 
Shift 
left 2 
 Add 
PCSrc 
ALUSrc (0) 
Result 
Zero ALU 
ALUOp (or) 
X RegDst (1) 
Read 
register 1 
Read 
register 2 
Write 
register 
Write 
data 
Read 
data 2 
Read 
data 1 
Registers 
RegWrite (1) 
 Add 
13 
X 0 
1 
  0 
  1 
IF/ID 
ID/EX 
EX/MEM 
MEM/WB  Control 
M 
WB 
WB 
1020 
14 
0 
   ??? 
    114 
0 
117 
X 
 118 
X 
16 
16 
 119 
110 
  111  X 
9 
 X 
 -1 
 -1 
2 
 -1 
2 
P 
C 
Sign 
extend 
1 
0 
EX 
M 
WB 
