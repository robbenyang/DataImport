Announcements
MP2 available, due 9/20, 11:59p.
MP3 available, due 10/8, 11:59p, EC due 10/1, 11:59p.
Exam 1: 10/1, 7p, rooms TBA
Template compilation:
Old:                       New:
Toward a new memory model:
struct listNode {
   LIT data;
   listNode * next;
   listNode(LIT newData):data(newData),next(NULL){}
};
listNode<int> nln(5);
What is the result of this declaration?
Write code that would result in each of these memory configurations?
8 6 8
Example 1:     insertAtFront<farmAnimal>(head,cow);
struct listNode {
   LIT data;
   listNode * next;
   listNode(LIT newData):data(newData),next(NULL){}
}
void insertAtFront(listNode *   curr, LIT e) {
}
dog
Running time?
cat pig
Example 2:
struct listNode {
   LIT data;
   listNode * next;
   listNode(LIT newData):data(newData),next(NULL){}
}
void printReverse(listNode *   curr) {
}
8  4  2  6  3  0  1  2 
Running time?
Example 3:  Find kth position (we’ll need this later)
Analysis:    Find kth in array:
3 7 4 2 8
//returns pointer to node k steps forward from *curr
listNode * findKth(listNode *   curr, int k) {
}
Abstract Data Types (an example):
ToDo List
Groc List
top 20 
movie 
List
Class List
List
template<class LIT>
class List {
public:
List();
//~List();
int getSize() const;
void insert(int loc, LIT e);
void remove(int loc);
LIT const & getItem(int loc) const;
private:
//my little secret
};
int main() {
List<int> myList;
myList.insert(1,4);
myList.insert(1,6);
myList.insert(1,8);
myList.insert(3,0);
myList.insert(4,myList.getItem(2));
cout << myList.getSize() << endl;
myList.remove(2);
cout << myList.getItem(3) << endl;
return 0;
}
ADT List, implementation 1:
ToDo List
Groc List
top 20 
movie 
List Class List
List
template<class LIT>
class List {
public:
List():size(0){}
//~List();
int getSize() const;
void insert(int loc, LIT e);
void remove(int loc);
LIT const & getItem(int loc) const;
private:
LIT items[8];
int size;
};
template<class LIT>
int List<LIT>::getSize() const {
   return size;
}
template<class LIT>
void List<LIT>::insert(int loc, LIT e){
if ((size + 1) < 8) {
   LIT go = e;
   int it = loc-1;
   while (it < size+1){
     LIT temp = items[it];
     items[it] = go;
     go = temp;
     it ++;
   }
   size ++;
}}
template<class LIT>
void List<LIT>::remove(int loc) {
if (size > 0) {
   int it = loc-1;
   while (it < size){
     items[it] = items[it+1];
     it ++;
   }
   size --;
}}
template<class LIT>
LIT const & List<LIT>::getItem(int loc) 
const {return items[loc -1];}
0 1 2 3 4 5 6 7
Don
’t loo
k at 
this 
code
!
Don
’t loo
k at 
this 
code
!
Implementing a list using an array:
0 1 2 3 4 5 6 7
0 1 2 3 4 5 6 7
