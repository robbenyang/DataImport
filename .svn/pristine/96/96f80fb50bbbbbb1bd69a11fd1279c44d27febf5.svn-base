1 Closure Properties
1.1 Regular Operations
Union of CFLs
Proposition 1. If L1 and L2 are context-free languages then L1 âˆª L2 is also context-free.
Proof. Let L1 be language recognized by G1 = (V1,Î£, R1, S1) and L2 the language recognized by
G2 = (V2,Î£, R2, S2). Assume that V1 âˆ© V2 = âˆ…; if this assumption is not true, rename the variables
of one of the grammars to make this condition true.
We will construct a grammar G = (V,Î£, R, S) such that L(G) = L(G1) âˆª L(G2) as follows.
â€¢ V = V1 âˆª V2 âˆª {S}, where S 6âˆˆ V1 âˆª V2 (and V1 âˆ© V2 = âˆ…)
â€¢ R = R1 âˆªR2 âˆª {S â†’ S1|S2}
We need to show that L(G) = L(G1) âˆª L(G2). Consider w âˆˆ L(G). That means there is a
derivation S
âˆ—â‡’G w. Since the only rules involving S are S â†’ S1 and S â†’ S2, this derivation
is either of the form S â‡’G S1 âˆ—â‡’G w or S â‡’G S2 âˆ—â‡’G w. Consider the first case. Since the
only rules for variables in V1 are those belonging to R1 and since S1
âˆ—â‡’G w, we have S1 âˆ—â‡’G1 w,
and so w âˆˆ L1 = L(G1). If the derivation S âˆ—â‡’G w is of the form S â‡’G S2 âˆ—â‡’G w, then by a
similar reasoning we can conclude that w âˆˆ L(G2). Hence if w âˆˆ L(G) then w âˆˆ L(G1) âˆª L(G2).
Conversely, consider w âˆˆ L(G1) âˆª L(G2). Suppose w âˆˆ L(G1); the case that w âˆˆ L(G2) is similar
and skipped. That means that S1
âˆ—â‡’G1 w. Since R1 âŠ† R, we have S1 âˆ—â‡’G w. Thus, we have
S â‡’G S1 âˆ—â‡’G w which means that w âˆˆ L(G). This completes the proof.
Concatenation, Kleene Closure
Proposition 2. CFLs are closed under concatenation and Kleene closure
Proof. Let L1 be language generated by G1 = (V1,Î£, R1, S1) and L2 the language generated by
G2 = (V2,Î£, R2, S2). As before we will assume that V1 âˆ© V2 = âˆ….
Concatenation Let G = (V,Î£, R, S) be such that V = V1 âˆª V2 âˆª {S} (with S 6âˆˆ V1 âˆª V2), and
R = R1 âˆª R2 âˆª {S â†’ S1S2}. We will show that L(G) = L(G1)L(G2). Suppose w âˆˆ L(G).
Then there is a leftmost derivation S
âˆ—â‡’Glm w. The form such a derivation is S â‡’G S1S2 âˆ—â‡’
G
lm
w1S2
âˆ—â‡’Glm w1w2 = w. Thus, S1 âˆ—â‡’
G
lm w1 and S2
âˆ—â‡’Glm w2. Since the rules in R restricted to
V1 are R1 and restricted to V2 are R2, we can conclude that S1
âˆ—â‡’G1lm w1 and S2 âˆ—â‡’
G2
lm w2.
Thus, w1 âˆˆ L(G1) and w2 âˆˆ L(G2) and therefore, w = w1w2 âˆˆ L(G1)L(G2). On the other
hand, if w1 âˆˆ L(G1) and w2 âˆˆ L(G2) then we have S1 âˆ—â‡’G1 w1 and S2 âˆ—â‡’G2 w2. Take
w = w1w2 âˆˆ L(G1)L(G2). Now since R1 âˆª R2 âŠ† R, we have S1 âˆ—â‡’G w1 and S2 âˆ—â‡’G w2.
Therefore, we have, S â‡’G S1S2 âˆ—â‡’G w1S2 âˆ—â‡’G w1w2 = w, and so w âˆˆ L(G).
1
Kleene Closure Let G = (V = V1 âˆª {S},Î£, R = R1 âˆª {S â†’ SS1 | }, S), where S 6âˆˆ V1. We will
show that L(G) = (L(G1))
âˆ—. We will show if w âˆˆ L(G) then w âˆˆ (L(G1))âˆ— by induction
on the length of the leftmost derivation of w. For the base case, consider w such that
S â‡’G w. Since S â†’  is the only rule for S whose right-hand side has terminals, this
means that w = . Further,  âˆˆ (L(G1))âˆ— which establishes the base case. The induction
hypothesis assumes that for all strings w, if S
âˆ—â‡’Glm w in < n steps then w âˆˆ (L(G1))âˆ—.
Consider w such that S
âˆ—â‡’Glm w in n steps. Any leftmost derivation has the following form:
S â‡’G SS1 âˆ—â‡’
G
lm w1S1
âˆ—â‡’Glm w1w2 = w. Now we have S âˆ—â‡’
G
lm w1 is < n steps (because
S1
âˆ—â‡’Glm w2 takes at least one step), and S1 âˆ—â‡’
G
lm w2. This means that w1 âˆˆ (L(G1))âˆ— (by
induction hypothesis) and w2 âˆˆ L(G1) (since the only rules in R for variables in V1 are those
belonging to R1). Thus, w = w1w2 âˆˆ (L(G1))âˆ—. For the converse, suppose w âˆˆ (L(G1))âˆ—. By
definition, this means that there are w1, w2, . . . wn (for n â‰¥ 0) such that wi âˆˆ L(G1) for all
i. Now if n = 0 (i.e., w = ) then we have S â‡’G w because S â†’  is a rule. Otherise, since
wi âˆˆ L(G1), we have S1 âˆ—â‡’G1 wi, for each i. Since R1 âŠ† R, S1 âˆ—â‡’G wi. Hence we have the
following derivation
S â‡’G SS1 â‡’G SSS1 â‡’G Â· Â· Â· â‡’G S(S1)n â‡’G (S1)n âˆ—â‡’G w1(S1)nâˆ’1 âˆ—â‡’G Â· Â· Â· âˆ—â‡’G w1w2 Â· Â· Â·wn = w
1.2 Intersection and Complementation
Intersection
Proposition 3. CFLs are not closed under intersection
Proof. â€¢ L1 = {aibicj | i, j â‰¥ 0} is a CFL
â€“ Generated by a grammar with rules S â†’ XY ; X â†’ aXb|; Y â†’ cY |.
â€¢ L2 = {aibjcj | i, j â‰¥ 0} is a CFL.
â€“ Generated by a grammar with rules S â†’ XY ; X â†’ aX|; Y â†’ bY c|.
â€¢ But L1 âˆ© L2 = {anbncn | n â‰¥ 0}, which we will see soon, is not a CFL.
Intersection with Regular Languages
Proposition 4. If L is a CFL and R is a regular language then L âˆ©R is a CFL.
Proof. Let P be the PDA that accepts L, and let M be the DFA that accepts R. A new PDA
P â€² will simulate P and M simultaneously on the same input and accept if both accept. Then P â€²
accepts L âˆ©R.
2
â€¢ The stack of P â€² is the stack of P
â€¢ The state of P â€² at any time is the pair (state of P , state of M)
â€¢ These determine the transition function of P â€²
â€¢ The final states of P â€² are those in which both the state of P and state of M are accepting.
More formally, letM = (Q1,Î£, Î´1, q1, F1) be a DFA such that L(M) = R, and P = (Q2,Î£,Î“, Î´2, q2, F2)
be a PDA such that L(P ) = L. Then consider P â€² = (Q,Î£,Î“, Î´, q0, F ) such that
â€¢ Q = Q1 Ã—Q2
â€¢ q0 = (q1, q2)
â€¢ F = F1 Ã— F2
Î´((p, q), x, a) =
{ {((p, qâ€²), b) | (qâ€², b) âˆˆ Î´2(q, x, a)} when x = 
{((pâ€², qâ€²), b) | pâ€² = Î´1(p, x) and (qâ€², b) âˆˆ Î´2(q, x, a)} when x 6= 
One can show by induction on the number of computation steps, that for any w âˆˆ Î£âˆ—
ã€ˆq0, ã€‰ wâˆ’â†’P â€² ã€ˆ(p, q), Ïƒã€‰ iff q1 wâˆ’â†’M p and ã€ˆq2, ã€‰ wâˆ’â†’P ã€ˆq, Ïƒã€‰
The proof of this statement is left as an exercise. Now as a consequence, we have w âˆˆ L(P â€²)
iff ã€ˆq0, ã€‰ wâˆ’â†’P â€² ã€ˆ(p, q), Ïƒã€‰ such that (p, q) âˆˆ F (by definition of PDA acceptance) iff ã€ˆq0, ã€‰ wâˆ’â†’P â€²
ã€ˆ(p, q), Ïƒã€‰ such that p âˆˆ F1 and q âˆˆ F2 (by definition of F ) iff q1 wâˆ’â†’M p and ã€ˆq2, ã€‰ wâˆ’â†’P ã€ˆq, Ïƒã€‰ and
p âˆˆ F1 and q âˆˆ F2 (by the statement to be proved as exercise) iff w âˆˆ L(M) and w âˆˆ L(P ) (by
definition of DFA acceptance and PDA acceptance).
Why does this construction not work for intersection of two CFLs?
Complementation
Proposition 5. Context-free languages are not closed under complementation.
Proof. [Proof 1] Suppose CFLs were closed under complementation. Then for any two CFLs L1,
L2, we have
â€¢ L1 and L2 are CFL. Then, since CFLs closed under union, L1 âˆª L2 is CFL. Then, again by
hypothesis, L1 âˆª L2 is CFL.
â€¢ i.e., L1 âˆ© L2 is a CFL
i.e., CFLs are closed under intersection. Contradiction!
[Proof 2] L = {x | x not of the form ww} is a CFL.
â€¢ L generated by a grammar with rules X â†’ a|b, Aâ†’ a|XAX, B â†’ b|XBX, S â†’ A|B|AB|BA
But L = {ww | w âˆˆ {a, b}âˆ—} we will see is not a CFL!
3
Set Difference
Proposition 6. If L1 is a CFL and L2 is a CFL then L1 \ L2 is not necessarily a CFL
Proof. Because CFLs not closed under complementation, and complementation is a special case of
set difference. (How?)
Proposition 7. If L is a CFL and R is a regular language then L \R is a CFL
Proof. L \R = L âˆ©R
1.3 Homomorphisms
Homomorphism
Proposition 8. Context free languages are closed under homomorphisms.
Proof. Let G = (V,Î£, R, S) be the grammar generating L, and let h : Î£âˆ— â†’ Î“âˆ— be a homomorphism.
A grammar Gâ€² = (V â€²,Î“, Râ€², Sâ€²) for generating h(L):
â€¢ Include all variables from G (i.e., V â€² âŠ‡ V ), and let Sâ€² = S
â€¢ Treat terminals in G as variables. i.e., for every a âˆˆ Î£
â€“ Add a new variable Xa to V
â€²
â€“ In each rule of G, if a appears in the RHS, replace it by Xa
â€¢ For each Xa, add the rule Xa â†’ h(a)
Gâ€² generates h(L). (Exercise!)
Example 9. Let G have the rules S â†’ 0S0|1S1|.
Consider the homorphism h : {0, 1}âˆ— â†’ {a, b}âˆ— given by h(0) = aba and h(1) = bb.
Rules of Gâ€² s.t. L(Gâ€²) = L(L(G)):
S â†’ X0SX0|X1SX1|
X0 â†’ aba
X1 â†’ bb
4
1.4 Inverse Homomorphisms
Inverse Homomorphisms
Recall: For a homomorphism h, hâˆ’1(L) = {w | h(w) âˆˆ L}
Proposition 10. If L is a CFL then hâˆ’1(L) is a CFL
Proof Idea
For regular language L: the DFA for hâˆ’1(L) on reading a symbol a, simulated the DFA for L on
h(a). Can we do the same with PDAs?
â€¢ Key idea: store h(a) in a â€œbufferâ€ and process symbols from h(a) one at a time (according
to the transition function of the original PDA), and the next input symbol is processed only
after the â€œbufferâ€ has been emptied.
â€¢ Where to store this â€œbufferâ€? In the state of the new PDA!
Proof. Let P = (Q,âˆ†,Î“, Î´, q0, F ) be a PDA such that L(P ) = L. Let h : Î£
âˆ— â†’ âˆ†âˆ— be a homomor-
phism such that n = maxaâˆˆÎ£ |h(a)|, i.e., every symbol of Î£ is mapped to a string under h of length
at most n. Consider the PDA P â€² = (Qâ€²,Î£,Î“, Î´â€², qâ€²0, F â€²) where
â€¢ Qâ€² = QÃ—âˆ†â‰¤n, where âˆ†â‰¤n is the collection of all strings of length at most n over âˆ†.
â€¢ qâ€²0 = (q0, )
â€¢ F â€² = F Ã— {}
â€¢ Î´â€² is given by
Î´â€²((q, v), x, a) =
{
{((q, h(x)), )} if v = a = 
{((p, u), b) | (p, b) âˆˆ Î´(q, y, a)} if v = yu, x = , and y âˆˆ (âˆ† âˆª {})
and Î´â€²(Â·) = âˆ… in all other cases.
We can show by induction that for every w âˆˆ Î£âˆ—
ã€ˆqâ€²0, ã€‰ wâˆ’â†’P â€² ã€ˆ(q, v), Ïƒã€‰ iff ã€ˆq0, ã€‰ w
â€²âˆ’â†’P ã€ˆq, Ïƒã€‰
where h(w) = wâ€²v. Again this induction proof is left as an exercise. Now, w âˆˆ L(P â€²) iff ã€ˆqâ€²0, ã€‰ wâˆ’â†’P â€²
ã€ˆ(q, ), Ïƒã€‰ where q âˆˆ F (by definition of PDA acceptance and F â€²) iff ã€ˆq0, ã€‰ h(w)âˆ’â†’P ã€ˆq, Ïƒã€‰ (by exercise)
iff h(w) âˆˆ L(P ) (by definition of PDA acceptance). Thus, L(P â€²) = hâˆ’1(L(P )) = hâˆ’1(L).
5
