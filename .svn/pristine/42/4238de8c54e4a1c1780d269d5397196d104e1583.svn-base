MP6 available, due 11/19, 11:59p.  
Exam 2: returned in section this week. 
 
 
 
 
  
 
Today’s announcements: 
(min)Heap: buildHeap 
I U 
L 
A P 
D 
N O 
H 
W 
E 
B 
W O N P A E H D L I U B 
(min)Heap: buildHeap - 3 alternatives 
I U 
L 
A P 
D 
N O 
H 
W 
E 
B 
W O N P A E H D L I U B 
template <class T> 
void Heap<T>::buildHeap(){ 
   for (int i=2;i<=size;i++) 
      heapifyUp(i) 
} 
template <class T> 
void Heap<T>::buildHeap(){ 
   for (int i=parent(size);i>0;i--) 
      heapifyDown(i) 
} 
1. Sort the array: 
2. 3. 
(min)Heap: buildHeap 
E B 
L 
U P 
D 
N O 
H 
W 
I 
A 
W O N P U I H D L E B A 
Thm:  The running time of buildHeap on an 
array of size n is ________.  
Instead of focussing specifically on running 
time, we observe that the time is 
proportional to the sum of the heights of all 
of the nodes, which we denote by S(h). 
S(h) =  
S(0) =  
Soln S(h) =  
Proof of solution to the recurrence: 
 
 
 
But running times are reported in terms of n, the number of nodes... 
  
(min)Heap: heapSort 
E B 
L 
U P 
D 
N O 
H 
W 
I 
A 
W O N P U I H D L E B A 
Running time? 
 
Why do we need another 
sorting algorithm? 
•   
 
•    
1  
2   
3 
    
This image reminds us of a ____heap________,  
which is one way we can implement ADT _______ priority queue______,  
whose functions include ___ insert____ and _ remove___, 
whose running times are __________. 
This structure can be built in time ____________. 
An example: 
Let R be an equivalence relation on the set of students in this room, where 
(s,t)   R if s and t have the same major. 
 
 
 
 
 
 
 
Notation from  math: [ ___ ]R = {x : xR___} 
One big goal for us:  Given s and t we want to determine if sRt. 
A Disjoint Sets example: 
Let R be an equivalence relation on the set of students in this room, where 
(s,t)  R if s and t have the same major. 
0 1 4 8 2 5 9 3 6 7 
1.  Find(4) 
2.  Find(4)==Find(8) 
3.  If (!(Find(7)==Find(2)) then Union(Find(7),Find(2)) 
Disjoint Sets ADT 
We will implement a data structure in support of “Disjoint Sets”: 
•  Maintains a collection S = {s0, s1, … sk} of disjoint sets. 
•  Each set has a representative member. 
•  Supports functions: 
A first data structure for Disjoint Sets: 
Find: 
Union: 
void MakeSet(const T & k); 
void Union(const T & k1, const T & k2); 
T & Find(const T & k); 
0 1 2 3 0 1 2 3 
0 1 2 3 
A better data structure for Disjoint Sets:  UpTrees 
• if array value is -1, then we’ve found a root, o/w value is index of parent. 
• x and y are in the same tree iff they are in the same set. 
A Disjoint Sets example: 
Let R be an equivalence relation on the set of students in this room, where 
(s,t)    R if s and t have the same major. 
0 1 4 8 2 5 9 3 6 7 
0 1 2 3 4 5 6 7 8 9 
4 8 5 6 -1 -1 -1 -1 4 5 
1.  Find(4) 
2.  Find(4)==Find(8) 
3.  If (!(Find(7)==Find(2)) then Union(Find(7),Find(2)) 
A better data structure for Disjoint Sets: 
int DS::Find(int i) { 
   if (s[i] < 0) return i; 
   else return Find(s[i]); 
} 
void DS::Union(int root1, int root2) { 
   ________________________; 
} 
Running time depends on ___________. 
Worst case? 
What’s an ideal tree? 
