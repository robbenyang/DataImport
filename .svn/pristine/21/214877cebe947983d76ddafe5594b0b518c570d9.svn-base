1 High-Level Descriptions of Computation
High-Level Descriptions of Computation
‚Ä¢ Instead of giving a Turing Machine, we shall often describe a program as code in some
programming language (or often ‚Äúpseudo-code‚Äù)
‚Äì Possibly using high level data structures and subroutines
‚Ä¢ Inputs and outputs are complex objects, encoded as strings
‚Ä¢ Examples of objects:
‚Äì Matrices, graphs, geometric shapes, images, videos, . . .
‚Äì DFAs, NFAs, Turing Machines, Algorithms, other machines . . .
Encoding Complex Objects
‚Ä¢ ‚ÄúEverything‚Äù finite can be encoded as a (finite) string of symbols from a finite alphabet (e.g.
ASCII)
‚Äì Can in turn be encoded in binary (as modern day computers do). No special unionsq symbol:
use self-terminating representations
Example 1. A ‚Äúgraph‚Äù can be encoded as „Äà(1, 2, 3, 4)((1, 2)(2, 3)(3, 1)(1, 4))„Äâ where the graph is
1
2
3
4
Notation
For any object O, we will use „ÄàO„Äâ to denote its representation as a binary string.
‚Ä¢ Thus, if M is a DFA/PDA/TM then „ÄàM„Äâ is its encoding as a binary string.
‚Ä¢ If G is a graph then „ÄàG„Äâ is its representation as a string.
‚Ä¢ If O1, O2, . . . On are objects then „ÄàO1, . . . On„Äâ is the representation of these objects as a single
string.
Problems with Programs/Machines as Input
‚Ä¢ We will often consider problems where machines/programs are given as input.
‚Äì Given an NFA, construct the equivalent DFA; given an NFA N and word w, decide if
w ‚àà L(N); . . .
1
‚Ä¢ All of these algorithms can be implemented on a Turing machine
‚Ä¢ Some of these algorithms are for decision problems, while others are for computing more
general functions
Decision Problems and Languages
Recall
‚Ä¢ Decision problems are problems that require a yes/no answer on a given input
‚Ä¢ They have an exact correspondence to languages: L is a representation of problem P if and
only if an input x ‚àà L iff answer for x is yes in problem P .
2 Deciding vs. Recognizing
Decidable and Recognizable Languages
Recognizable Language
A Turing machine M recognizes language L if L = L(M). We say L is Turing-recognizable (or
simply recognizable) if there is a TM M such that L = L(M).
Decidable Language
A Turing machine M decides language L if L = L(M) and M halts on all inputs. We say L is
decidable if there is a TM M that decides L.
Decidable Problems
The following problems are all decidable.
‚Ä¢ Problem: Given a DFA M and input w decide if M accepts w. We can write this formally
as a language (using our notation) as Adfa = {„ÄàM,w„Äâ |M is a DFA and w ‚àà L(M)}.
Algorithm: ‚ÄúSimulate‚Äù M on w and answer ‚Äúyes‚Äù iff M reaches a final state.
‚Ä¢ Problem: Given a NFA M and input w decide if M accepts w. We can write this formally
as a language (using our notation) as Anfa = {„ÄàM,w„Äâ |M is an NFA and w ‚àà L(M)}.
Algorithm: Convert M into a DFA and run the algorithm for Adfa.
‚Ä¢ Problem: Arex = {„ÄàR,w„Äâ |R is a regular expression and w ‚àà L(R)}.
Algorithm: Convert R into a NFA and run the algorithm for Anfa.
2
‚Ä¢ Problem: Given a DFA M answer ‚Äúyes‚Äù iff L(M) = ‚àÖ. Formally,
Edfa = {„ÄàM„Äâ |M is a DFA s.t. L(M) = ‚àÖ}
Algorithm: Check if a final state is reachable from the start state by using a graph search
algorithm like DFS/BFS.
‚Ä¢ Problem: Given DFA A and B, check if L(A) = L(B). In other words,
EQdfa = {„ÄàA,B„Äâ |A,B are DFAs s.t. L(A) = L(B)}.
Algorithm: Construct (using cross-product construction) the DFA C recognizing (L(A) ‚à©
L(B)) ‚à™ (L(A) ‚à© L(B)) and check if L(C) = ‚àÖ.
‚Ä¢ Problem: Acfg = {„ÄàG,w„Äâ |G is a CFG s.t. w ‚àà L(G)}.
Algorithm: Convert G to G‚Ä≤ in Chomsky normal form. Now w ‚àà L(G‚Ä≤) iff w can be derived
in 2|w| ‚àí 1 steps, where none of the intermediate strings is of length more than |w|. Go
through all such derivations (which is finite) and check if they derive w.
2.1 An Undecidable but Recognizable Language
Decidable and Recognizable Languages
‚Ä¢ But not all languages are decidable! In the next class we will see an example:
‚Äì Atm = {„ÄàM,w„Äâ |M is a TM and w ‚àà L(M)} is undecidable
‚Ä¢ However Atm is Turing-recognizable!
Proposition 2. There are languages which are recognizable, but not decidable
Recognizing Atm
Program U for recognizing Atm:
On input „ÄàM,w„Äâ
simulate M on w
if simulated M accepts w, then accept
else reject (by moving to qrej)
U (the Universal TM) accepts „ÄàM,w„Äâ iff M accepts w. i.e.,
L(U) = Atm
But U does not decide Atm: If M rejects w by not halting, U rejects „ÄàM,w„Äâ by not halting.
Indeed (as we shall see) no TM decides Atm.
3
2.2 Complementation
Deciding vs. Recognizing
Proposition 3. If L and L are recognizable, then L is decidable
Proof. Program P for deciding L, given programs PL and PL for recognizing L and L:
‚Ä¢ On input x, simulate PL and PL on input x. Whether x ‚àà L or x 6‚àà L, one of PL and PL will
halt in finite number of steps.
‚Ä¢ Which one to simulate first? Either could go on forever.
‚Ä¢ On input x, simulate in parallel PL and PL on input x until either PL or PL accepts
‚Ä¢ If PL accepts, accept x and halt. If PL accepts, reject x and halt.
In more detail, P works as follows:
On input x
for i = 1, 2, 3, . . .
simulate PL on input x for i steps
simulate PL on input x for i steps
if either simulation accepts, break
if PL accepted, accept x (and halt)
if PL accepted, reject x (and halt)
(Alternately, maintain configurations of PL and PL, and in each iteration of the loop advance
both their simulations by one step.)
Deciding vs. Recognizing
So far:
‚Ä¢ Atm is undecidable (next lecture)
‚Ä¢ But it is recognizable
‚Ä¢ Is every language recognizable? No!
Proposition 4. Atm is unrecognizable
Proof. If Atm is recognizable, since Atm is recognizable, the two languages will be decidable too!
Note: Decidable languages are closed under complementation, but recognizable languages are
not.
4
3 Recursive Enumeration
3.1 Enumerators
Enumerators
write only output tape
read/write work tape
read/write work tape
finite-state
control
‚Ä¢ An enumerator is multi-tape Turing Machine, with a special output tape which is write-only
‚Äì Write-only means (a) symbol on output tape does not affect transitions, and (b) tape
head only moves right.
‚Ä¢ Intially all tapes blank (no input). During computation the machine adds symbols to the
output tape. Output considered to be a list of words (separated by special symbol #)
Recursively Enumerable Languages
Definition 5. An enumerator M is said to enumerate a string w if and only if at some point M
writes a word w on the output tape. E(M) = {w |M enumerates w}
Note
M need not enumerate strings in order. It is also possible that M lists some strings many times!
Definition 6. L is recursively enumerable (r.e.) iff there is an enumerator M such that L = E(M).
3.2 Equivalence of Enumerating and Recognizing a Language
Recursively Enumerable Languages and TMs
Theorem 7. L is recursively enumerable if and only if L is Turing-recognizable.
Note
Hence, when we say a language L is recursively enumerable (r.e.) then
5
‚Ä¢ there is a TM that accepts L, and
‚Ä¢ there is an enumerator that enumerates L.
Proof. Enumerator to Recognizer: Suppose L is enumerated by N . Need to construct M such
that L(M) = E(N). M is the following TM
On input w
Run N. Every time N writes a word ‚Äòx‚Äô
compare x with w.
If x = w then accept and halt
else continue simulating N
Clearly, if w ‚àà L, M accepts w, and if w 6‚àà L then M never halts.
Flawed Solution to Construct an enumerator: Let M be such that L = L(M). Need to
construct N such that E(N) = L(M). N is the following enumerator
for w = , 0, 1, 00, 01, 10, 11, 000, . . . do
simulate M on w
if M accepts w then write the word ‚Äòw‚Äô
on output tape
Does N enumerate L? No!! M may not halt on a string w 6‚àà L, in which case N will not output
any more strings! Therefore, one must simulate M on all inputs in parallel. But that means we
need to have infinitely many parallel executions. How can this be accomplished?
Correct Construction using Dovetailing: Let M be such that L = L(M). Need to con-
struct N such that E(N) = L(M). N is the following enumerator
for i = 1, 2, 3 . . . do
let w1, w2, . . . wi be the first i strings (in
lexicographic order)
simulate M on w1 for i steps, then on w2 for i
steps and ...simulate M on wi for i steps
if M accepts wj within i steps then write wj
(with separator) on output tape
Observe that w ‚àà L(M) iff N will enumerates w. N will enumerate strings many times!
6
