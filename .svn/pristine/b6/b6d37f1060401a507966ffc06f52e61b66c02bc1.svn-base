Announcements
MP3, EC grading runs 9/27-10/1 with EC due 10/1, all due 
10/08, 11:59p.
MP 3.1 will be on Exam 1.
Exam 1: 10/1, 7-10p, in rooms tba. 75min exam, given  3hr.
Class cancelled 9/30.
Review session – 9/30, 12-2p, Siebel 1404.
Review session – 9/30, 2-3p, Siebel 0216.
MP2 solution party: Sun, 9/29, 4-6pm, Room TBA.
Code Challenge #1: 10/2, 9pm
Insert new node in kth position:
3 6 4
void List<LIT>::insert(int loc, LIT e) {
listNode * newnode = new listNode(e);
listNode * t = Find(head, loc-2);
newnode->next = t->next;
t->next = newnode;
}
Analysis:    insert new kth in array:
Insert new node in kth position with sentinel:
X 3 6 4
Wow, this is convenient!  How do we make it happen?
template<class LIT>
List<LIT>::List(){
}
void List<LIT>::insert(int loc, LIT e) {
     listNode * curr = Find(head, loc-1);
     listNode * newN = new listNode(e);
     newN->next = curr ->next; 
     curr->next = newN;
}
Remove node in fixed position (given a pointer to node you wish to remove):
Solution #1:
X 4 2 8
void List<LIT>::removeCurrent(listNode * curr) {
}
7...
Remove node in fixed position (given a pointer to node you wish to remove):
Constant time hack:
void List<LIT>::removeCurrent(listNode * curr) {
}
X 4 2 87
Summary – running times for List functions:
      SLL  Array
Insert/Remove at front:  O(1)  O(1)
Insert at given location:  O(1)  O(1)
Remove at given location:  O(1) hack O(n) shift
Insert at arbitrary location:  O(1)   O(n) shift
Remove at arbitrary location: O(n) find O(n) shift
lots of magic:
#include <list>
#include <iostream>
#include <string>
using namespace std;
struct animal {
   string name;
   string food;
   bool big;
   animal(string n="blob", string f="you”, bool b=true):name(n),food(f),big(b) {}
};
int main() {
   animal g("giraffe","leaves"), p("penguin","fish”,false), b("bear"); 
   list<animal> zoo;
   zoo.push_back(g); zoo.push_back(p); zoo.push_back(b); //STL list insertAtEnd
   for(list<animal>::iterator it = zoo.begin(); it != zoo.end(); it++)
      cout << (*it).name << "  " << (*it).food << endl;
return 0;
}
