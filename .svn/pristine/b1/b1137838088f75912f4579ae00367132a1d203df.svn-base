1 
Building  an  Arithme0c  Machine	  
2 
Today’s  lecture  
  Register  Files,  review/cont.  
  Registers	  
  The  Arithme0c  Machine  
  Programmable	  hardware	  
  Instruc6on	  Set	  Architectures	  (ISA)	  
  Instruc6ons	  &	  Registers	  
  Assembly	  Language	  
  Machine	  Language	  
3 
How  can  we  store  more  than  1  bit?  
  We  build  registers  out  of  flip  flops.  
  Example	  4-­‐bit	  register	  made	  of	  four	  D	  flip	  flops	  
  1	  data	  input,	  1	  data	  output	  per	  flip	  flop	  
  All	  control	  signals	  use	  the	  same	  input	  
QD
reseten
QD
reseten
QD
reseten
QD
reseten
reset
clk
enable
D3 D2 D1 D0
Q3 Q2 Q1 Q0
D3
D2
D1
D0
Q3
Q2
Q1
Q0
reset
enable
4 
Register  file  implementa0on  
  A  register  file  has  3  parts  
  The  Storage:	  An	  array	  of	  registers	  
  The  Read  Ports:	  Output	  the	  value	  of	  selected	  register	  
  The  Write  Port:	  Selec6vely	  write	  one	  of	  the	  registers	  
  Let’s  consider  a  2  word  memory    
  with	  4-­‐bit	  words	  
A data
B data
A address
B address
1
1
4
4
write data
write address1
4
write enable
2  x 4
register file
1
5 
What  does  it  do?  
0
1
0
1
Time
R_dataA
R_addrA
0
1clk
0
1reset
0
1W_addr
0
1W_data 0xa 0x1 0x5 0xf 0xe
0
1W_en
0
1
0
1R_dataB
R_addrB
0!
1!
6 
2  x  4-­‐bit  register  file  (only  1  read  port  shown)  
wen
Q3D3
reset
enable
Q2D2
Q1D1
Q0D0
Q3D3
reset
enable
Q2D2
Q1D1
Q0D0
0
1
waddr
0
1
wdata[3]
wdata[2]
wdata[1]
wdata[0]
clk
reset
0
1
0
1
0
1
raddrA
rdataA[3]
rdataA[2]
rdataA[1]
rdataA[0]
7 
Building  an  “arithme0c  machine”  
  With  an  ALU  and  a  register  file,  we  can  build  a  calculator  
  Here	  are	  the	  essen6al	  parts.	  
A[31:0]
control[2:0]
out[31:0]
B[31:0]
ALU
dataAregA
reset
w_en
dataBregB
w_reg
w_data
Register 
File
reset
clk
wr_enable
Rdest
Rt
Rs
8 
Building  a  computer  processor.  
  The  key  feature  that  dis0nguishes  a  computer  processor  from  
other  digital  systems  is  programmability.  
  A  processor  is  a  hardware  system  controlled  by  soVware  
  
  An  Instruc0on  Set  Architecture  (ISA)  describes  the  interface  
between  the  soVware  and  the  hardware.  
  Specifies	  what	  opera6ons	  are	  available	  
  Specifies	  the	  effects	  of	  each	  opera6on	  
  
Software 
Hardware 
ISA 
9 
A  MIPS  ISA  processor  
  Different  processor  families  (x86,  PowerPC,  ARM,  MIPS,  …)  use  
their  own  instruc0on  set  architectures.  
  The  processor  we’ll  build  will  execute  a  subset  of  the  MIPS  ISA  
  Of	  course,	  the	  concepts	  are	  not	  MIPS-­‐specific	  
  MIPS	  is	  just	  convenient	  because	  it	  is	  real,	  yet	  simple	  
  The  MIPS  ISA  is  widely  used.  Primarily  in  embedded  systems:  
  Various	  routers	  from	  Cisco	  
  Game	  machines	  like	  the	  Nintendo	  64	  and	  Sony	  Playsta6on	  2	  
  
10 
Programming  and  CPUs  
  Programs  wri_en  in  a  high-­‐level  
language  like  C++  must  be  
compiled  to  produce  an  
executable  program.  
  The  result  is  a  CPU-­‐specific  
machine  language  program.  This  
can  be  loaded  into  memory  and  
executed  by  the  processor.  
  Machine  language  serves  as  the  
interface  between  hardware  
and  soVware.   Datapath 
High-level program 
Executable file 
Control signals 
Compiler 
Control Unit 
Hardware 
Software 
11 
High-­‐level  languages  vs.  machine  language  
  High-­‐level  languages  are  designed  for  human  usage:  
  Useful	  programming	  constructs	  (for	  loops,	  if/else)	  
  Func6ons	  for	  code	  abstrac6on;	  variables	  for	  naming	  data	  
  Safety	  features:	  type	  checking,	  garbage	  collec6on	  
  Portable	  across	  pla\orms	  
  Machine  language  is  designed  for  efficient  hardware  
implementa0on  
  Consists	  of	  very	  simple	  statements,	  called	  instruc0ons  
  Data	  is	  named	  by	  where	  it	  is	  being	  stored	  
  Loops,	  if/else	  implemented	  by	  branch	  and	  jump	  instruc6ons	  
  Li]le	  error	  checking	  provided;	  no	  portability	  
12 
Assembly  Language  &  Instruc0ons  
  Machine  language  is  a  binary  representa0on  of  instruc0ons  
  Assembly  language  is  a  human-­‐readable  version  
  There  is  an  (almost)  one-­‐to-­‐one  correspondence  between  
assembly  and  machine  languages;  we’ll  see  the  rela0on  later.  
  Instruc0ons  consist  of:  
  Opera6on	  code	  (opcode):	  names	  the	  opera6on	  to	  perform	  
  Operands:	  names	  the	  data	  to	  operate	  on	  
  Example:  
ADD  $17,  $6,  $15 
operation operands 
13 
MIPS: register-to-register, “three address” 
  MIPS uses three-address instructions for arithmetic. 
  Each ALU instruction contains a destination and two sources. 
  MIPS is a register-to-register architecture. 
  For arithmetic instructions, the destination and sources must all 
be registers (or constants). 
  Special instructions move values between the register file and 
memory.  
  For example, an addition (a = b + c) might look like: 
ADD  $17,  $6,  $15 
operation 
destination sources 
operands $6  =  register  #6  
14 
MIPS register file 
  MIPS processors have 32 registers, each of which 
holds a 32-bit value.  
  Register specifiers are 5 bits long. 
  The data inputs and outputs are 32-bits wide. 
  Register 0 is special 
  It is always read as the value 0. 
  Writes to it are ignored. 
  Two naming conventions for regs: 
  By number: $0,…, $17,…, $31 
  By name: $zero,…, $s1,…, $ra 
D data 
 Write 
 D address 
 A address B address 
A data B data 
32 × 32 Register File 
5 5 
5 
 32 
 32  32 
15 
A  32  x  32b  Register  File  
Figure 2: Block diagram of register file internals.
3
16 
Decoders  
  This  circuit  is  a  1-­‐to-­‐2  decoder  
  It	  decodes	  a	  1-­‐bit	  address,	  se^ng	  the	  specified	  output	  to	  1	  
  Assuming	  the	  circuit	  is	  enabled	  
AND
NOT
AND
Q1
Q0
EN
S0
1
0
Q1
Q0
EN
S0
EN S0 (Q1,Q0) 
0 X (0, 0) 
1 0 (0, 1) 
1 1 (1, 0) 
17 
Scaling  Decoders  
  Decoders  can  be  generalized  as  follows  
  A  1-­‐to-­‐2n  decoder:  
  Has	  a	  1-­‐bit	  enable	  input,	  and	  an	  n-­‐bit	  select	  input	  	  
  Has	  2n	  outputs	  
  All	  the	  outputs	  are	  zero,	  except	  the	  selectth	  if	  enable	  =	  1	  
  If	  enable	  =	  0,	  all	  outputs	  are	  zero.	  
  A  1-­‐to-­‐4  decoder:  
EN S[1:0] Q[3:0] 
0 X (0,0,0,0) 
1 (0,0) (0,0,0,1) 
1 (0,1) (0,0,1,0) 
1 (1,0) (0,1,0,0) 
1 (1,1) (1,0,0,0) 
EN S[4:0] Q[31:0] 
0 X 0x0000 
1 0 0x0001 
1 1 0x0002 
1 … … 
1 30 0x4000 
1 31 0x8000 
Q1
Q0
1
0
Q3
EN
S[1:0]
Q2
2
3
Q1
Q0
Q31
EN
S[4:0]
Q30
18 
Basic arithmetic and logic operations 
  MIPS provides basic integer arithmetic operations:  
     add    sub    mul*    div* 
  And logical operations: 
and    or    nor    xor     not 
  Remember that these all require three register 
operands; for example: 
  add  $14, $18, $3  # $14 = $18 + $3 
  mul  $22, $22, $11  # $22 = $22 x $11 
 
 
Note: a full MIPS ISA reference can be found in Appendix A 
(linked from website) *  We  won’t  implement  these  in  our  implementa3on  
19 
  More complex arithmetic expressions may require 
multiple operations at the instruction level. 
$4 = ($1 + $2) × ($3 - $4)  
  add  $4, $1, $2  # $4 contains $1 + $2 
  sub  $5, $3, $4  # Temporary value $5 = $3 - $4 
  mul  $4, $4, $5  # $4 contains the final product 
  Temporary registers may be necessary, since each 
MIPS instructions can access only two source registers 
and one destination. 
  could have re-used $3 instead of introducing $5. 
  But be careful not to modify registers that are 
needed again later. 
Larger expressions 
20 
Immediate operands 
  So far, the instructions expect register operands. How 
do you get data into registers in the first place? 
  Some instructions allow you to specify a signed 
constant, or “immediate” value, for the second source 
instead of a register.  
  For example, here is the immediate add instruction, 
addi: 
  addi $15, $1, 4  # $15 = $1 + 4 
  Immediate operands can be used in conjunction with 
the $zero register to write constants into registers: 
   addi $15, $0, 4  # $15 = 4 
21 
January 23, 2013 Introduction to CS232 21 
A more complete example 
  What if we wanted to compute the following? 
1 + 2 + 3 + 4 
22 
January 23, 2013 Introduction to CS232 22 
A more complete example 
  What if we wanted to compute the following? 
1 + 2 + 3 + 4 
II!
addi $1, $0, 1!
addi $1, $1, 2!
addi $1, $1, 3!
addi $1, $1, 4!
III!
addi $1, $0, 1!
addi $2, $0, 2!
addi $3, $0, 3!
addi $4, $0, 4!
add  $1, $1, $2!
add  $3, $3, $4!
add  $1, $1, $3!
I!
addi $1, 1, 2!
addi $2, 3, 4!
add  $1, $1, $2!
A:  none of the above!
B:  I and II!
C:  I and III!
D:  II and III!
E:  all of the above!
23 
How  do  instruc0ons  control  the  datapath?  
  First  step  is  to  learn  how  instruc0ons  are  encoded  
A[31:0]
control[2:0]
out[31:0]
B[31:0]
ALU
dataAregA
reset
w_en
dataBregB
w_reg
w_data
Register 
File
reset
clk
wr_enable
Rdest
Rt
Rs
24 
Machine  Language  
  Machine language is a binary format that can be stored 
in memory and decoded by the CPU. 
  MIPS machine language is designed to be easy to decode 
  Each MIPS instruction is the same length, 32 bits. 
  There are only three different instruction formats, 
which are very similar to each other. 
  We’ll see two of them today 
25 
R-type format 
  Register-to-register arithmetic instructions use the R-type format. 
 
  This format includes six different fields. 
— op is an operation code or opcode that selects a specific operation. 
— rs and rt are the first and second source registers. 
— rd is the destination register. 
— shamt is only used for shift instructions. 
— func is used together with op to select an arithmetic instruction.  
op rs rt rd shamt func 
6 bits 5 bits 5 bits 5 bits 5 bits 6 bits 
26 
January 23, 2013 Machine Language and Pointers 26 
I-type format 
  Instructions with immediates all use the I-type format. 
 
  For uniformity, op, rs and rt are in the same positions as in R-type 
  The meaning of the register fields depends on the exact 
instruction. 
— For arithmetic instructions, rt is the destination and rs a source. 
  The address is a 16-bit signed two’s-complement value. 
  It can range from -32,768 to +32,767. 
op rs rt address 
6 bits 5 bits 5 bits 16 bits 
