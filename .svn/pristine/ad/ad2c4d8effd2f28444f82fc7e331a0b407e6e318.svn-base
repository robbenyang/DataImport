10/15/13 1 
Programming Languages and 
Compilers (CS 421) 
Elsa L Gunter 
2112 SC, UIUC 
http://courses.engr.illinois.edu/cs421 
Based in part on slides by Mattox Beckman, as updated 
by Vikram Adve and Gul Agha 
10/15/13 2 
Two Problems 
n  Type checking 
n  Question: Does exp. e have type τ in env Γ? 
n  Answer: Yes / No 
n  Method: Type derivation 
n  Typability  
n  Question Does exp. e have some type in env. Γ? 
If so, what is it? 
n  Answer: Type τ / error 
n  Method: Type inference 
10/15/13 3 
Type Inference - Outline 
n  Begin by assigning a type variable as the type of 
the whole expression 
n  Decompose the expression into component 
expressions 
n  Use typing rules to generate constraints on 
components and whole 
n  Recursively find substitution that solves typing 
judgment of first subcomponent 
n  Apply substitution to next subcomponent and find 
substitution solving it; compose with first, etc. 
n  Apply comp of all substitution to orig. type var. to 
get answer 
10/15/13 4 
Type Inference - Example 
n  What type can we give to 
(fun x -> fun f -> f x) 
n  Start with a type variable and then look at 
the way the term is constructed 
10/15/13 5 
Type Inference - Example 
n  First approximate: 
[ ] |- (fun x -> fun f -> f (f x)) : α 
 
n  Second approximate: use fun rule 
[x : β] |- (fun f -> f (f x)) : γ 
[ ] |- (fun x -> fun f -> f (f x)) : α 
n   Remember constraint α ≡ (β → γ) 
10/15/13 6 
Type Inference - Example 
n  Third approximate: use fun rule 
[f : δ ; x : β] |- f (f x) : ε 
[x : β] |- (fun f -> f (f x)) : γ 
[ ] |- (fun x -> fun f -> f(f x)) : α 
n   α ≡ (β → γ); γ ≡ (δ → ε) 
10/15/13 7 
Type Inference - Example 
n  Fourth approximate: use app rule 
[f:δ; x:β]|- f : ϕ → ε  [f:δ; x:β]|- f x : ϕ 
[f : δ ; x : β] |- (f (f x)) : ε 
[x : β] |- (fun f -> f (f x)) : γ 
[ ] |- (fun x -> fun f -> f (f x)) : α 
n   α ≡ (β → γ); γ ≡ (δ → ε) 
10/15/13 8 
Type Inference - Example 
n  Fifth approximate: use var rule, get 
constraint δ≡ϕ → ε, Solve with same 
n  Apply to next sub-proof 
[f:δ; x:β]|- f : ϕ → ε  [f:δ; x:β]|- f x : ϕ 
[f : δ ; x : β] |- (f (f x)) : ε 
[x : β] |- (fun f -> f (f x)) : γ 
[ ] |- (fun x -> fun f -> f (f x)) : α 
n   α ≡ (β → γ); γ ≡ (δ → ε) 
10/15/13 9 
Type Inference - Example 
n  Current subst: {δ≡ϕ → ε}  
…    [f:ϕ → ε; x:β]|- f x : ϕ 
[f : δ ; x : β] |- (f (f x)) : ε 
[x : β] |- (fun f -> f (f x)) : γ 
[ ] |- (fun x -> fun f -> f (f x)) : α 
n   α ≡ (β → γ); γ ≡ (δ → ε) 
10/15/13 10 
Type Inference - Example 
n  Current subst: {δ≡ϕ → ε}  
[f:ϕ→ε; x:β]|- f:ζ→ϕ  [f:ϕ→ε; x:β]|- x:ζ 
…    [f:ϕ → ε; x:β]|- f x : ϕ 
[f : δ ; x : β] |- (f (f x)) : ε 
[x : β] |- (fun f -> f (f x)) : γ 
[ ] |- (fun x -> fun f -> f (f x)) : α 
n   α ≡ (β → γ); γ ≡ (δ → ε) 
10/15/13 11 
Type Inference - Example 
n  Current subst: {δ≡ϕ → ε}  
n  Var rule: Solve ζ→ϕ ≡ϕ→ε   Unification 
[f:ϕ→ε; x:β]|- f:ζ→ϕ  [f:ϕ→ε; x:β]|- x:ζ 
…    [f:ϕ → ε; x:β]|- f x : ϕ 
[f : δ ; x : β] |- (f (f x)) : ε 
[x : β] |- (fun f -> f (f x)) : γ 
[ ] |- (fun x -> fun f -> f (f x)) : α 
n   α ≡ (β → γ); γ ≡ (δ → ε) 
10/15/13 12 
Type Inference - Example 
n  Current subst: {ζ≡ε, ϕ≡ε} o {δ≡ϕ → ε}  
n  Var rule: Solve ζ→ϕ ≡ϕ→ε   Unification 
[f:ϕ→ε; x:β]|- f:ζ→ϕ  [f:ϕ→ε; x:β]|- x:ζ 
…    [f:ϕ → ε; x:β]|- f x : ϕ 
[f : δ ; x : β] |- (f (f x)) : ε 
[x : β] |- (fun f -> f (f x)) : γ 
[ ] |- (fun x -> fun f -> f (f x)) : α 
n   α ≡ (β → γ); γ ≡ (δ → ε) 
10/15/13 13 
Type Inference - Example 
n  Current subst: {ζ≡ε, ϕ≡ε, δ≡ε→ε}  
n  Apply to next sub-proof 
     …            [f:ε→ε; x:β]|- x:ε 
…    [f:ϕ → ε; x:β]|- f x : ϕ 
[f : δ ; x : β] |- (f (f x)) : ε 
[x : β] |- (fun f -> f (f x)) : γ 
[ ] |- (fun x -> fun f -> f (f x)) : α 
n   α ≡ (β → γ); γ ≡ (δ → ε) 
10/15/13 14 
Type Inference - Example 
n  Current subst: {ζ≡ε, ϕ≡ε, δ≡ε→ε}  
n  Var rule: ε≡β 
           …            [f:ε→ε; x:β]|- x:ε 
…    [f:ϕ → ε; x:β]|- f x : ϕ 
[f : δ ; x : β] |- (f (f x)) : ε 
[x : β] |- (fun f -> f (f x)) : γ 
[ ] |- (fun x -> fun f -> f (f x)) : α 
n   α ≡ (β → γ); γ ≡ (δ → ε) 
10/15/13 15 
Type Inference - Example 
n  Current subst: {ε≡β}o{ζ≡ε, ϕ≡ε, δ≡ε→ε}  
n  Solves subproof; return one layer 
           …            [f:ε→ε; x:β]|- x:ε 
…    [f:ϕ → ε; x:β]|- f x : ϕ 
[f : δ ; x : β] |- (f (f x)) : ε 
[x : β] |- (fun f -> f (f x)) : γ 
[ ] |- (fun x -> fun f -> f (f x)) : α 
n   α ≡ (β → γ); γ ≡ (δ → ε) 
10/15/13 16 
Type Inference - Example 
n  Current subst: {ε≡β, ζ≡β, ϕ≡β, δ≡β→β}  
n  Solves this subproof; return one layer 
            
…    [f:ϕ → ε; x:β]|- f x : ϕ 
[f : δ ; x : β] |- (f (f x)) : ε 
[x : β] |- (fun f -> f (f x)) : γ 
[ ] |- (fun x -> fun f -> f (f x)) : α 
n   α ≡ (β → γ); γ ≡ (δ → ε) 
10/15/13 17 
Type Inference - Example 
n  Current subst: {ε≡β, ζ≡β, ϕ≡β, δ≡β→β}  
n  Need to satisfy constraint γ ≡ (δ → ε), 
given subst: γ ≡ ((β→β) → β) 
 
[f : δ ; x : β] |- (f (f x)) : ε 
[x : β] |- (fun f -> f (f x)) : γ 
[ ] |- (fun x -> fun f -> f (f x)) : α 
n   α ≡ (β → γ); γ ≡ (δ → ε) 
10/15/13 18 
Type Inference - Example 
n  Current subst:  
{γ ≡ ((β→β) → β),ε≡β, ζ≡β, ϕ≡β, δ≡β→β}  
n  Solves subproof; return one layer 
 
[f : δ ; x : β] |- (f (f x)) : ε 
[x : β] |- (fun f -> f (f x)) : γ 
[ ] |- (fun x -> fun f -> f (f x)) : α 
n   α ≡ (β → γ); γ ≡ (δ → ε) 
10/15/13 19 
Type Inference - Example 
n  Current subst:  
{γ ≡ ((β→β) → β),ε≡β, ζ≡β, ϕ≡β, δ≡β→β}  
n  Need to satisfy constraint α ≡ (β → γ) 
given subst: α ≡ (β → ((β→β) → β))  
[x : β] |- (fun f -> f (f x)) : γ 
[ ] |- (fun x -> fun f -> f (f x)) : α 
n   α ≡ (β → γ);  
10/15/13 20 
Type Inference - Example 
n  Current subst:  
{α ≡ (β → ((β→β) → β)), 
 γ ≡ ((β→β) → β),ε≡β, ζ≡β, ϕ≡β, δ≡β→β}  
n  Solves subproof; return on layer 
[x : β] |- (fun f -> f (f x)) : γ 
[ ] |- (fun x -> fun f -> f (f x)) : α 
10/15/13 21 
Type Inference - Example 
n  Current subst:  
{α ≡ (β → ((β→β) → β)), 
 γ ≡ ((β→β) → β),ε≡β, ζ≡β, ϕ≡β, δ≡β→β}  
n  Done: α ≡ (β → ((β→β) → β)) 
[ ] |- (fun x -> fun f -> f (f x)) : α 
10/15/13 22 
Type Inference Algorithm 
Let infer (Γ, e, τ) = σ  
n   Γ is a typing environment (giving polymorphic 
types to expression variables) 
n   e is an expression 
n   τ is a type (with type variables), 
n   σ is a substitution of types for type variables 
n  Idea: σ is the constraints on type variables 
necessary for    Γ |- e : τ 
n  Should have σ(Γ) |- e : σ(τ) 
10/15/13 23 
Type Inference Algorithm 
has_type (Γ, exp, τ) = 
n  Case exp of  
n  Var v --> return Unify{τ ≡ freshInstance(Γ(v))} 
n  Replace all quantified type vars by fresh ones 
n  Const c --> return Unify{τ ≡ freshInstance ϕ } 
where Γ |- c : ϕ by the constant rules 
n  fun x -> e -->  
n  Let α, β be fresh variables 
n  Let σ = infer ([x: α] + Γ, e, β) 
n  Return Unify({σ(τ) ≡ σ(α → β)}) o σ 
10/15/13 24 
Type Inference Algorithm (cont) 
n  Case exp of 
n  App (e1 e2) --> 
n Let α be a fresh variable 
n Let σ1 = infer(Γ, e1, α → τ) 
n Let σ2 = infer(σ(Γ), e2, σ(α)) 
n Return σ2 o σ1 
10/15/13 25 
Type Inference Algorithm (cont) 
n  Case exp of 
n  If e1 then e2 else e3 --> 
n Let σ1 = infer(Γ, e1, bool) 
n Let σ2 = infer(σΓ, e2, σ1(τ)) 
n Let σ3 = infer(σ2 ο σ1(Γ),e2,σ2 ο σ(τ)) 
n Return σ3 ο σ2 ο σ1 
10/15/13 26 
Type Inference Algorithm (cont) 
n  Case exp of 
n  let x = e1 in e2 --> 
n Let α be a fresh variable 
n Let σ1 = infer(Γ, e1, α) 
n Let σ2 = 
infer([x:GEN(σ1(Γ), σ1(α))] + σ1(Γ), 
e2, σ1(τ)) 
n Return σ2 o σ1 
10/15/13 27 
Type Inference Algorithm (cont) 
n  Case exp of 
n  let rec x = e1 in e2 --> 
n Let α be a fresh variable 
n Let σ1 = infer([x: α] + Γ, e1, α) 
n Let σ2 = 
infer([x:[x:GEN(σ1(Γ),σ1(α))] + σ1(Γ)] 
+ σ1(Γ), e2, σ1(τ)) 
n Return σ2 o σ1 
10/15/13 28 
Type Inference Algorithm (cont) 
n  To infer a type, introduce type_of 
n  Let α be a fresh variable 
n  type_of (Γ, e) =  
n  Let σ = infer (Γ, e, α) 
n  Return σ (α) 
 
n  Need an algorithm for Unif 
