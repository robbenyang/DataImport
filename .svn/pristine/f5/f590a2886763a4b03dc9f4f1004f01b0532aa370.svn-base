Administrivia
1 Staff, and Office Hours
Instructional Staff
‚Ä¢ Instructor:
‚Äì Mahesh Viswanathan (vmahesh)
‚Ä¢ Teaching Assistants:
‚Äì Santosh Prabhu (prabhum2)
‚Äì Matt Wala (wala1)
‚Äì Chao Xu (chaoxu3)
‚Ä¢ Office Hours: See course webpage
2 Resources
Electronic Bulletin Boards
‚Ä¢ Webpage: courses.engr.illinois.edu/cs373
‚Ä¢ Newsgroup: We will use Piazza. Sign up at piazza.com/illinois/fall2013/cs373. Piazza
discussion page is piazza.com/illinois/fall2013/cs373/home
Resources for class material
‚Ä¢ Prerequisites: All material in CS 173, and CS 225
‚Ä¢ Lecture Notes: Available on the web-page
‚Ä¢ Additional References
‚Äì Introduction to the Theory of Computation: Michael Sipser
‚Äì Introduction to Automata Theory, Languages, and Computation: Hopcroft, and Ullman
‚Äì Introduction to Automata Theory, Languages, and Computation: Hopcroft, Motwani,
and Ullman
‚Äì Elements of the Theory of Computation: Lewis, and Papadimitriou
1
3 Grading Scheme
Grading Policy: Overview
Total Grade and Weight
‚Ä¢ Homeworks: 20%
‚Ä¢ Quizzes: 10%
‚Ä¢ Midterms: 40% (2√ó 20)
‚Ä¢ Finals: 30%
Homeworks
‚Ä¢ One homework every week: Assigned on Thursday and due the following Thursday (midnight
in homework drop boxes)
‚Ä¢ No late homeworks. Lowest two homework scores will be dropped.
‚Ä¢ Homeworks may be solved in groups of size at most 3 except homework 1.
‚Ä¢ Homework 1 will be solved online.
‚Ä¢ For the other homeworks, read Homework Guidelines on course website.
Quizzes
‚Ä¢ The day before every class on Moodle.
‚Ä¢ About 25 to 26 in total.
‚Ä¢ We will drop the 5 lowest scores.
Examinations
‚Ä¢ First Midterm: October 3, 7pm to 8:30pm
‚Ä¢ Second Midterm: October 31, 7pm to 8:30pm
‚Ä¢ Final Exam: December 18, 7pm to 10pm
‚Ä¢ Midterms will only test material since the previous exam
‚Ä¢ Final Exam will test all the course material
Course Overview
2
4 Computation
Objectives
Understand the nature of computation in a manner that is independent of our understanding of
physical laws (or of the laws themselves)
‚Ä¢ Its a fundamental scientific question
‚Ä¢ Provides the foundation for the science of computationally solving problems
Problems through the Computational Lens
Mathematical problems look fundamentally different when viewed through the computational lens
‚Ä¢ Not all problems equally easy to solve ‚Äî some will take longer or use more memory, no matter
how clever you are
‚Ä¢ Not all problems can be solved!
‚Ä¢ The ‚Äúcomplexity‚Äù of the problem influences the nature of the solution
‚Äì May explore alternate notions of ‚Äúsolving‚Äù like approximate solutions, ‚Äúprobabilistically
correct‚Äù solutions, partial solutions, etc.
5 Overview
Course Overview
The three main computational models/problem classes in the course
Computational Model Applications
Finite State Machines/
Regular Expressions
text processing, lexical analy-
sis, protocol verification
Pushdown Automata/
Context-free Gram-
mars
compiler parsing, software
modeling, natural language
processing
Turing machines undecidability, computational
complexity, cryptography
3
6 Skills
Skills
‚Ä¢ Comprehend mathematical definitions
‚Ä¢ Write mathematical definitions
‚Ä¢ Comprehend mathematical proofs
‚Ä¢ Write mathematical proofs
Mathematics Background
7 Sets, Functions, and Relations
Sets
Sets
A set is a (unordered) collection of objects without repetition. The objects in the set are called
elements/members. Sets can be described formally
‚Ä¢ By listing the elements inside braces, e.g. {3, 7, 10}
‚Ä¢ Using the set builder notation, like {w | p(w)} where p(¬∑) is a predicate. For example, {n ‚àà
N | n mod 2 = 0} is the set of all even natural numbers.
We will denote: the set of natural numbers by N (0 ‚àà N); the empty set ‚àÖ.
A set A is finite if it has finitely many elements. A is an infinite set if it is not finite. For
example N is an infinite set. The cardinality of a set A is the number of elements in A, and we
denote that by |A|.
A is a subset of B (denoted A ‚äÜ B) if every element of A is also an element of B. A is a proper
subset of B (denoted A ( B) if A ‚äÜ B and A 6= B.
Operations on Sets
Given sets A and B subsets of a universe U , we can define the following operations
union A ‚à™B = {w ‚àà U | w ‚àà A or w ‚àà B}
intersection A ‚à©B = {w ‚àà U | w ‚àà A and w ‚àà B}
difference A \B = {w ‚àà U | w ‚àà A and w 6‚àà B}
complement A = {w ‚àà U | w 6‚àà A}
powerset P(A) = {K ‚äÜ U |K ‚äÜ A}
4
Sequences and Tuples
‚Ä¢ A sequence is a ordered list of elements. For example, the sequence 7,2,3,3 is different than
2,7,3,3 and 7,2,3. Sequences maybe finite or infinite.
‚Ä¢ A tuple is a finite sequence. A k-tuple has k elements. A pair is a 2-tuple.
‚Ä¢ For sets A, B, the Cartesian product of A and B, denoted A√óB, is the set of all pairs where
the first element belongs to A and the second element belongs to B.
‚Ä¢ For sets A1, . . . Ak, the set A1 √ó A2 √ó ¬∑ ¬∑ ¬∑ √ó Ak is the collection of all k-tuples where the ith
element is a member of Ai.
Functions and Relations
Functions
A function f : A ‚Üí B maps each element of A to some element of B; A is said to be the domain
of f and B is the co-domain. The range of f is the set {b ‚àà B | ‚àÉa ‚àà A. f(a) = b}. A function
f : A‚Üí B is said to be onto if the range of f is B. f is 1-to-1 iff f(x) = f(y) implies that x = y.
If f is 1-to-1 and onto then it is said to be bijective.
When the domain of function f is a set of the form A1 √ó A2 √ó ¬∑ ¬∑ ¬∑ √ó Ak then it called a k-ary
function.
Relations
A k-ary relation on A is a R ‚äÜ A √ó A √ó A, i.e., it is a set of k-tuples all of whose elements are
members of A. A 2-ary relation is called binary relation. A binary relation R ‚äÜ A√óA is
‚Ä¢ reflexive if for every a ‚àà A, (a, a) ‚àà R,
‚Ä¢ symmetric if for every a, b ‚àà A, (a, b) ‚àà R implies (b, a) ‚àà R.
‚Ä¢ transitive if for every a, b, c ‚àà A, (a, b) ‚àà R and (b, c) ‚àà R implies (a, c) ‚àà R.
‚Ä¢ equivalence if R is reflexive, symmetric, and transitive.
7.1 Alphabets, Strings and Languages
Alphabet
Definition 1. An alphabet is any finite, non-empty set of symbols. We will usually denote it by Œ£.
Example 2. Examples of alphabets include {0, 1} (binary alphabet); {a, b, . . . , z} (English alpha-
bet); the set of all ASCII characters; {moveforward, moveback, rotate90}.
5
Strings
Definition 3. A string or word over alphabet Œ£ is a (finite) sequence of symbols in Œ£. Examples
are ‚Äò0101001‚Äô, ‚Äòstring‚Äô, ‚Äò„Äàmoveback„Äâ„Äàrotate90„Äâ‚Äô
‚Ä¢  is the empty string.
‚Ä¢ The length of string u (denoted by |u|) is the number of symbols in u. Example, || = 0,
|011010| = 6.
‚Ä¢ Concatenation: uv is the string that has a copy of u followed by a copy of v. Example, if
u = ‚Äòcat‚Ä≤ and v = ‚Äònap‚Ä≤ then uv = ‚Äòcatnap‚Ä≤. If v =  the uv = vu = u.
‚Ä¢ u is a prefix of v if there is a string w such that v = uw. Example ‚Äòcat‚Ä≤ is a prefix of ‚Äòcatnap‚Ä≤.
Languages
Definition 4. ‚Ä¢ For alphabet Œ£, Œ£‚àó is the set of all strings over Œ£. Œ£n is the set of all strings
of length n.
‚Ä¢ A language over Œ£ is a set L ‚äÜ Œ£‚àó. For example L = {1, 01, 11, 001} is a language over {0, 1}.
8 Proofs
8.1 Induction Proofs
Induction Principle
‚Ä¢ Infinite sequence of statements S0, S1, . . .
‚Ä¢ Goal: Prove ‚àÄi. Si is true
‚Ä¢ Prove S0 is true [Base Case]
‚Ä¢ For an arbitrary i, assuming Sj is true for all j < i [Induction Hypothesis], establishes Si to
be true [Induction Step].
‚Ä¢ Conclude ‚àÄi. Si is true.
Why does induction work?
‚Ä¢ Assume S0 is true (Base case holds), and for any i, assuming Sj is true for all j < i, we can
conclude Si is true (Induction step holds).
6
‚Ä¢ Suppose (for contradiction) Si does not hold for some i.
‚Ä¢ Let k be the smallest i such that Si does not hold. Existence of such a smallest k is a
consequence of a property of natural numbers that any non-empty set of natural numbers has
a smallest element in it (Well-ordering principle).
‚Ä¢ That means for all j < k, Sj holds.
‚Ä¢ Then by the induction step, Sk holds! Contradiction, establishing that Si holds for all i.
Example
Proposition 5. Prove that the sum of the first k odd numbers is kth square. That is, for all k,‚àëk
i=1(2i‚àí 1) = k2.
Proof. The result can be proved by induction on k.
Base Case Consider the case when k = 1. Then
‚àëk
i=1(2i ‚àí 1) = 2.1 ‚àí 1 = 1 = 12. This proves
the base case.
Ind. Hyp. Assume that for all k < k0,
‚àëk
i=1(2i‚àí 1) = k2.
Ind. Step Consider k = k0. Then we have,‚àëk0
i=1(2i‚àí 1) =
‚àëk0‚àí1
i=1 (2i‚àí 1) + (2k0 ‚àí 1)
= (k0 ‚àí 1)2 + (2k0 ‚àí 1) by ind. hyp.
= (k20 ‚àí 2k0 + 1) + (2k0 ‚àí 1)
= k20
Thus, the induction step is established.
7
