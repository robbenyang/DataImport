• Right deep:
Types of Join Trees
Query Optimization (32 of 64)
R3
R1
R5
R2 R4
Dynamic Programming (4 of 12)
• Given: a query  
• Assume we have a function cost() that gives us the 
cost of every join tree
• Find the best join tree for the query
Problem
Query Optimization (33 of 64)Dynamic Programming (5 of 12)
• Idea: for each subset of  ଵ ௡ compute the 
best plan for that subset
• In increasing order of set cardinality:
• ܵݐ݁݌	1: 	݂݋ݎ	ሼܴଵሽ, ሼܴଶሽ, … , ሼܴ௡ሽ
• ܵݐ݁݌	2: 	݂݋ݎ	ሼܴଵ, ܴଶሽ, ሼܴଵ, ܴଷሽ, … , ሼܴ௡ିଵ, ܴ௡ሽ
• …
• ܵݐ݁݌	݊: 	݂݋ݎ	ሼܴଵ, … , ܴ௡ሽ
• For each subset of  ܴଵ,… , ܴ௡ , also called a subquery, 
compute the following:
• Size(Q)
• Best plan for Q: Plan(Q)
• Cost of that plan: Cost(Q)
Dynamic Programming
Query Optimization (34 of 64)Dynamic Programming (6 of 12)
• To illustrate, we will make the following 
simplifications:
•
• Intermediate results:
• If P1 = a join, then the size of the intermediate result is 
size(P1), otherwise the size is 0
• Similarly for P2
• Cost of a scan = 0, i.e.,  = 0.
Dynamic Programming
Query Optimization (35 of 64)Dynamic Programming (7 of 12)
• Example:
•
= 0
•
Dynamic Programming
Query Optimization (36 of 64)Dynamic Programming (8 of 12)
• Relations: 
• Number of tuples: 2000, 5000, 3000, 1000
• Size estimation: 
Dynamic Programming
Query Optimization (37 of 64)Dynamic Programming (9 of 12)
Query Optimization (38 of 64)
Subquery Size Cost Plan
RS
RT
RU
ST
SU
TU
RST
RSU
RTU
STU
RSTU
Dynamic Programming (10 of 12)
Query Optimization (39 of 64)
Subquery Size Cost Plan
RS 100k 0 RS
RT 60k 0 RT
RU 20k 0 RU
ST 150k 0 ST
SU 50k 0 SU
TU 30k 0 TU
RST 3M 60k (RT)S
RSU 1M 20k (RU)S
RTU 0.6M 20k (RU)T
STU 1.5M 30k (TU)S
RSTU 30M 60k+50k=110k (RT)(SU)
Dynamic Programming (11 of 12)
• Summary: computes optimal plans for subqueries:
• Step 1: {R1},  {R2}, …, {Rn}
• Step 2:  {R1, R2}, {R1, R3}, …, {Rn‐1, Rn}
• …
• Step n: {R1, …, Rn}
• We used naïve size/cost estimations
• In practice:
• more realistic size/cost estimations (next time)
• heuristics for Reducing the Search Space 
• Restrict to left linear trees
• Restrict to trees “without Cartesian product”: 
• R(A,B), S(B,C), T(C,D)
• (R join T) join S has a Cartesian product
Dynamic Programming
Query Optimization (40 of 64)Dynamic Programming (12 of 12)
Completing Physical Query Plan
Query Optimization (41 of 64)Completing Physical Query Plan (0 of 13)
• Choose algorithm to implement each operator
• Need to account for more than cost:
• How much memory do we have ?
• Are the input operand(s) sorted ?
• Decide for each intermediate result:
• To materialize
• To pipeline
Completing the Physical Query Plan
Query Optimization (42 of 64)Completing Physical Query Plan (1 of 13)
Materialize Intermediate Results Between 
Operators
Query Optimization (43 of 64)
T
R S
U
HashTable  S
repeat read(R, x)
y  join(HashTable, x)
write(V1, y)
HashTable  T
repeat read(V1, y)
z  join(HashTable, y)
write(V2, z)
HashTable  U
repeat read(V2, z)
u  join(HashTable, z)
write(Answer, u)
V1
V2
Completing Physical Query Plan (2 of 13)
• Given B(R), B(S), B(T), B(U)
• What is the total cost of the plan ?
• Cost = 
• How much main memory do we need ?
• M = 
Materialize Intermediate Results Between 
Operators
Query Optimization (44 of 64)Completing Physical Query Plan (3 of 13)
Pipeline Between Operators
Query Optimization (45 of 64)
T
R S
U
HashTable1  S
HashTable2  T
HashTable3  U
repeat read(R, x)
y  join(HashTable1, x) 
z  join(HashTable2, y)
u  join(HashTable3, z)
write(Answer, u)
How much main memory do we need ? M =
Completing Physical Query Plan (4 of 13)
• Given B(R), B(S), B(T), B(U)
• What is the total cost of the plan ?
• Cost = 
• How much main memory do we need ?
• M = 
Pipeline Between Operators
Query Optimization (46 of 64)Completing Physical Query Plan (5 of 13)
• Choose algorithm to implement each operator
• Need to account for more than cost:
• How much memory do we have ?
• Are the input operand(s) sorted ?
• Decide for each intermediate result:
• To materialize
• To pipeline
Completing the Physical Query Plan
Query Optimization (47 of 64)Completing Physical Query Plan (6 of 13)
• Logical plan is:
• Main memory M = 101 buffers
Example
Query Optimization (48 of 64)
R(w,x)
5,000 blocks
S(x,y)
10,000 blocks
U(y,z)
10,000 blocks
k blocks
Completing Physical Query Plan (7 of 13)

• Naïve evaluation: 
• 2 partitioned hash‐joins
• Cost 3B(R) + 3B(S) + 4k + 3B(U) = 75000 + 4k
Example
Query Optimization (49 of 64)
R(w,x)
5,000 blocks
S(x,y)
10,000 blocks
U(y,z)
10,000 blocks
k blocks
Completing Physical Query Plan (8 of 13)
• Smarter:
• Step 1: hash R on x into 100 buckets, each of 50 
blocks; to disk
• Step 2: hash S on x into 100 buckets; to disk
• Step 3: read each Ri in memory (50 buffer) join with 
Si (1 buffer); hash result on y into 50 buckets (50 
buffers)   ‐‐ here we pipeline
• Cost so far: 3B(R) + 3B(S)
Example
Query Optimization (50 of 64)
R(w,x)
5,000 blocks
S(x,y)
10,000 blocks
U(y,z)
10,000 blocks
k blocks
Completing Physical Query Plan (9 of 13)
• Continuing:
• How large are the 50 buckets on y ?  Answer: k/50.
• If k <= 50 then keep all 50 buckets in Step 3 in 
memory, then:
• Step 4: read U from disk, hash on y and join with 
memory
• Total cost: 3B(R) + 3B(S) + B(U) = 55,000
Example
Query Optimization (51 of 64)
R(w,x)
5,000 blocks
S(x,y)
10,000 blocks
U(y,z)
10,000 blocks
k blocks
Completing Physical Query Plan (10 of 13)
