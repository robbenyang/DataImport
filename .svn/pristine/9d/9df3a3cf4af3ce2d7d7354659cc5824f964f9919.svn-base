• Logical plan is:
• Main memory M = 101 buffers
Example
Query Optimization (48 of 64)
R(w,x)
5,000 blocks
S(x,y)
10,000 blocks
U(y,z)
10,000 blocks
k blocks
Completing Physical Query Plan (7 of 13)



• Naïve evaluation: 
• 2 partitioned hash‐joins
• Cost 3B(R) + 3B(S) + 4k + 3B(U) = 75000 + 4k
Example
Query Optimization (49 of 64)
R(w,x)
5,000 blocks
S(x,y)
10,000 blocks
U(y,z)
10,000 blocks
k blocks
Completing Physical Query Plan (8 of 13)
• Smarter:
• Step 1: hash R on x into 100 buckets, each of 50 
blocks; to disk
• Step 2: hash S on x into 100 buckets; to disk
• Step 3: read each Ri in memory (50 buffer) join with 
Si (1 buffer); hash result on y into 50 buckets (50 
buffers)   ‐‐ here we pipeline
• Cost so far: 3B(R) + 3B(S)
Example
Query Optimization (50 of 64)
R(w,x)
5,000 blocks
S(x,y)
10,000 blocks
U(y,z)
10,000 blocks
k blocks
Completing Physical Query Plan (9 of 13)
• Continuing:
• How large are the 50 buckets on y ?  Answer: k/50.
• If k <= 50 then keep all 50 buckets in Step 3 in 
memory, then:
• Step 4: read U from disk, hash on y and join with 
memory
• Total cost: 3B(R) + 3B(S) + B(U) = 55,000
Example
Query Optimization (51 of 64)
R(w,x)
5,000 blocks
S(x,y)
10,000 blocks
U(y,z)
10,000 blocks
k blocks
Completing Physical Query Plan (10 of 13)
• Continuing:
• If 50 < k <= 5000 then send the 50 buckets in Step 3 
to disk
• Each bucket has size k/50 <= 100
• Step 4: partition U into 50 buckets
• Step 5: read each partition and join in memory
• Total cost: 3B(R) + 3B(S) + 2k + 3B(U) = 75,000 + 2k
Example
Query Optimization (52 of 64)
R(w,x)
5,000 blocks
S(x,y)
10,000 blocks
U(y,z)
10,000 blocks
k blocks
Completing Physical Query Plan (11 of 13)
• Continuing:
• If k > 5000 then materialize instead of pipeline
• 2 partitioned hash‐joins
• Cost 3B(R) + 3B(S) + 4k + 3B(U) = 75000 + 4k
Example
Query Optimization (53 of 64)
R(w,x)
5,000 blocks
S(x,y)
10,000 blocks
U(y,z)
10,000 blocks
k blocks
Completing Physical Query Plan (12 of 13)
• Summary:
• If k <= 50,  cost = 55,000
• If 50 < k <=5000, cost = 75,000 + 2k
• If k > 5000, cost = 75,000 + 4k
Example
Query Optimization (54 of 64)Completing Physical Query Plan (13 of 13)
Estimating Sizes
Query Optimization (55 of 64)Estimating Sizes (0 of 9)
• Need size in order to estimate cost
• Example:
• Cost of partitioned hash‐join ܧ1 ⋈ ܧ2	is 3ܤሺܧ1ሻ 	൅
	3ܤሺܧ2ሻ
• ܤሺܧ1ሻ 	ൌ 	ܶሺܧ1ሻ/	ܾ݈݋ܿ݇	ݏ݅ݖ݁
• ܤሺܧ2ሻ 	ൌ 	ܶሺܧ2ሻ/	ܾ݈݋ܿ݇	ݏ݅ݖ݁
• So, we need to estimate ܶሺܧ1ሻ, ܶሺܧ2ሻ
Estimating Sizes
Query Optimization (56 of 64)Estimating Sizes (1 of 9)
• Estimating the size of a projection
• Easy:  ௅
• A projection doesn’t eliminate duplicates
Estimating Sizes
Query Optimization (57 of 64)Estimating Sizes (2 of 9)
• Estimating the size of a selection
• ஺ୀ௖
• T(S) can be anything from 0 to ܶሺܴሻ	– 	ܸሺܴ, ܣሻ 	൅ 	1
• Mean value: ܶሺܵሻ 	ൌ 	ܶሺܴሻ/ܸሺܴ, ܣሻ
• ஺ழ௖
• T(S) can be anything from 0 to ܶሺܴሻ
• Heuristics: ܶሺܵሻ 	ൌ 	ܶሺܴሻ/3
Estimating Sizes
Query Optimization (58 of 64)Estimating Sizes (3 of 9)
• Estimating the size of a natural join,  ஺
• When the set of A values are disjoint, then 
• ஺
• When A is a key in S and a foreign key in R, then 
஺
• When A has a unique value, the same in R and S, 
then  ஺ .
Estimating Sizes
Query Optimization (59 of 64)Estimating Sizes (4 of 9)
• Assumptions:
• Containment of values: if 
then the set of R.A values is included in 
the set of S.A values
• Indeed holds when A is a foreign key in R, and a key in S
• Preservation of values: for any other attribute  ,  
• ஺ or  .
Estimating Sizes
Query Optimization (60 of 64)Estimating Sizes (5 of 9)
• Assume 
• Then each tuple  in  joins some tuple(s) in 
• How many?
• On average ܵ/ܸሺܵ, ܣሻ
• It will contribute ܵ/ܸሺܵ, ܣሻ tuples in ܴ ⋈஺ ܵ
• Hence ܶ ܴ ⋈஺ ܵ ൌ ܶ ܴ ܶሺܵሻ/ܸሺܵ, ܣሻ
• In general: 
• ܶ ܴ ⋈஺ ܵ ൌ ܶ ܴ ܶሺܵሻ/maxሺܸ ܴ, ܣ , ܸ ܵ, ܣ ሻ
Estimating Sizes
Query Optimization (61 of 64)Estimating Sizes (6 of 9)
• Example:
•
•
• How large is  ஺ ?
• Answer: 
• ஺
Estimating Sizes
Query Optimization (62 of 64)Estimating Sizes (7 of 9)
• Joins on more than one attribute:
• ஺
் ோ ் ௌ
୫ୟ୶ ௏ ோ,஺ ,௏ ௌ,஺ ⋅୫ୟ୶	ሺ௏ ோ,஻ ,௏ ௌ,஻ ሻ
Estimating Sizes
Query Optimization (63 of 64)Estimating Sizes (8 of 9)
• Statistics on data maintained by the RDBMS
• Makes size estimation much more accurate (hence, 
cost estimations are more accurate)
• Ranks(rankName, salary)
• Estimate the size of  ௌ௔௟௔௥௬
More statistics helps: E.g., Histograms
Query Optimization (64 of 64)
Employee 0..20k 20k..40k 40k..60k 60k..80k 80k..100k > 100k
200 800 5000 12000 6500 500
Ranks 0..20k 20k..40k 40k..60k 60k..80k 80k..100k > 100k
8 20 40 80 100 2
Estimating Sizes (9 of 9)
