1 Equivalence of Finite Automata and Regular Expressions
Finite Automata Recognize Regular Languages
Theorem 1. L is a regular language iff there is a regular expression R such that L(R) = L iff
there is a DFA M such that L(M) = L iff there is a NFA N such that L(N) = L.
i.e., regular expressions, DFAs and NFAs have the same computational power.
Proof. • Given regular expression R, will construct NFA N such that L(N) = L(R)
• Given DFA M , will construct regular expression R such that L(M) = L(R)
2 Regular Expressions to NFA
Regular Expressions to Finite Automata
. . . to Non-determinstic Finite Automata
Lemma 2. For any regex R, there is an NFA NR s.t. L(NR) = L(R).
Proof Idea
We will build the NFA NR for R, inductively, based on the number of operators in R, #(R).
• Base Case: #(R) = 0 means that R is ∅, , or a (from some a ∈ Σ). We will build NFAs for
these cases.
• Induction Hypothesis: Assume that for regular expressions R, with #(R) < n, there is an
NFA NR s.t. L(NR) = L(R).
• Induction Step: Consider R with #(R) = n. Based on the form of R, the NFA NR will be
built using the induction hypothesis.
Regular Expression to NFA
Base Cases
If R is an elementary regular expression, NFA NR is constructed as follows.
R = ∅
q0
R = 
q0
R = a
q0 q1
a
1
Induction Step: Union
Case R = R1 ∪R2
By induction hypothesis, there are N1, N2 s.t. L(N1) = L(R1) and L(N2) = L(R2). Build NFA N
s.t. L(N) = L(N1) ∪ L(N2)
q0
q1
q11
q12
q2 q21


Figure 1: NFA for L(N1) ∪ L(N2)
Induction Step: Union
Formal Definition
Case R = R1 ∪R2
Let N1 = (Q1,Σ, δ1, q1, F1) and N2 = (Q2,Σ, δ2, q2, F2) (with Q1 ∩Q2 = ∅) be such that L(N1) =
L(R1) and L(N2) = L(R2). The NFA N = (Q,Σ, δ, q0, F ) is given by
• Q = Q1 ∪Q2 ∪ {q0}, where q0 6∈ Q1 ∪Q2
• F = F1 ∪ F2
• δ is defined as follows
δ(q, a) =

δ1(q, a) if q ∈ Q1
δ2(q, a) if q ∈ Q2
{q1, q2} if q = q0 and a = 
∅ otherwise
Induction Step: Union
Correctness Proof
Need to show that w ∈ L(N) iff w ∈ L(N1) ∪ L(N2).
⇒ w ∈ L(N) implies q0 w−→N q for some q ∈ F . Based on the transitions out of q0, q0 −→N
q1
w−→N q or q0 −→N q2 w−→N q. Consider q0 −→N q1 w−→N q. (Other case is similar) This
means q1
w−→N1 q (as N has the same transition as N1 on the states in Q1) and q ∈ F1. This
means w ∈ L(N1).
2
⇐ w ∈ L(N1)∪L(N2). Consider w ∈ L(N1); case of w ∈ L(N2) is similar. Then, q1 w−→N1 q for
some q ∈ F1. Thus, q0 −→N q1 w−→N q, and q ∈ F . This means that w ∈ L(N).
Induction Step: Concatenation
Case R = R1 ◦R2
• By induction hypothesis, there are N1, N2 s.t. L(N1) = L(R1) and L(N2) = L(R2)
• Build NFA N s.t. L(N) = L(N1) ◦ L(N2)
q1
q11
q12
q2 q21


Figure 2: NFA for L(N1) ◦ L(N2)
Induction Step: Concatenation
Formal Definition
Case R = R1 ◦R2
Let N1 = (Q1,Σ, δ1, q1, F1) and N2 = (Q2,Σ, δ2, q2, F2) (with Q1 ∩Q2 = ∅) be such that L(N1) =
L(R1) and L(N2) = L(R2). The NFA N = (Q,Σ, δ, q0, F ) is given by
• Q = Q1 ∪Q2
• q0 = q1
• F = F2
• δ is defined as follows
δ(q, a) =

δ1(q, a) if q ∈ (Q1 \ F1) or a 6= 
δ1(q, a) ∪ {q2} if q ∈ F1 and a = 
δ2(q, a) if q ∈ Q2
∅ otherwise
Induction Step: Concatenation
Correctness Proof
Need to show that w ∈ L(N) iff w ∈ L(N1) ◦ L(N2).
3
w ∈ L(N) iff q0 w−→N q for some q ∈ F = F2. The computation of N on w starts in a state of
N1 (namely, q0 = q1) and ends in a state of N2 (namely, q ∈ F2). The only transitions from a state
of N1 to a state of N2 is from a state in F1 which have -transitions to q2, the initial state of N2.
Thus, we have
q0 = q1
w−→N q with q ∈ F = F2
iff
∃q′ ∈ F1. ∃u, v ∈ Σ∗. w = uv and q0 = q1 u−→N q′ −→N q2 v−→N q
This means that q1
u−→N1 q′ (with q′ ∈ F1) and q2 v−→N2 q (with q ∈ F2). Hence, u ∈ L(N1) and
v ∈ L(N2), and so w = uv ∈ L(N1)◦L(N2). Conversely, if u ∈ L(N1) and v ∈ L(N2) then for some
q′ ∈ F1 and q ∈ F2, we have q1 u−→N1 q′ and q2 v−→N2 q. Then,
q0 = q1
u−→N q′ −→N q2 v−→N q
Thus, q0
w=uv−→ N q and so uv ∈ L(N).
Induction Step: Kleene Closure
First Attempt
Case R = R∗1
• By induction hypothesis, there is N1 s.t. L(N1) = L(R1)
• Build NFA N s.t. L(N) = (L(N1))∗
q0
q1
q2


Figure 3: NFA accepts (L(N1))
+
Problem: May not accept ! One can show that L(N) = (L(N1))
+.
Induction Step: Kleene Closure
Second Attempt
Case R = R∗1
• By induction hypothesis, there is N1 s.t. L(N1) = L(R1)
• Build NFA N s.t. L(N) = (L(N1))∗
4
q0
q1
q2


Figure 4: NFA accepts ⊇ (L(N1))∗
Problem: May accept strings that are not in (L(N1))
∗!
Example demonstrating the problem
q0 q1
0, 1
1
0, 1
Figure 5: Example NFA N
q0 q1
0, 1
1

0, 1
Figure 6: Incorrect Kleene Closure of N
L(N) = (0 ∪ 1)∗1(0 ∪ 1)∗. Thus, (L(N))∗ =  ∪ (0 ∪ 1)∗1(0 ∪ 1)∗. The previous construction, gives
an NFA that accepts 0 6∈ (L(N))∗!
Induction Step: Kleene Closure
Correct Construction
Case R = R∗1
• First build N1 s.t. L(N1) = L(R1)
• Given N1 build NFA N s.t. L(N) = L(N1)∗
5
q q0
q1
q2



Figure 7: NFA for L(N1)
∗
Induction Step: Kleene Closure
Formal Definition
Case R = R∗1
Let N1 = (Q1,Σ, δ1, q1, F1) be such that L(N1) = L(R1). The NFA N = (Q,Σ, δ, q0, F ) is given by
• Q = Q1 ∪ {q0} with q0 6∈ Q1
• F = F1 ∪ {q0}
• δ is defined as follows
δ(q, a) =

δ1(q, a) if q ∈ (Q1 \ F1) or a 6= 
δ1(q, a) ∪ {q1} if q ∈ F1 and a = 
{q1} if q = q0 and a = 
∅ otherwise
Induction Step: Kleene Closure
Correctness Proof
Let us begin by stating what our goal is. We would like to show w ∈ L(N) iff w ∈ L∗. If we choose
to prove this statement by induction, most induction proofs will fail because this statement is too
weak to be established by induction. How we choose to strengthen it depends on what parameter
we will choose to induct over. One possibility is |w|. If we do induction on the length of w, then
we need to strengthen the statement by saying which strings are accepted from any state q ∈ Q,
and not just the initial state q0 as in the above statement. We can carry such a proof out, but it is
long. We instead present a proof that does induction over a parameter different than length of w,
but before presenting this proof we need to introduce some notation and terminology that we will
find convenient.
Observe that we construct N from N1 by adding some -transitions: one from q0 to q1, and
others from q ∈ F1 to q1. We will call these “new” transitions. Recall that an accepting computation
is a sequence of steps starting from the initial state q0 and ending in some accept state, such that
every step conforms to the transition relation. Let us call a computation ρ as having n new steps,
if exactly n steps in ρ are according to the new -transitions. For any n, let us define
An = {w ∈ Σ∗ | w has an accepting computation where exactly n new transitions are used}
6
Observe that if w has an accepting computation then w ∈ An for some n ≥ 0.
We will prove by induction on n, the following statement
∀n ∈ N. w ∈ An iff w ∈ Ln
Before proving the above stronger statement by induction, let us see how proving the above state-
ment establishes the correctness of the construction. Suppose w ∈ L∗ then (by definition of Kleene
closure) w ∈ Li for some i ∈ N. By the above statement, it would mean that w ∈ Ai. In other
words, w has an accepting computation that uses exactly i new transitions, which just implies that
N accepts w. On the other hand, suppose N accepts w. Since N has an accepting computation
on w, it must have an accepting computation that uses exactly i new transitions, for some value
of i. In other words, w ∈ Ai. By the above statement that means that w ∈ Li which implies that
w ∈ L∗. Thus we can establish both sides of the correctness claim.
Let us now prove by induction on n
∀n ∈ N. w ∈ An iff w ∈ Ln
Base Case For this statement we need to establish two base cases: one when n = 0 and the other
when n = 1.
Case 1: Let n = 0. Since the only transition out of the initial state q0 is a new transition,
w ∈ A0 means that the computation takes no steps and stays in q0. If the computation on
w has no transition steps, it means that w =  and clearly w ∈ L0. On the other hand, if
w ∈ L0 then w =  and N accepts w by taking no steps as q0 ∈ F . Thus, we have established
the base case for n = 0.
Case 2: Let n = 1. Suppose w ∈ L, then N1 has an accepting computation. Thus, there
is q ∈ F1 such that q1 w−→N1 q. Observe that since every transition of N1 is a transition of
N (which is not new), and F1 ⊆ F we have the following accepting computation of N with
exactly one new transition
q0
−→N q1 w−→N1 q
Thus w ∈ A1. Conversely, suppose w ∈ A1. Again, the only transition out of q0 is a new
transition. Thus the accepting computation of N on w must be of the form
q0
−→N q1 w−→N1 q
for some q ∈ F1; the reason that q must be in F1 is because q0 (the only other accept state)
has no incoming transitions. Thus, q1
w−→N1 q for q ∈ F1, which means that w is accepted
by N1, and from the fact that L(N1) = L, we can conclude that w ∈ L = L1. We have,
therefore, established the base case for n = 1.
Ind. Hyp. Assume that for all i < n, w ∈ Ai iff w ∈ Li, where n > 1.
Ind. Step Suppose w ∈ Ln. Then there are u, v such that w = uv, u ∈ Ln−1 and v ∈ L. By
induction hypothesis, we have u ∈ An−1. Now, since n > 1, the accepting computation on u
must end in a state q ∈ F1 (because once you leave q0 you can never get back to it). Moreover
since v ∈ L, from the correctness of N1, we have q1 v−→N1 q′ for some q′ ∈ F1. Putting all of
this together we have the following accepting computation
q0
u−→N q −→N q1 v−→N1 q′
7
which has exactly n new transitions. Thus, w ∈ An. To prove the converse, suppose w ∈ An.
Since n > 1, the accepting computation on w must be of the form
q0
u−→N q −→N q1 v−→N1 q′
where w = uv, and q and q′ are some states in F1. Thus, u ∈ An−1. By induction hypothesis,
we have u ∈ Ln−1. From the correctness of N1, q1 v−→N1 q′ for q′ ∈ F1 means that v ∈ L.
Putting this together, we get that w = uv ∈ (Ln−1)L = Ln.
Regular Expressions to NFA
To Summarize
We built an NFA NR for each regular expression R inductively
• When R was an elementary regular expression, we gave an explicit construction of an NFA
recognizing L(R)
• When R = R1 op R2 (or R = op(R1)), we constructed an NFA N for R, using the NFAs for
R1 and R2.
Regular Expressions to NFA
An Example
Build NFA for (1 ∪ 01)∗
N0
0
N1
1
N01
0  1
N1∪01
1
0  1


N(1∪01)∗
1
0  1





3 DFAs to Regular Expressions
DFA to Regular Expression
8
• Given DFA M , will construct regular expression R such that L(M) = L(R). In two steps:
– Construct a “Generalized NFA” (GNFA) G from the DFA M
– And then convert G to a regex R
3.1 Generalized NFA
Generalized NFA
• A GNFA is similar to an NFA, but:
– There is a single accept state which is not the start state.
– The start state has no incoming transitions, and the accept state has no outgoing tran-
sitions.
∗ These are “cosmetic changes”: Any NFA can be converted to an equivalent NFA of
this kind.
– The transitions are labeled not by characters in the alphabet, but by regular expressions.
∗ For every pair of states (q1, q2), the transition from q1 to q2 is labeled by a regular
expression ρ(q1, q2).
– “Generalized NFA” because a normal NFA has transitions labeled by , elements in Σ
(a union of elements, if multiple edges between a pair of states) and ∅ (missing edges).
Generalized NFA
• Transition: GNFA non-deterministically reads a block of characters from the input, chooses
an edge from the current state q1 to another state q2, and if the block of symbols matches
the regex ρ(q1, q2), then moves to q2.
• Acceptance: G accepts w if there exists some sequence of valid transitions such that on
starting from the start state, and after finishing the entire input, G is in the accept state.
Generalized NFA: Example
9
q0
q1
q2
0∗10∗ 0∗
0∗
10∗10∗
Figure 8: Example GNFA G
Accepting run of G on 11110100 is q0
1−→G q1 11−→G q1 101−→G q1 00−→G q2
Generalized NFA: Definition
Definition 3. A generalized nondeterministic finite automaton (GNFA) is G = (Q,Σ, q0, qF , ρ),
where
• Q is the finite set of states
• Σ is the finite alphabet
• q0 ∈ Q initial state
• qF ∈ (Q \ {q0}, a single accepting state
• ρ : (Q \ {qF }) × (Q \ {q0}) → RΣ, where RΣ is the set of all regular expressions over the
alphabet Σ
Generalized NFA: Definition
Definition 4. For a GNFA M = (Q,Σ, q0, qF , ρ) and string w ∈ Σ∗, we say M accepts w iff there
exist x1, . . . , xt ∈ Σ∗ and states r0, . . . , rt such that
• w = x1x2x3 · · ·xt
• r0 = q0 and rt = qF
• for each i ∈ [1, t], xi ∈ L(ρ(ri−1, ri)),
10
3.2 Converting DFA to GNFA
Converting DFA to GNFA
A DFA M = (Q,Σ, δ, q0, F ) can be easily converted to an equivalent GNFA G = (Q
′,Σ, q′0, q′F , ρ):
• Q′ = Q ∪ {q′0, q′F } where Q ∩ {q′0, q′F } = ∅
• ρ(q1, q2) =

, if q1 = q
′
0 and q2 = q0
, if q1 ∈ F and q2 = q′F⋃
{a|δ(q1,a)=q2} a otherwise
q′0 q
′
F
q0
q1
q2



Prove: L(G) = L(M).
3.3 Converting GNFA to Regular Expression
GNFA to Regex
• Suppose G is a GNFA with only two states, q0 and qF .
• Then L(R) = L(G) where R = ρ(q0, qF ).
• How about G with three states?
q0
q1
qF
R4
R1 R3
R2
q0 qF
(R4) ∪ (R1R∗2R3)
11
• Plan: Reduce any GNFA G with k > 2 states to an equivalent GFA with k − 1 states.
GNFA to Regex: From k states to k − 1 states
Definition 5 (Deleting a GNFA State). Given GNFA G = (Q,Σ, q0, qF , ρ) with |Q| > 2, and any
state q∗ ∈ Q \ {q0, qF }, define GNFA rip(G, q∗) = (Q′,Σ, q0, qF , ρ′) as follows:
• Q′ = Q \ {q∗}.
• For any (q1, q2) ∈ Q′ \ {qF } ×Q′ \ {q0} (possibly q1 = q2), let
ρ′(q1, q2) = (R1R∗2R3) ∪R4,
where R1 = ρ(q1, q
∗), R2 = ρ(q∗, q∗), R3 = ρ(q∗, q2) and R4 = ρ(q1, q2).
GNFA to Regex: From k states to k − 1 states
Correctness
Proposition 6. For any q∗ ∈ Q \ {q0, qF }, G and rip(G, q∗) are equivalent.
Proof. Let G′ = rip(G, q∗). We need to show that L(G) = L(G′). We will prove this in two steps:
we will show L(G) ⊆ L(G′) and then show L(G′) ⊆ L(G).
L(G) ⊆ L(G′): First we show w ∈ L(G) =⇒ w ∈ L(G′). w ∈ L(G) =⇒ ∃q0 = r0, r1, . . . , rt = qF
and x1, . . . , xt ∈ Σ∗ such that w = x1x2x3 · · ·xt and for each i, xi ∈ L(ρ(ri−1, ri)).
We need to show y1, . . . , yd ∈ Σ∗ and q0 = s0, s1, . . . , sd = qF such that w = y1 · · · yd, and for
each i, yi ∈ L(ρ′(si−1, si)).
Define (s0 = q0, . . . , sd = qF ) to be the sequence obtained by deleting all occurrences of q
∗ from
(r0 = q0, r1, . . . , rt = qF ).
To formally define yj , first we define σ as follows:
σ(j) =

0 if j = 0
i if 0 < σ(j − 1) < t, where i = mini>σ(j−1) (ri 6= q∗)
undefined otherwise.
The range of σ is the set of indices i such that ri 6= q∗. Let d = mink(σ(k) = t). Then, sj = rσ(j),
for j = 0, . . . , d.
Now we define yj = xσ(j−1)+1 · · ·xσ(j) for j = 1, . . . , d
Then y1 · · · yd = x1 · · ·xt = w.
We need to show that yj ∈ L(ρ′(sj−1, sj)) for all j. We consider the following cases for j:
• σ(j) = σ(j − 1) + 1 (i.e., rσ(j−1)+1 6= q∗). Then yj = xi and sj−1 = ri−1 and sj = ri, where
i = σ(j). yj = xi ∈ L(ρ(ri−1, ri)) ⊆ L(ρ′(ri−1, ri)) = L(ρ′(sj−1, sj)).
12
• σ(j) > σ(j − 1) + 1 (i.e., rσ(j−1)+1 = q∗). Then yj = x` · · ·xi and sj−1 = r`−1 and sj = ri,
where ` = σ(j − 1) + 1 and i = σ(j).
yj = x` · · ·xi ∈ L(ρ(r`−1, r`)ρ(r`, r`+1) · · · ρ(ri−1, ri)ρ(ri, ri+1))
= L(ρ(r`−1, q∗)ρ(q∗, q∗)i−`ρ(q∗, ri))
⊆ L(ρ(r`−1, r`)ρ(q∗, q∗)∗ρ(q∗, ri))
⊆ L(ρ(sj−1, q∗)ρ(q∗, q∗)∗ρ(q∗, sj))
⊆ L(ρ′(sj−1, sj))
Thus w ∈ L(G′) as we set out to prove.
L(G′) ⊆ L(G): Next we need to show that w ∈ L(G′) =⇒ w ∈ L(G). w ∈ L(G′) =⇒
∃q0 = s0, s1, . . . , sd = qF and y1, . . . , yd ∈ Σ∗ such that w = y1y2y3 · · · yd and for each j, yj ∈
L(ρ′(sj−1, sj)) = L ((ρ(sj−1, q∗)ρ(q∗, q∗)∗ρ(q∗, ri)) ∪ ρ(sj−1, sj))
Define σ as follows, for j = 0, . . . , d:
σ(j) =

0 if j = 0,
σ(j − 1) + 1 if yj ∈ L(ρ(sj−1, sj))
σ(j − 1) + u+ 2 otherwise, where u = minv (yj ∈ L(ρ(sj−1, q∗)ρ(q∗, q∗)vρ(q∗, sj)))
Let t = σ(d). For i = 0, . . . , t define ri as follows:
r(i) =
{
sj if there exists j such thati = σ(j),
q∗ otherwise.
Finally, define xi (i = 1, . . . , t) as follows: if i = σ(j) and i − 1 = σ(j − 1), then let xi = yj .
For other i (σ(j − 1) < i− 1 < i ≤ σ(j) for some j), we have yj ∈ L(ρ(sj−1, q∗)ρ(q∗, q∗)uρ(q∗, sj))
where u = σ(j) − σ(j − 1) − 2. Therefore we can write yj = x` · · ·xσ(j), where ` = σ(j − 1) + 1,
such that x` ∈ L(ρ(sj−1, q∗)), xσ(j) ∈ L(ρ(q∗, sj)) and x`+1, . . . , xσ(j)−1 ∈ L(ρ(q∗, q∗)). Verify that
all xi (i = 1, . . . , t) are well-defined by this.
With these definitions it can be easily verified that x0 · · ·xt = y0 · · · yd = w and xi ∈ L(ρ(ri−1, ri)).
DFA to Regex: Summary
Lemma 7. For every DFA M , there is a regular expression R such that L(M) = L(R).
• Any DFA can be converted into an equivalent GNFA. So let G be a GNFA s.t. L(M) = L(G).
• For any GNFA G = (Q,Σ, q0, qF , ρ) with |Q| > 2, for any q∗ ∈ Q \ {q0, qF }, G and rip(G, q∗)
are equivalent. rip(G, q∗) has one fewer state than G.
• So given G, by applying rip repeatedly (choosing q∗ arbitrarily each time), we can get a GNFA
G′ with two states s.t. L(G) = L(G′). Formally, by induction on the number of states in G.
• For a 2-state GNFA G′, L(G′) = L(R), where R = ρ(q0, qF ).
13
DFA to Regex: Example
q1 q2
0 0
1
1
Figure 9: Example DFA D
q1 q2
q0 qF
0 0
1
1
 
Figure 10: GNFA G equivalent to D, ignoring transitions labelled ∅
14
q2
q0 qF
0 ∪ (10∗1)
0∗1 
Figure 11: Ripping q1
q0 qF
0∗1(0 ∪ (10∗1))∗
Figure 12: Ripping q2
15
