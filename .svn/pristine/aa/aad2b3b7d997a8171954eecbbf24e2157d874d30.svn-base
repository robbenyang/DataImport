1 Equivalence of Finite Automata and Regular Expressions
Finite Automata Recognize Regular Languages
Theorem 1. L is a regular language iff there is a regular expression R such that L(R) = L iff
there is a DFA M such that L(M) = L iff there is a NFA N such that L(N) = L.
i.e., regular expressions, DFAs and NFAs have the same computational power.
Proof. â€¢ Given regular expression R, will construct NFA N such that L(N) = L(R)
â€¢ Given DFA M , will construct regular expression R such that L(M) = L(R)
2 Regular Expressions to NFA
Regular Expressions to Finite Automata
. . . to Non-determinstic Finite Automata
Lemma 2. For any regex R, there is an NFA NR s.t. L(NR) = L(R).
Proof Idea
We will build the NFA NR for R, inductively, based on the number of operators in R, #(R).
â€¢ Base Case: #(R) = 0 means that R is âˆ…, , or a (from some a âˆˆ Î£). We will build NFAs for
these cases.
â€¢ Induction Hypothesis: Assume that for regular expressions R, with #(R) < n, there is an
NFA NR s.t. L(NR) = L(R).
â€¢ Induction Step: Consider R with #(R) = n. Based on the form of R, the NFA NR will be
built using the induction hypothesis.
Regular Expression to NFA
Base Cases
If R is an elementary regular expression, NFA NR is constructed as follows.
R = âˆ…
q0
R = 
q0
R = a
q0 q1
a
1
Induction Step: Union
Case R = R1 âˆªR2
By induction hypothesis, there are N1, N2 s.t. L(N1) = L(R1) and L(N2) = L(R2). Build NFA N
s.t. L(N) = L(N1) âˆª L(N2)
q0
q1
q11
q12
q2 q21


Figure 1: NFA for L(N1) âˆª L(N2)
Induction Step: Union
Formal Definition
Case R = R1 âˆªR2
Let N1 = (Q1,Î£, Î´1, q1, F1) and N2 = (Q2,Î£, Î´2, q2, F2) (with Q1 âˆ©Q2 = âˆ…) be such that L(N1) =
L(R1) and L(N2) = L(R2). The NFA N = (Q,Î£, Î´, q0, F ) is given by
â€¢ Q = Q1 âˆªQ2 âˆª {q0}, where q0 6âˆˆ Q1 âˆªQ2
â€¢ F = F1 âˆª F2
â€¢ Î´ is defined as follows
Î´(q, a) =
ï£±ï£´ï£´ï£²ï£´ï£´ï£³
Î´1(q, a) if q âˆˆ Q1
Î´2(q, a) if q âˆˆ Q2
{q1, q2} if q = q0 and a = 
âˆ… otherwise
Induction Step: Union
Correctness Proof
Need to show that w âˆˆ L(N) iff w âˆˆ L(N1) âˆª L(N2).
â‡’ w âˆˆ L(N) implies q0 wâˆ’â†’N q for some q âˆˆ F . Based on the transitions out of q0, q0 âˆ’â†’N
q1
wâˆ’â†’N q or q0 âˆ’â†’N q2 wâˆ’â†’N q. Consider q0 âˆ’â†’N q1 wâˆ’â†’N q. (Other case is similar) This
means q1
wâˆ’â†’N1 q (as N has the same transition as N1 on the states in Q1) and q âˆˆ F1. This
means w âˆˆ L(N1).
2
â‡ w âˆˆ L(N1)âˆªL(N2). Consider w âˆˆ L(N1); case of w âˆˆ L(N2) is similar. Then, q1 wâˆ’â†’N1 q for
some q âˆˆ F1. Thus, q0 âˆ’â†’N q1 wâˆ’â†’N q, and q âˆˆ F . This means that w âˆˆ L(N).
Induction Step: Concatenation
Case R = R1 â—¦R2
â€¢ By induction hypothesis, there are N1, N2 s.t. L(N1) = L(R1) and L(N2) = L(R2)
â€¢ Build NFA N s.t. L(N) = L(N1) â—¦ L(N2)
q1
q11
q12
q2 q21


Figure 2: NFA for L(N1) â—¦ L(N2)
Induction Step: Concatenation
Formal Definition
Case R = R1 â—¦R2
Let N1 = (Q1,Î£, Î´1, q1, F1) and N2 = (Q2,Î£, Î´2, q2, F2) (with Q1 âˆ©Q2 = âˆ…) be such that L(N1) =
L(R1) and L(N2) = L(R2). The NFA N = (Q,Î£, Î´, q0, F ) is given by
â€¢ Q = Q1 âˆªQ2
â€¢ q0 = q1
â€¢ F = F2
â€¢ Î´ is defined as follows
Î´(q, a) =
ï£±ï£´ï£´ï£²ï£´ï£´ï£³
Î´1(q, a) if q âˆˆ (Q1 \ F1) or a 6= 
Î´1(q, a) âˆª {q2} if q âˆˆ F1 and a = 
Î´2(q, a) if q âˆˆ Q2
âˆ… otherwise
Induction Step: Concatenation
Correctness Proof
Need to show that w âˆˆ L(N) iff w âˆˆ L(N1) â—¦ L(N2).
3
w âˆˆ L(N) iff q0 wâˆ’â†’N q for some q âˆˆ F = F2. The computation of N on w starts in a state of
N1 (namely, q0 = q1) and ends in a state of N2 (namely, q âˆˆ F2). The only transitions from a state
of N1 to a state of N2 is from a state in F1 which have -transitions to q2, the initial state of N2.
Thus, we have
q0 = q1
wâˆ’â†’N q with q âˆˆ F = F2
iff
âˆƒqâ€² âˆˆ F1. âˆƒu, v âˆˆ Î£âˆ—. w = uv and q0 = q1 uâˆ’â†’N qâ€² âˆ’â†’N q2 vâˆ’â†’N q
This means that q1
uâˆ’â†’N1 qâ€² (with qâ€² âˆˆ F1) and q2 vâˆ’â†’N2 q (with q âˆˆ F2). Hence, u âˆˆ L(N1) and
v âˆˆ L(N2), and so w = uv âˆˆ L(N1)â—¦L(N2). Conversely, if u âˆˆ L(N1) and v âˆˆ L(N2) then for some
qâ€² âˆˆ F1 and q âˆˆ F2, we have q1 uâˆ’â†’N1 qâ€² and q2 vâˆ’â†’N2 q. Then,
q0 = q1
uâˆ’â†’N qâ€² âˆ’â†’N q2 vâˆ’â†’N q
Thus, q0
w=uvâˆ’â†’ N q and so uv âˆˆ L(N).
Induction Step: Kleene Closure
First Attempt
Case R = Râˆ—1
â€¢ By induction hypothesis, there is N1 s.t. L(N1) = L(R1)
â€¢ Build NFA N s.t. L(N) = (L(N1))âˆ—
q0
q1
q2


Figure 3: NFA accepts (L(N1))
+
Problem: May not accept ! One can show that L(N) = (L(N1))
+.
Induction Step: Kleene Closure
Second Attempt
Case R = Râˆ—1
â€¢ By induction hypothesis, there is N1 s.t. L(N1) = L(R1)
â€¢ Build NFA N s.t. L(N) = (L(N1))âˆ—
4
q0
q1
q2


Figure 4: NFA accepts âŠ‡ (L(N1))âˆ—
Problem: May accept strings that are not in (L(N1))
âˆ—!
Example demonstrating the problem
q0 q1
0, 1
1
0, 1
Figure 5: Example NFA N
q0 q1
0, 1
1

0, 1
Figure 6: Incorrect Kleene Closure of N
L(N) = (0 âˆª 1)âˆ—1(0 âˆª 1)âˆ—. Thus, (L(N))âˆ— =  âˆª (0 âˆª 1)âˆ—1(0 âˆª 1)âˆ—. The previous construction, gives
an NFA that accepts 0 6âˆˆ (L(N))âˆ—!
Induction Step: Kleene Closure
Correct Construction
Case R = Râˆ—1
â€¢ First build N1 s.t. L(N1) = L(R1)
â€¢ Given N1 build NFA N s.t. L(N) = L(N1)âˆ—
5
q q0
q1
q2



Figure 7: NFA for L(N1)
âˆ—
Induction Step: Kleene Closure
Formal Definition
Case R = Râˆ—1
Let N1 = (Q1,Î£, Î´1, q1, F1) be such that L(N1) = L(R1). The NFA N = (Q,Î£, Î´, q0, F ) is given by
â€¢ Q = Q1 âˆª {q0} with q0 6âˆˆ Q1
â€¢ F = F1 âˆª {q0}
â€¢ Î´ is defined as follows
Î´(q, a) =
ï£±ï£´ï£´ï£²ï£´ï£´ï£³
Î´1(q, a) if q âˆˆ (Q1 \ F1) or a 6= 
Î´1(q, a) âˆª {q1} if q âˆˆ F1 and a = 
{q1} if q = q0 and a = 
âˆ… otherwise
Induction Step: Kleene Closure
Correctness Proof
Let us begin by stating what our goal is. We would like to show w âˆˆ L(N) iff w âˆˆ Lâˆ—. If we choose
to prove this statement by induction, most induction proofs will fail because this statement is too
weak to be established by induction. How we choose to strengthen it depends on what parameter
we will choose to induct over. One possibility is |w|. If we do induction on the length of w, then
we need to strengthen the statement by saying which strings are accepted from any state q âˆˆ Q,
and not just the initial state q0 as in the above statement. We can carry such a proof out, but it is
long. We instead present a proof that does induction over a parameter different than length of w,
but before presenting this proof we need to introduce some notation and terminology that we will
find convenient.
Observe that we construct N from N1 by adding some -transitions: one from q0 to q1, and
others from q âˆˆ F1 to q1. We will call these â€œnewâ€ transitions. Recall that an accepting computation
is a sequence of steps starting from the initial state q0 and ending in some accept state, such that
every step conforms to the transition relation. Let us call a computation Ï as having n new steps,
if exactly n steps in Ï are according to the new -transitions. For any n, let us define
An = {w âˆˆ Î£âˆ— | w has an accepting computation where exactly n new transitions are used}
6
Observe that if w has an accepting computation then w âˆˆ An for some n â‰¥ 0.
We will prove by induction on n, the following statement
âˆ€n âˆˆ N. w âˆˆ An iff w âˆˆ Ln
Before proving the above stronger statement by induction, let us see how proving the above state-
ment establishes the correctness of the construction. Suppose w âˆˆ Lâˆ— then (by definition of Kleene
closure) w âˆˆ Li for some i âˆˆ N. By the above statement, it would mean that w âˆˆ Ai. In other
words, w has an accepting computation that uses exactly i new transitions, which just implies that
N accepts w. On the other hand, suppose N accepts w. Since N has an accepting computation
on w, it must have an accepting computation that uses exactly i new transitions, for some value
of i. In other words, w âˆˆ Ai. By the above statement that means that w âˆˆ Li which implies that
w âˆˆ Lâˆ—. Thus we can establish both sides of the correctness claim.
Let us now prove by induction on n
âˆ€n âˆˆ N. w âˆˆ An iff w âˆˆ Ln
Base Case For this statement we need to establish two base cases: one when n = 0 and the other
when n = 1.
Case 1: Let n = 0. Since the only transition out of the initial state q0 is a new transition,
w âˆˆ A0 means that the computation takes no steps and stays in q0. If the computation on
w has no transition steps, it means that w =  and clearly w âˆˆ L0. On the other hand, if
w âˆˆ L0 then w =  and N accepts w by taking no steps as q0 âˆˆ F . Thus, we have established
the base case for n = 0.
Case 2: Let n = 1. Suppose w âˆˆ L, then N1 has an accepting computation. Thus, there
is q âˆˆ F1 such that q1 wâˆ’â†’N1 q. Observe that since every transition of N1 is a transition of
N (which is not new), and F1 âŠ† F we have the following accepting computation of N with
exactly one new transition
q0
âˆ’â†’N q1 wâˆ’â†’N1 q
Thus w âˆˆ A1. Conversely, suppose w âˆˆ A1. Again, the only transition out of q0 is a new
transition. Thus the accepting computation of N on w must be of the form
q0
âˆ’â†’N q1 wâˆ’â†’N1 q
for some q âˆˆ F1; the reason that q must be in F1 is because q0 (the only other accept state)
has no incoming transitions. Thus, q1
wâˆ’â†’N1 q for q âˆˆ F1, which means that w is accepted
by N1, and from the fact that L(N1) = L, we can conclude that w âˆˆ L = L1. We have,
therefore, established the base case for n = 1.
Ind. Hyp. Assume that for all i < n, w âˆˆ Ai iff w âˆˆ Li, where n > 1.
Ind. Step Suppose w âˆˆ Ln. Then there are u, v such that w = uv, u âˆˆ Lnâˆ’1 and v âˆˆ L. By
induction hypothesis, we have u âˆˆ Anâˆ’1. Now, since n > 1, the accepting computation on u
must end in a state q âˆˆ F1 (because once you leave q0 you can never get back to it). Moreover
since v âˆˆ L, from the correctness of N1, we have q1 vâˆ’â†’N1 qâ€² for some qâ€² âˆˆ F1. Putting all of
this together we have the following accepting computation
q0
uâˆ’â†’N q âˆ’â†’N q1 vâˆ’â†’N1 qâ€²
7
which has exactly n new transitions. Thus, w âˆˆ An. To prove the converse, suppose w âˆˆ An.
Since n > 1, the accepting computation on w must be of the form
q0
uâˆ’â†’N q âˆ’â†’N q1 vâˆ’â†’N1 qâ€²
where w = uv, and q and qâ€² are some states in F1. Thus, u âˆˆ Anâˆ’1. By induction hypothesis,
we have u âˆˆ Lnâˆ’1. From the correctness of N1, q1 vâˆ’â†’N1 qâ€² for qâ€² âˆˆ F1 means that v âˆˆ L.
Putting this together, we get that w = uv âˆˆ (Lnâˆ’1)L = Ln.
Regular Expressions to NFA
To Summarize
We built an NFA NR for each regular expression R inductively
â€¢ When R was an elementary regular expression, we gave an explicit construction of an NFA
recognizing L(R)
â€¢ When R = R1 op R2 (or R = op(R1)), we constructed an NFA N for R, using the NFAs for
R1 and R2.
Regular Expressions to NFA
An Example
Build NFA for (1 âˆª 01)âˆ—
N0
0
N1
1
N01
0  1
N1âˆª01
1
0  1


N(1âˆª01)âˆ—
1
0  1





3 DFAs to Regular Expressions
DFA to Regular Expression
8
â€¢ Given DFA M , will construct regular expression R such that L(M) = L(R). In two steps:
â€“ Construct a â€œGeneralized NFAâ€ (GNFA) G from the DFA M
â€“ And then convert G to a regex R
3.1 Generalized NFA
Generalized NFA
â€¢ A GNFA is similar to an NFA, but:
â€“ There is a single accept state which is not the start state.
â€“ The start state has no incoming transitions, and the accept state has no outgoing tran-
sitions.
âˆ— These are â€œcosmetic changesâ€: Any NFA can be converted to an equivalent NFA of
this kind.
â€“ The transitions are labeled not by characters in the alphabet, but by regular expressions.
âˆ— For every pair of states (q1, q2), the transition from q1 to q2 is labeled by a regular
expression Ï(q1, q2).
â€“ â€œGeneralized NFAâ€ because a normal NFA has transitions labeled by , elements in Î£
(a union of elements, if multiple edges between a pair of states) and âˆ… (missing edges).
Generalized NFA
â€¢ Transition: GNFA non-deterministically reads a block of characters from the input, chooses
an edge from the current state q1 to another state q2, and if the block of symbols matches
the regex Ï(q1, q2), then moves to q2.
â€¢ Acceptance: G accepts w if there exists some sequence of valid transitions such that on
starting from the start state, and after finishing the entire input, G is in the accept state.
Generalized NFA: Example
9
q0
q1
q2
0âˆ—10âˆ— 0âˆ—
0âˆ—
10âˆ—10âˆ—
Figure 8: Example GNFA G
Accepting run of G on 11110100 is q0
1âˆ’â†’G q1 11âˆ’â†’G q1 101âˆ’â†’G q1 00âˆ’â†’G q2
Generalized NFA: Definition
Definition 3. A generalized nondeterministic finite automaton (GNFA) is G = (Q,Î£, q0, qF , Ï),
where
â€¢ Q is the finite set of states
â€¢ Î£ is the finite alphabet
â€¢ q0 âˆˆ Q initial state
â€¢ qF âˆˆ (Q \ {q0}, a single accepting state
â€¢ Ï : (Q \ {qF }) Ã— (Q \ {q0}) â†’ RÎ£, where RÎ£ is the set of all regular expressions over the
alphabet Î£
Generalized NFA: Definition
Definition 4. For a GNFA M = (Q,Î£, q0, qF , Ï) and string w âˆˆ Î£âˆ—, we say M accepts w iff there
exist x1, . . . , xt âˆˆ Î£âˆ— and states r0, . . . , rt such that
â€¢ w = x1x2x3 Â· Â· Â·xt
â€¢ r0 = q0 and rt = qF
â€¢ for each i âˆˆ [1, t], xi âˆˆ L(Ï(riâˆ’1, ri)),
10
3.2 Converting DFA to GNFA
Converting DFA to GNFA
A DFA M = (Q,Î£, Î´, q0, F ) can be easily converted to an equivalent GNFA G = (Q
â€²,Î£, qâ€²0, qâ€²F , Ï):
â€¢ Qâ€² = Q âˆª {qâ€²0, qâ€²F } where Q âˆ© {qâ€²0, qâ€²F } = âˆ…
â€¢ Ï(q1, q2) =
ï£±ï£´ï£²ï£´ï£³
, if q1 = q
â€²
0 and q2 = q0
, if q1 âˆˆ F and q2 = qâ€²Fâ‹ƒ
{a|Î´(q1,a)=q2} a otherwise
qâ€²0 q
â€²
F
q0
q1
q2



Prove: L(G) = L(M).
3.3 Converting GNFA to Regular Expression
GNFA to Regex
â€¢ Suppose G is a GNFA with only two states, q0 and qF .
â€¢ Then L(R) = L(G) where R = Ï(q0, qF ).
â€¢ How about G with three states?
q0
q1
qF
R4
R1 R3
R2
q0 qF
(R4) âˆª (R1Râˆ—2R3)
11
â€¢ Plan: Reduce any GNFA G with k > 2 states to an equivalent GFA with k âˆ’ 1 states.
GNFA to Regex: From k states to k âˆ’ 1 states
Definition 5 (Deleting a GNFA State). Given GNFA G = (Q,Î£, q0, qF , Ï) with |Q| > 2, and any
state qâˆ— âˆˆ Q \ {q0, qF }, define GNFA rip(G, qâˆ—) = (Qâ€²,Î£, q0, qF , Ïâ€²) as follows:
â€¢ Qâ€² = Q \ {qâˆ—}.
â€¢ For any (q1, q2) âˆˆ Qâ€² \ {qF } Ã—Qâ€² \ {q0} (possibly q1 = q2), let
Ïâ€²(q1, q2) = (R1Râˆ—2R3) âˆªR4,
where R1 = Ï(q1, q
âˆ—), R2 = Ï(qâˆ—, qâˆ—), R3 = Ï(qâˆ—, q2) and R4 = Ï(q1, q2).
GNFA to Regex: From k states to k âˆ’ 1 states
Correctness
Proposition 6. For any qâˆ— âˆˆ Q \ {q0, qF }, G and rip(G, qâˆ—) are equivalent.
Proof. Let Gâ€² = rip(G, qâˆ—). We need to show that L(G) = L(Gâ€²). We will prove this in two steps:
we will show L(G) âŠ† L(Gâ€²) and then show L(Gâ€²) âŠ† L(G).
L(G) âŠ† L(Gâ€²): First we show w âˆˆ L(G) =â‡’ w âˆˆ L(Gâ€²). w âˆˆ L(G) =â‡’ âˆƒq0 = r0, r1, . . . , rt = qF
and x1, . . . , xt âˆˆ Î£âˆ— such that w = x1x2x3 Â· Â· Â·xt and for each i, xi âˆˆ L(Ï(riâˆ’1, ri)).
We need to show y1, . . . , yd âˆˆ Î£âˆ— and q0 = s0, s1, . . . , sd = qF such that w = y1 Â· Â· Â· yd, and for
each i, yi âˆˆ L(Ïâ€²(siâˆ’1, si)).
Define (s0 = q0, . . . , sd = qF ) to be the sequence obtained by deleting all occurrences of q
âˆ— from
(r0 = q0, r1, . . . , rt = qF ).
To formally define yj , first we define Ïƒ as follows:
Ïƒ(j) =
ï£±ï£´ï£²ï£´ï£³
0 if j = 0
i if 0 < Ïƒ(j âˆ’ 1) < t, where i = mini>Ïƒ(jâˆ’1) (ri 6= qâˆ—)
undefined otherwise.
The range of Ïƒ is the set of indices i such that ri 6= qâˆ—. Let d = mink(Ïƒ(k) = t). Then, sj = rÏƒ(j),
for j = 0, . . . , d.
Now we define yj = xÏƒ(jâˆ’1)+1 Â· Â· Â·xÏƒ(j) for j = 1, . . . , d
Then y1 Â· Â· Â· yd = x1 Â· Â· Â·xt = w.
We need to show that yj âˆˆ L(Ïâ€²(sjâˆ’1, sj)) for all j. We consider the following cases for j:
â€¢ Ïƒ(j) = Ïƒ(j âˆ’ 1) + 1 (i.e., rÏƒ(jâˆ’1)+1 6= qâˆ—). Then yj = xi and sjâˆ’1 = riâˆ’1 and sj = ri, where
i = Ïƒ(j). yj = xi âˆˆ L(Ï(riâˆ’1, ri)) âŠ† L(Ïâ€²(riâˆ’1, ri)) = L(Ïâ€²(sjâˆ’1, sj)).
12
â€¢ Ïƒ(j) > Ïƒ(j âˆ’ 1) + 1 (i.e., rÏƒ(jâˆ’1)+1 = qâˆ—). Then yj = x` Â· Â· Â·xi and sjâˆ’1 = r`âˆ’1 and sj = ri,
where ` = Ïƒ(j âˆ’ 1) + 1 and i = Ïƒ(j).
yj = x` Â· Â· Â·xi âˆˆ L(Ï(r`âˆ’1, r`)Ï(r`, r`+1) Â· Â· Â· Ï(riâˆ’1, ri)Ï(ri, ri+1))
= L(Ï(r`âˆ’1, qâˆ—)Ï(qâˆ—, qâˆ—)iâˆ’`Ï(qâˆ—, ri))
âŠ† L(Ï(r`âˆ’1, r`)Ï(qâˆ—, qâˆ—)âˆ—Ï(qâˆ—, ri))
âŠ† L(Ï(sjâˆ’1, qâˆ—)Ï(qâˆ—, qâˆ—)âˆ—Ï(qâˆ—, sj))
âŠ† L(Ïâ€²(sjâˆ’1, sj))
Thus w âˆˆ L(Gâ€²) as we set out to prove.
L(Gâ€²) âŠ† L(G): Next we need to show that w âˆˆ L(Gâ€²) =â‡’ w âˆˆ L(G). w âˆˆ L(Gâ€²) =â‡’
âˆƒq0 = s0, s1, . . . , sd = qF and y1, . . . , yd âˆˆ Î£âˆ— such that w = y1y2y3 Â· Â· Â· yd and for each j, yj âˆˆ
L(Ïâ€²(sjâˆ’1, sj)) = L ((Ï(sjâˆ’1, qâˆ—)Ï(qâˆ—, qâˆ—)âˆ—Ï(qâˆ—, ri)) âˆª Ï(sjâˆ’1, sj))
Define Ïƒ as follows, for j = 0, . . . , d:
Ïƒ(j) =
ï£±ï£´ï£²ï£´ï£³
0 if j = 0,
Ïƒ(j âˆ’ 1) + 1 if yj âˆˆ L(Ï(sjâˆ’1, sj))
Ïƒ(j âˆ’ 1) + u+ 2 otherwise, where u = minv (yj âˆˆ L(Ï(sjâˆ’1, qâˆ—)Ï(qâˆ—, qâˆ—)vÏ(qâˆ—, sj)))
Let t = Ïƒ(d). For i = 0, . . . , t define ri as follows:
r(i) =
{
sj if there exists j such thati = Ïƒ(j),
qâˆ— otherwise.
Finally, define xi (i = 1, . . . , t) as follows: if i = Ïƒ(j) and i âˆ’ 1 = Ïƒ(j âˆ’ 1), then let xi = yj .
For other i (Ïƒ(j âˆ’ 1) < iâˆ’ 1 < i â‰¤ Ïƒ(j) for some j), we have yj âˆˆ L(Ï(sjâˆ’1, qâˆ—)Ï(qâˆ—, qâˆ—)uÏ(qâˆ—, sj))
where u = Ïƒ(j) âˆ’ Ïƒ(j âˆ’ 1) âˆ’ 2. Therefore we can write yj = x` Â· Â· Â·xÏƒ(j), where ` = Ïƒ(j âˆ’ 1) + 1,
such that x` âˆˆ L(Ï(sjâˆ’1, qâˆ—)), xÏƒ(j) âˆˆ L(Ï(qâˆ—, sj)) and x`+1, . . . , xÏƒ(j)âˆ’1 âˆˆ L(Ï(qâˆ—, qâˆ—)). Verify that
all xi (i = 1, . . . , t) are well-defined by this.
With these definitions it can be easily verified that x0 Â· Â· Â·xt = y0 Â· Â· Â· yd = w and xi âˆˆ L(Ï(riâˆ’1, ri)).
DFA to Regex: Summary
Lemma 7. For every DFA M , there is a regular expression R such that L(M) = L(R).
â€¢ Any DFA can be converted into an equivalent GNFA. So let G be a GNFA s.t. L(M) = L(G).
â€¢ For any GNFA G = (Q,Î£, q0, qF , Ï) with |Q| > 2, for any qâˆ— âˆˆ Q \ {q0, qF }, G and rip(G, qâˆ—)
are equivalent. rip(G, qâˆ—) has one fewer state than G.
â€¢ So given G, by applying rip repeatedly (choosing qâˆ— arbitrarily each time), we can get a GNFA
Gâ€² with two states s.t. L(G) = L(Gâ€²). Formally, by induction on the number of states in G.
â€¢ For a 2-state GNFA Gâ€², L(Gâ€²) = L(R), where R = Ï(q0, qF ).
13
DFA to Regex: Example
q1 q2
0 0
1
1
Figure 9: Example DFA D
q1 q2
q0 qF
0 0
1
1
 
Figure 10: GNFA G equivalent to D, ignoring transitions labelled âˆ…
14
q2
q0 qF
0 âˆª (10âˆ—1)
0âˆ—1 
Figure 11: Ripping q1
q0 qF
0âˆ—1(0 âˆª (10âˆ—1))âˆ—
Figure 12: Ripping q2
15
