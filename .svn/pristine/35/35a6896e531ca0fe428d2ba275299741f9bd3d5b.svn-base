MP7 available, due 12/10, 11:59p.
Student Projects Expo - Siebel 0216, 12/11, 7p.
Code Challenge #4 - Siebel 0224, 12/11, 9p.
Final exam - 12/16, 7-10p, Locations TBA
 
How would you characterize the difference between these graphs?
Today’s announcements:
MST - minimum total weight spanning tree
Input:
Output:
Prim’s algorithms (1957) 
is based on the Partition 
Property:
Consider a partition of the vertices 
of G into subsets U and V.
Let e be an edge of minimum 
weight across the partition.
Then e is part of some minimum 
spanning tree.
Proof:
See cs473
U V
6
4
2 8
5
7
3
9
8
e
7
4
2 8
5
7
3
9
8 e
f
U V
MST - minimum total weight spanning tree
Theorem suggests an algorithm...
5
34
5
4
4
4
4
4
4
3 3
3
3
3
3
2
2
2
2
Example of Prim’s algorithm - 
B
D
C
A
F
E
7
4
2
8
5
7
3
9
8
Initialize structure:
1. For all v, d[v] = “infinity”, p[v] = null
2. Initialize source: d[s] = 0
3. Initialize priority (min) queue
4. Initialize set of labeled vertices to ∅.
Example of Prim’s algorithm - 
B
D
C
A
F
E
7
4
2
8
5
7
3
9
8
Initialize structure:
1. For all v, d[v] = “infinity”, p[v] = null
2. Initialize source: d[s] = 0
3. Initialize priority (min) queue
4. Initialize set of labeled vertices to ∅.
Repeat these steps n times:
• Find & remove minimum d[] unlabelled 
vertex: v
• Label vertex v
• For all unlabelled neighbors w of v, 
If cost(v,w) < d[w]
d[w] = cost(v,w) 
p[w] = v
Prim’s Algorithm (undirected graph with unconstrained edge weights):
Initialize structure:
1. For all v, d[v] = “infinity”, p[v] = null
2. Initialize source: d[s] = 0
3. Initialize priority (min) queue
4. Initialize set of labeled vertices to ∅.
Repeat these steps n times:
• Remove minimum d[] unlabeled 
vertex: v
• Label vertex v (set a flag)
• For all unlabeled neighbors w of v, 
If cost(v,w) < d[w]
d[w] = cost(v,w) 
p[w] = v
adj mtx adj list
heap
Unsorted 
array
Prim’s Algorithm (undirected graph with unconstrained edge weights):
Initialize structure:
1. For all v, d[v] = “infinity”, p[v] = null
2. Initialize source: d[s] = 0
3. Initialize priority (min) queue
4. Initialize set of labeled vertices to ∅.
Repeat these steps n times:
• Remove minimum d[] unlabeled 
vertex: v
• Label vertex v (set a flag)
• For all unlabeled neighbors w of v, 
If cost(v,w) < d[w]
d[w] = cost(v,w) 
p[w] = v
Which is best?
Depends on density of the graph:
Sparse
Dense
adj mtx adj list
heap O(n2 + m log n) O(n log n + m log n)
Unsorted 
array O(n
2) O(n2)
