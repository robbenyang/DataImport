1 
MIPS	  Load	  &	  Stores	  
2 
Today’s	  lecture	  
  MIPS	  Load	  &	  Stores	  
  Data	  Memory	  
  Load	  and	  Store	  Instruc3ons	  
  Encoding	  
  How	  are	  they	  implemented?	  
3 
We need more space!  
  Registers are fast and convenient, but we have only 32 of 
them, and each one is just 32-bits wide. 
  That’s not enough to hold data structures like large arrays. 
  We also can’t access data elements that are wider than 32 bits. 
  We need to add some main memory to the system! 
  RAM is cheaper and denser than registers, so we can add lots of it. 
  But memory can be significantly slower, so registers should be 
used whenever possible. 
4 
Harvard Architecture 
 
  It’s easier to use a Harvard architecture at first, with 
programs and data stored in separate memories: 
  Instruction memory: 
  Contains instructions to execute 
  It is read-only 
  Data memory: 
  Contains the data of the program 
  Can be read/written 
5 
MIPS memory 
 
  MIPS memory is byte-addressable, which means that each 
memory address references an 8-bit quantity. 
  Our MIPS architecture can support up to 32-bit addresses. 
  This results in a 232 x 8 RAM, which would be 4 GB of 
memory. 
6 
Data Memory 
  ADDR specifies the memory location to access 
  To write to the memory, 
  when word_we=1, the 32 bits in DATA_IN are stored in ADDR  
  (in this case, bits ADDR[1:0] must be zero) 
  when byte_we =1, DATA[0:7] bits are stored in ADDR.  
  To read the memory,  
  word_we=0 and byte_we=0. DATA_OUT are the 32 bits stored in ADDR. 
word_we byte_we Operation 
0 0 Read 
0 1 Write byte in ADDR 
1 0 Write word in ADDR  
  
   
 
 
 
 
 
 
 
 
32 
32 
32 
word_we	  
DATA_IN	  
ADDR	  
DATA_OUT	  
byte_we	  
clk	  
reset	   reset	  
7 
Loading and storing words 
  The MIPS instruction set includes load and store instructions 
for accessing memory. 
  MIPS uses indexed addressing. 
  The address operand specifies a signed constant and a register. 
  These values are added to generate the effective address. 
  The MIPS “load word” instruction lw transfers one word of 
data from the data memory to a register.  
  lw   $12, 4($3)   
  The “store word” instruction sw transfers one word of data 
from a register into main memory.  
  sw   $12, 4($3)   
8 
Example 
lw   $12, 0($3) 
$3 
$12 
…	  
Data Memory 
0x10010000 0x00 
0x11 
0x22 
0x33 
Register File 
0x10010000 
0x10010001 
0x10010002 
0x10010003 
9 
Example 
$3 
$12 
…	  
Data Memory 
0xAABBCCDD 
Register File 
sw   $12, 0($3) 
0x10010000 0x10010000 
0x10010001 
0x10010002 
0x10010003 
10 
Loading and storing bytes 
  The MIPS “load byte unsigned” instruction lbu transfers one 
byte of data from the data memory to a register and zero 
extends it.  
  lbu $12, 2($3)  
  The “store byte” instruction sb transfers one byte (the LSB) of 
data from a register into main memory.  
  sb $12, 2($3)  
11 
Example	  
lbu  $12, 2($3) 
$3 
$12 
…	  
Data Memory 
0xF1 
0xF2 
0xF3 
0xF4 
Register File 
0x10010000 
0x10010001 
0x10010002 
0x10010003 
0x10010000 
12 
Example	  
lb   $12, 2($3) 
$3 
$12 
…	  
Data Memory 
0xF1 
0xF2 
0xF3 
0xF4 
Register File 
0x10010000 
0x10010001 
0x10010002 
0x10010003 
0x10010000 
13 
Example	  
sb   $12, 3($3) 
$3 
$12 
…	  
Data Memory 
0xAABBCCDD 
Register File 
0x10010000 
0x10010001 
0x10010002 
0x10010003 
0x10010000 
14 
Memory	  alignment	  
  Keep in mind that memory is byte-addressable, so a 32-bit word actually  
occupies four contiguous locations (bytes) of main memory. 
  The MIPS architecture requires words to be aligned in memory; 32-bit words  
must start at an address that is divisible by 4. 
  0, 4, 8 and 12 are valid word addresses. 
  1, 2, 3, 5, 6, 7, 9, 10 and 11 are not valid word addresses. 
  Unaligned memory accesses result in a bus error, which you may have 
unfortunately seen before. 
  This restriction has relatively little effect on high-level languages and compilers, 
but it makes things easier and faster for the processor. 
0  1  2  3  4  5  6  7  8  9  10  11 
Word 1 Word 2 Word 3 
Address 
8-bit data 
15 
Example Program that Uses Memory 
int a = 10;!
int b = 0;!
void main() {!
   b = a+7;!
}!
!
16 
Example Program that Uses Memory 
 
 
.data 
a: .word 10 
b: .word 0 
 
 
int a = 10;!
int b = 0;!
void main() {!
   b = a+7;!
}!
!
17 
Example Program that Uses Memory 
 
 
.data 
a: .word 10 
b: .word 0 
.text 
main: 
    la   $4, a 
  
int a = 10;!
int b = 0;!
void main() {!
   b = a+7;!
}!
!
Data Memory 
0x10010000 
0x10010001 
0x10010002 
0x10010003 
0x10010004 
0x10010005 
0x10010006 
0x10010007 
18 
Example Program that Uses Memory 
 
 
.data 
a: .word 10 
b: .word 0 
.text 
main: 
    la   $4, a 
 …. 
int a = 10;!
int b = 0;!
void main() {!
   b = a+7;!
}!
!
Data Memory 
0x10010000 
0x10010001 
0x10010002 
0x10010003 
0x10010004 
0x10010005 
0x10010006 
0x10010007 
lw    $5, 0($4) 
addi $5, $5, 7 
sw    $5, 0($4) 
 
lw   $5, 0($4) 
addi $5, $5, 7 
sw    $5, 4($4) 
 
lw    $5, 4($4) 
addi $5, $5, 7 
sw    $5, 4($4) 
 
A	   B	   C	  
$4	  =	  0x10010000	  
19 
Example Program that Uses Memory 
Data Memory 
int a = 10;!
int b = 0;!
void main() {!
   b = a+7;!
}!
!
0x10010000 
0x10010001 
0x10010002 
0x10010003 
0x10010004 
0x10010005 
0x10010006 
0x10010007 
 
 
.data 
a: .word 10 
b: .word 0 
.text 
main: 
    la   $4, a 
 lw  $5, 0($4) 
 addi $5, $5, 7 
 sw  $5, 4($4) 
 
20 
Encoding of loads and stores 
  Loads and stores use the I-type format. 
 
  The meaning of the register fields depends on the exact instruction. 
—  rs is a source register—an address for loads and stores 
—  rt is the destination for load, but a source for store 
  The address is a 16-bit signed two’s-complement value. 
  It can range from -32,768 to +32,767 
op rs rt address 
6 bits 5 bits 5 bits 16 bits 
21 
Encoding of loads and stores 
op rs rt address 
op rs rt address 
 sw $5, 4($4) 
 lw $5, 4($4) 
22 
load	  word	  implemented	  
2 (Add)
32
alu_op[2:0]
write_enable
itype
except
opcode[5:0]
funct[5:0]
MIPS decoder
A[31:0]
alu_op[2:0]
out[31:0]
B[31:0]
ALU
rsDatarsNum
reset
rdNum
rtDatartNum
rdWriteEnable
rdData
Register File
reset
clk
wr_enable
Rdest
Rt
Rs
zero
negative
overflow
0
1
wr_enable
itype
itype
alu_op[2:0]
reset
enable
Q[31:0]
D[31:0]
PC Register
Sign 
Extender
out[31:0]
in[15:0]
data[31:0]
addr[29:0]
Instruction
Memory
4
inst[31:0]
PC[31:0]
ALU
1
nextPC[31:0]
0
1
itype
inst[25:21]
inst[20:16]
inst[15:11]
inst[20:16]
inst[5:0]
inst[15:0]
inst[31:26]
except
PC
[3
1:
2]
Rt
Rd
imm16
imm32
32
30
32
3
5
5
5
16
32
6
6
32
32
32
32
32
3
3
control_type
0 1 2 3
2 (Add)
ALU
3
Shift Left 2
out[31:0]
in[29:0]30 32
inst[25:21] 00 (for LSBs)
PC[31:28] (for MSBs)
branch
offset
branch
offset
32
control_type control_type
 lw $5, 4($4) 
Data	  Memory	  
Addr	  
Data_in	  
Data_out	  
word_we	  
byte_we	  
imm_val	  
23 
load	  byte	  implemented	  
2 (Add)
32
alu_op[2:0]
write_enable
itype
except
opcode[5:0]
funct[5:0]
MIPS decoder
A[31:0]
alu_op[2:0]
out[31:0]
B[31:0]
ALU
rsDatarsNum
reset
rdNum
rtDatartNum
rdWriteEnable
rdData
Register File
reset
clk
wr_enable
Rdest
Rt
Rs
zero
negative
overflow
0
1
wr_enable
itype
itype
alu_op[2:0]
reset
enable
Q[31:0]
D[31:0]
PC Register
Sign 
Extender
out[31:0]
in[15:0]
data[31:0]
addr[29:0]
Instruction
Memory
4
inst[31:0]
PC[31:0]
ALU
1
nextPC[31:0]
0
1
itype
inst[25:21]
inst[20:16]
inst[15:11]
inst[20:16]
inst[5:0]
inst[15:0]
inst[31:26]
except
PC
[3
1:
2]
Rt
Rd
imm16
imm32
32
30
32
3
5
5
5
16
32
6
6
32
32
32
32
32
3
3
control_type
0 1 2 3
2 (Add)
ALU
3
Shift Left 2
out[31:0]
in[29:0]30 32
inst[25:21] 00 (for LSBs)
PC[31:28] (for MSBs)
branch
offset
branch
offset
32
control_type control_type
 lbu $5, 4($4) 
Data	  Memory	  
Addr	  
Data_in	  
Data_out	  
word_we	  
byte_we	  
imm_val	  
24 
2 (Add)
32
alu_op[2:0]
write_enable
itype
except
opcode[5:0]
funct[5:0]
MIPS decoder
A[31:0]
alu_op[2:0]
out
[31:0]
B[31:0]
ALU
rsDatarsNum
reset
rdNum
rtDatartNum
rdWriteEnable
rdData
Register File
reset
clk
wr_enable
Rdest
Rt
Rs
zero
negative
overflow
0
1
wr_enable
itype
itype
alu_op[2:0]
reset
enable
Q[31:0]
D[31:0]
PC Register
Sign 
Extender
out[31:0]
in[15:0]
data[31:0]
addr[29:0]
Instruction
Memory
4
inst[31:0]
PC[31:0]
ALU
1
nextPC[31:0]
0
1
itype
inst[25:21]
inst[20:16]
inst[15:11]
inst[20:16]
inst[5:0]
inst[15:0]
inst[31:26]
except
PC
[3
1:
2]
Rt
Rd
imm16
imm32
32
30
32
3
5
5
5
16
32
6
6
32
32
32
32
32
3
3
out[1:0]
0123
control_type
0 1 2 3
2 (Add)
ALU
3
Shift Left 2
out[31:0]
in[29:0]30 32
inst[25:0]
00 (for LSBs)
PC[31:28] (for MSBs)
branch
offset
branch
offset
32
control_type control_type
0 1
slt
01lui
16
16'b0
data_out[31:0]
addr[31:0]
Data
Memory
31'b0
zero
0
1
mem_read
da
ta
_o
ut
[3
1:
24
]
da
ta
_o
ut
[2
3:
16
]
da
ta
_o
ut
[1
5:
8]
da
ta
_o
ut
[7
:0
]
24'b00
1
byte_load
8
lui lui
slt slt
byte_load byte_load
32
26
word_we word_we
byte_we byte_we
word_we
byte_we
data_in[31:0]
word_we
byte_we
reset
32
32
mem_read mem_read
mm_val	  
imm_val	  
imm_val	  
25 
imm_val	  
imm_val√	  
store	  implemented	  
2 (Add)
32
alu_op[2:0]
write_enable
itype
except
opcode[5:0]
funct[5:0]
MIPS decoder
A[31:0]
alu_op[2:0]
out[31:0]
B[31:0]
ALU
rsDatarsNum
reset
rdNum
rtDatartNum
rdWriteEnable
rdData
Register File
reset
clk
wr_enable
Rdest
Rt
Rs
zero
negative
overflow
0
1
wr_enable
itype
itype
alu_op[2:0]
reset
enable
Q[31:0]
D[31:0]
PC Register
Sign 
Extender
out[31:0]
in[15:0]
data[31:0]
addr[29:0]
Instruction
Memory
4
inst[31:0]
PC[31:0]
ALU
1
nextPC[31:0]
0
1
itype
inst[25:21]
inst[20:16]
inst[15:11]
inst[20:16]
inst[5:0]
inst[15:0]
inst[31:26]
except
PC
[3
1:
2]
Rt
Rd
imm16
imm32
32
30
32
3
5
5
5
16
32
6
6
32
32
32
32
32
3
3
control_type
0 1 2 3
2 (Add)
ALU
3
Shift Left 2
out[31:0]
in[29:0]30 32
inst[25:21] 00 (for LSBs)
PC[31:28] (for MSBs)
branch
offset
branch
offset
32
control_type control_type
 sw $5, 4($4) 
Data	  Memory	  
Addr	  
Data_in	  
Data_out	  
word_we	  
byte_we	  
imm_val	  
imm_val	  
imm_val	  
26 
Full	  Machine	  Datapath	  –	  Lab	  6	  
2 (Add)
32
alu_op[2:0]
write_enable
itype
except
opcode[5:0]
funct[5:0]
MIPS decoder
A[31:0]
alu_op[2:0]
out
[31:0]
B[31:0]
ALU
rsDatarsNum
reset
rdNum
rtDatartNum
rdWriteEnable
rdData
Register File
reset
clk
wr_enable
Rdest
Rt
Rs
zero
negative
overflow
0
1
wr_enable
itype
itype
alu_op[2:0]
reset
enable
Q[31:0]
D[31:0]
PC Register
Sign 
Extender
out[31:0]
in[15:0]
data[31:0]
addr[29:0]
Instruction
Memory
4
inst[31:0]
PC[31:0]
ALU
1
nextPC[31:0]
0
1
itype
inst[25:21]
inst[20:16]
inst[15:11]
inst[20:16]
inst[5:0]
inst[15:0]
inst[31:26]
except
PC
[3
1:
2]
Rt
Rd
imm16
imm32
32
30
32
3
5
5
5
16
32
6
6
32
32
32
32
32
3
3
out[1:0]
0123
control_type
0 1 2 3
2 (Add)
ALU
3
Shift Left 2
out[31:0]
in[29:0]30 32
inst[25:0]
00 (for LSBs)
PC[31:28] (for MSBs)
branch
offset
branch
offset
32
control_type control_type
0 1
slt
01lui
16
16'b0
data_out[31:0]
addr[31:0]
Data
Memory
31'b0
zero
0
1
mem_read
da
ta
_o
ut
[3
1:
24
]
da
ta
_o
ut
[2
3:
16
]
da
ta
_o
ut
[1
5:
8]
da
ta
_o
ut
[7
:0
]
24'b00
1
byte_load
8
lui lui
slt slt
byte_load byte_load
32
26
word_we word_we
byte_we byte_we
word_we
byte_we
data_in[31:0]
word_we
byte_we
reset
32
32
mem_read mem_read
imm_val	  
imm_val	  
imm_val	  
