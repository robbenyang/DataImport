10/24/13 1 
Programming Languages and 
Compilers (CS 421) 
Elsa L Gunter 
2112 SC, UIUC 
http://courses.engr.illinois.edu/cs421 
Based in part on slides by Mattox Beckman, as updated 
by Vikram Adve and Gul Agha 
10/24/13 2 
General Input 
{ header } 
let ident = regexp ... 
rule entrypoint [arg1... argn] = parse     
       regexp { action }  
    | ...  
    | regexp { action } 
and entrypoint [arg1... argn] =  
parse ...and ... 
{ trailer } 
10/24/13 3 
Ocamllex Input 
n  header and trailer contain arbitrary 
ocaml code put at top an bottom of 
<filename>.ml 
n  let ident = regexp ...  Introduces ident 
for use in later regular expressions 
10/24/13 4 
Ocamllex Input 
n  <filename>.ml contains one lexing 
function per entrypoint 
n  Name of function is name given for 
entrypoint 
n  Each entry point becomes an Ocaml 
function that takes n+1 arguments, the 
extra implicit last argument being of type 
Lexing.lexbuf 
n  arg1... argn are for use in action 
10/24/13 5 
Ocamllex Regular Expression 
n  Single quoted characters for letters: 
‘a’ 
n  _: (underscore) matches any letter 
n  Eof: special “end_of_file” marker 
n  Concatenation same as usual 
n  “string”: concatenation of sequence 
of characters 
n  e1 | e2 : choice - what was e1 ∨ e2 
10/24/13 6 
Ocamllex Regular Expression 
n  [c1 - c2]: choice of any character 
between first and second inclusive, as 
determined by character codes 
n  [^c1 - c2]: choice of any character NOT 
in set 
n  e*: same as before 
n  e+: same as e e* 
n  e?: option - was e1 ∨ ε 
10/24/13 7 
Ocamllex Regular Expression 
n  e1 # e2: the characters in e1 but not in 
e2; e1 and e2 must describe just sets of 
characters 
n  ident: abbreviation for earlier reg exp in 
let ident = regexp  
n   e1 as id: binds the result of e1 to id to 
be used in the associated action 
10/24/13 8 
Ocamllex Manual 
n  More details can be found at 
 
http://caml.inria.fr/pub/docs/manual-ocaml/
manual026.html 
10/24/13 9 
Example : test.mll 
{ type result = Int of int | Float of float | 
String of string } 
let digit = ['0'-'9'] 
let digits = digit + 
let lower_case = ['a'-'z'] 
let upper_case = ['A'-'Z'] 
let letter = upper_case | lower_case 
let letters = letter + 
10/24/13 10 
Example : test.mll 
rule main = parse 
   (digits)'.'digits as f  { Float (float_of_string f) } 
 | digits as n              { Int (int_of_string n) } 
 | letters as s             { String s} 
 | _ { main lexbuf } 
 { let newlexbuf = (Lexing.from_channel stdin) in 
 print_string "Ready to lex."; 
 print_newline (); 
 main newlexbuf  } 
10/24/13 11 
Example 
# #use "test.ml";; 
… 
val main : Lexing.lexbuf -> result = <fun> 
val __ocaml_lex_main_rec : Lexing.lexbuf -> int -> 
result = <fun> 
Ready to lex. 
hi there 234 5.2 
- : result = String "hi" 
What happened to the rest?!? 
10/24/13 12 
Example 
# let b = Lexing.from_channel stdin;; 
# main b;; 
hi 673 there 
- : result = String "hi" 
# main b;; 
- : result = Int 673 
# main b;; 
- : result = String "there" 
10/24/13 13 
Problem 
n  How to get lexer to look at more than the 
first token at one time? 
n  Answer: action has to tell it to -- recursive 
calls 
n  Side Benefit: can add “state” into lexing 
n  Note: already used this with the _ case 
10/24/13 14 
Example 
rule main = parse 
   (digits) '.' digits as f { Float 
(float_of_string f) :: main lexbuf} 
 | digits as n          { Int (int_of_string n) :: 
main lexbuf } 
 | letters as s         { String s :: main 
lexbuf} 
 | eof                     { [] } 
 | _                        { main lexbuf } 
10/24/13 15 
Example Results 
Ready to lex. 
hi there 234 5.2 
- : result list = [String "hi"; String "there"; Int 
234; Float 5.2] 
#  
 
Used Ctrl-d to send the end-of-file signal 
10/24/13 16 
Dealing with comments 
First Attempt 
let open_comment = "(*" 
let close_comment = "*)" 
rule main = parse 
   (digits) '.' digits as f { Float (float_of_string 
f) :: main lexbuf} 
 | digits as n          { Int (int_of_string n) :: 
main lexbuf } 
 | letters as s         { String s :: main lexbuf} 
10/24/13 17 
Dealing with comments 
 | open_comment         { comment  lexbuf} 
 | eof                  { [] } 
 | _ { main lexbuf } 
and comment = parse 
   close_comment       { main lexbuf } 
 | _                   { comment lexbuf } 
10/24/13 18 
Dealing with nested comments 
rule main = parse … 
 | open_comment         { comment 1 lexbuf} 
 | eof                  { [] } 
 | _ { main lexbuf } 
and comment depth = parse 
   open_comment        { comment (depth+1) 
lexbuf } 
 | close_comment       { if depth = 1 
                          then main lexbuf 
                         else comment (depth - 1) lexbuf } 
 | _                   { comment depth lexbuf } 
10/24/13 19 
Dealing with nested comments 
rule main = parse 
   (digits) '.' digits as f { Float (float_of_string f) :: 
main lexbuf} 
 | digits as n          { Int (int_of_string n) :: main 
lexbuf } 
 | letters as s         { String s :: main lexbuf} 
 | open_comment         { (comment 1 lexbuf} 
 | eof                  { [] } 
 | _ { main lexbuf } 
10/24/13 20 
Dealing with nested comments 
and comment depth = parse 
   open_comment        { comment (depth+1) lexbuf } 
 | close_comment       { if depth = 1 
                          then main lexbuf 
                         else comment (depth - 1) lexbuf } 
 | _                   { comment depth lexbuf } 
10/24/13 21 
Types of Formal Language Descriptions 
n  Regular expressions, regular grammars 
n  Context-free grammars, BNF grammars, 
syntax  diagrams 
n  Finite state automata 
n  Whole family more of grammars and 
automata – covered in automata theory 
10/24/13 22 
Sample Grammar 
n  Language: Parenthesized sums of 0’s and 
1’s 
 
n  <Sum> ::= 0  
n  <Sum >::= 1  
n  <Sum> ::= <Sum> + <Sum> 
n  <Sum> ::= (<Sum>) 
10/24/13 23 
BNF Grammars 
n  Start with a set of characters,   a,b,c,… 
n  We call these terminals 
n  Add a set of different characters, X,Y,Z,
… 
n  We call these nonterminals 
n  One special nonterminal S called start 
symbol 
10/24/13 24 
BNF Grammars 
n  BNF rules (aka productions) have form 
         X ::= y 
    where X is any nonterminal and y is a string 
of terminals and nonterminals 
n  BNF grammar is a set of BNF rules such that 
every nonterminal appears on the left of 
some rule 
10/24/13 25 
Sample Grammar 
n  Terminals: 0 1 + ( ) 
n  Nonterminals: <Sum> 
n  Start symbol = <Sum> 
n  <Sum> ::= 0  
n  <Sum >::= 1  
n  <Sum> ::= <Sum> + <Sum> 
n  <Sum> ::= (<Sum>) 
n  Can be abbreviated as 
 <Sum> ::= 0 | 1  
                | <Sum> + <Sum> | (<Sum>) 
10/24/13 26 
BNF Deriviations 
n  Given rules  
X::= yZw and Z::=v  
we may replace Z by v to say 
X => yZw => yvw  
n  Sequence of such replacements called 
derivation 
n  Derivation called right-most if always 
replace the right-most non-terminal 
10/24/13 27 
BNF Derivations 
n  Start with the start symbol: 
 
<Sum> => 
10/24/13 28 
BNF Derivations 
n  Pick a non-terminal 
<Sum> => 
10/24/13 29 
n  Pick a rule and substitute: 
n  <Sum> ::= <Sum> + <Sum> 
<Sum> => <Sum> + <Sum > 
BNF Derivations 
10/24/13 30 
n  Pick a non-terminal: 
 
<Sum> => <Sum> + <Sum > 
BNF Derivations 
10/24/13 31 
n  Pick a rule and substitute: 
n  <Sum> ::= ( <Sum> ) 
<Sum> => <Sum> + <Sum > 
            => ( <Sum> ) + <Sum> 
BNF Derivations 
10/24/13 32 
n  Pick a non-terminal: 
 
<Sum> => <Sum> + <Sum > 
            => ( <Sum> ) + <Sum> 
BNF Derivations 
10/24/13 33 
n  Pick a rule and substitute: 
n  <Sum> ::= <Sum> + <Sum> 
<Sum> => <Sum> + <Sum > 
            => ( <Sum> ) + <Sum> 
            => ( <Sum> + <Sum> ) + <Sum>  
BNF Derivations 
10/24/13 34 
n  Pick a non-terminal: 
 
<Sum> => <Sum> + <Sum > 
            => ( <Sum> ) + <Sum> 
            => ( <Sum> + <Sum> ) + <Sum>  
BNF Derivations 
10/24/13 35 
n  Pick a rule and substitute: 
n  <Sum >::= 1 
<Sum> => <Sum> + <Sum > 
            => ( <Sum> ) + <Sum> 
            => ( <Sum> + <Sum> ) + <Sum>  
            => ( <Sum> + 1 ) + <Sum> 
BNF Derivations 
10/24/13 36 
n  Pick a non-terminal: 
 
<Sum> => <Sum> + <Sum > 
            => ( <Sum> ) + <Sum> 
            => ( <Sum> + <Sum> ) + <Sum>  
            => ( <Sum> + 1 ) + <Sum> 
BNF Derivations 
10/24/13 37 
n  Pick a rule and substitute: 
n  <Sum >::= 0 
<Sum> => <Sum> + <Sum > 
            => ( <Sum> ) + <Sum> 
            => ( <Sum> + <Sum> ) + <Sum>  
            => ( <Sum> + 1 ) + <Sum> 
            => ( <Sum> + 1 ) + 0 
BNF Derivations 
10/24/13 38 
n  Pick a non-terminal: 
<Sum> => <Sum> + <Sum > 
            => ( <Sum> ) + <Sum> 
            => ( <Sum> + <Sum> ) + <Sum>  
            => ( <Sum> + 1 ) + <Sum> 
            => ( <Sum> + 1 ) + 0 
BNF Derivations 
10/24/13 39 
n  Pick a rule and substitute 
n  <Sum> ::= 0 
<Sum> => <Sum> + <Sum > 
            => ( <Sum> ) + <Sum> 
            => ( <Sum> + <Sum> ) + <Sum>  
            => ( <Sum> + 1 ) + <Sum> 
            => ( <Sum> + 1 ) 0 
            => ( 0 + 1 ) + 0 
BNF Derivations 
10/24/13 40 
n  ( 0 + 1 ) + 0  is generated by grammar 
<Sum> => <Sum> + <Sum > 
            => ( <Sum> ) + <Sum> 
            => ( <Sum> + <Sum> ) + <Sum>  
            => ( <Sum> + 1 ) + <Sum> 
            => ( <Sum> + 1 ) + 0 
            => ( 0 + 1 ) + 0 
BNF Derivations 
10/24/13 41 
<Sum> ::= 0 | 1 | <Sum> + <Sum> | (<Sum>) 
<Sum> => 
10/24/13 42 
BNF Semantics 
n  The meaning of a BNF grammar is the 
set of all strings consisting only of 
terminals that can be derived from the 
Start symbol 
10/24/13 43 
Regular Grammars 
n  Subclass of BNF 
n  Only rules of form 
<nonterminal>::=<terminal><nonterminal> or 
<nonterminal>::=<terminal> or 
<nonterminal>::=ε 
n  Defines same class of languages as regular 
expressions 
n  Important for writing lexers (programs that 
convert strings of characters into strings of 
tokens) 
10/24/13 44 
Example 
n  Regular grammar:  
<Balanced> ::= ε 
<Balanced> ::=  0<OneAndMore> 
<Balanced> ::= 1<ZeroAndMore> 
<OneAndMore> ::= 1<Balanced> 
<ZeroAndMore> ::= 0<Balanced> 
n  Generates even length strings where every 
initial substring of even length has same 
number of 0’s as 1’s 
10/24/13 45 
Extended BNF Grammars 
n  Alternatives: allow rules of from X::=y|z 
n  Abbreviates  X::= y, X::= z 
n  Options:  X::=y[v]z 
n  Abbreviates X::=yvz, X::=yz 
n  Repetition: X::=y{v}*z 
n  Can be eliminated by adding new 
nonterminal V and rules X::=yz, X::=yVz, 
V::=v, V::=vV 
10/24/13 46 
n  Graphical representation of derivation 
n  Each node labeled with either non-terminal 
or terminal 
n  If node is labeled with a terminal, then it is a 
leaf (no sub-trees) 
n  If node is labeled with a non-terminal, then 
it has one branch for each character in the 
right-hand side of rule used to substitute for 
it 
Parse Trees 
10/24/13 47 
Example 
n  Consider grammar: 
 <exp>  ::= <factor> 
               |  <factor> +  <factor> 
 <factor>  ::=  <bin>  
                 |  <bin>  *  <exp> 
 <bin> ::=  0  | 1 
n  Problem: Build parse tree for  1 * 1 + 0 as 
an <exp> 
10/24/13 48 
Example cont. 
n  1 * 1 + 0:    <exp> 
 
 
<exp> is the start symbol for this parse 
tree 
10/24/13 49 
Example cont. 
n  1 * 1 + 0:    <exp> 
 
                    <factor> 
 
Use rule: <exp> ::=  <factor> 
10/24/13 50 
Example cont. 
n  1 * 1 + 0:    <exp> 
 
                    <factor> 
 
           <bin>      *         <exp> 
 
Use rule:  <factor> ::=  <bin> *  <exp> 
10/24/13 51 
Example cont. 
n  1 * 1 + 0:    <exp> 
 
                    <factor> 
 
           <bin>      *         <exp> 
 
              1         <factor>  +    <factor> 
 
Use rules:  <bin> ::= 1   and 
                  <exp> ::= <factor>  + 
<factor> 
10/24/13 52 
Example cont. 
n  1 * 1 + 0:    <exp> 
 
                    <factor> 
 
           <bin>      *         <exp> 
 
              1         <factor>  +    <factor> 
 
                           <bin>            <bin> 
 
 
Use rule:  <factor> ::= <bin> 
10/24/13 53 
Example cont. 
n  1 * 1 + 0:    <exp> 
 
                    <factor> 
 
           <bin>      *         <exp> 
 
              1         <factor>  +    <factor> 
 
                           <bin>            <bin> 
 
                               1                   0 
Use rules:  <bin> ::= 1 | 0 
10/24/13 54 
Example cont. 
n  1 * 1 + 0:    <exp> 
 
                    <factor> 
 
           <bin>      *         <exp> 
 
              1         <factor>  +    <factor> 
 
                           <bin>            <bin> 
 
                               1                   0 
Fringe of tree is string generated by grammar 
10/24/13 55 
Your Turn: 1 * 0 + 0 * 1 
10/24/13 56 
Parse Tree Data Structures 
n  Parse trees may be represented by OCaml 
datatypes 
n  One datatype for each nonterminal 
n  One constructor for each rule 
n  Defined as mutually recursive collection of 
datatype declarations 
10/24/13 57 
Example 
n  Recall grammar: 
<exp>  ::= <factor>  |  <factor> +  <factor> 
<factor>  ::=  <bin> |  <bin>  *  <exp> 
<bin> ::=  0  | 1 
n  type exp = Factor2Exp of factor 
                   | Plus of factor * factor 
    and factor = Bin2Factor of bin  
                       | Mult of bin * exp 
    and bin = Zero | One 
10/24/13 58 
Example cont. 
n  1 * 1 + 0:    <exp> 
 
                    <factor> 
 
           <bin>      *         <exp> 
 
              1         <factor>  +    <factor> 
 
                           <bin>            <bin> 
 
                               1                   0 
 
10/24/13 59 
Example cont. 
n  Can be represented as 
Factor2Exp 
(Mult(One,   
          Plus(Bin2Factor One, 
                   Bin2Factor Zero))) 
10/24/13 60 
Ambiguous Grammars and Languages 
n  A BNF grammar is ambiguous if its language 
contains strings for which there is more than 
one parse tree 
n  If all BNF’s for a language are ambiguous 
then the language is inherently ambiguous 
10/24/13 61 
Example: Ambiguous Grammar 
n  0 + 1 + 0 
                <Sum>                 <Sum> 
 
        <Sum> + <Sum>  <Sum> + <Sum> 
 
<Sum> + <Sum>  0         0   <Sum> + <Sum> 
 
     0             1                            1             0 
 
10/24/13 62 
Example 
n  What is the result for: 
3 + 4 * 5 + 6 
10/24/13 63 
Example 
n  What is the result for: 
3 + 4 * 5 + 6 
n  Possible answers: 
n     41 = ((3 + 4) * 5) + 6 
n     47 = 3 + (4 * (5 + 6)) 
n     29 = (3 + (4 * 5)) + 6 = 3 + ((4 * 5) + 6) 
n     77 = (3 + 4) * (5 + 6) 
10/24/13 64 
Example 
n  What is the value of: 
7 – 5 – 2 
10/24/13 65 
Example 
n  What is the value of: 
7 – 5 – 2 
n  Possible answers: 
n  In Pascal, C++, SML assoc. left 
  7 – 5 – 2 = (7 – 5) – 2 = 0 
n  In APL, associate to right 
  7 – 5 – 2 = 7 – (5 – 2) = 4 
10/24/13 66 
Two Major Sources of Ambiguity 
n  Lack of determination of operator 
precedence 
n  Lack of determination of operator 
assoicativity 
n  Not the only sources of ambiguity 
