Today’s announcements: 
MP5 available, due 11/1, 11:59p 
Parallel Lab update: Lab Race due 11/6  
 
EWS Migration results?  
Code Challenge #2: 10/30 9PM in 0224 
Exam 2: 11/5, 7-10p, locations on website.  
Class cancelled 11/4. 
Exam reviews: 11/4, 12-2p in Siebel 1404 
      11/4, 2-3 in Siebel 0216 
 
Searching a B-tree 
bool B-TREE-SEARCH(BtreeNode & x, T key){ 
   int i = 0; 
   while ((i < x.numkeys) && (key > x.key[i])) 
      i++; 
   if ((i < x.numkeys) && (key == x.key[i])) 
      return true; 
   if (x.leaf == true) 
      return false; 
   else{ 
      BtreeNode b=DISK-READ(x.child[i]); 
      return B-TREE-SEARCH(b,key); 
   } 
} 17 
3 8 28 48 
1 2 6 7 12 14 16 52 53 55 68 25 26 29 45 
Analysis of B-Trees (order m) 
The height of the B-tree determines the number of disk seeks possible 
in a search for data. 
 
We want to be able to say that the height of the structure  and thus the 
number of disk seeks is no more than ________. 
 
As we saw in the case of AVL trees, finding an upper bound on the 
height (given n) is the same as finding a lower bound on the number 
of keys (given h). 
 
We seek a relationship between the height of the structure (h) and the 
amount of data it contains (n). 
Analysis of B-Trees (order m) 
We seek a relationship between the height of the structure (h) and the 
amount of data it contains (n). 
• The minimum number of nodes in each level of a B-tree of order m: 
(For your convenience, let t = ______.) 
root   
level 1  
level 2  
.  .  .  
level h 
• The total number of nodes is the sum of these: 
 
 
 
• So, the least total number of keys is: 
Analysis of B-Trees (order m) 
We seek a relationship between the height of the structure (h) and the 
amount of data it contains (n). (continued…)  
• So, the least total number of keys is: 
   
 
• rewrite as an inequality about n, the total number of keys: 
 
 
• rewrite that as an inequality about h, the height of the tree (note that 
this bounds the number of disk seeks): 
Summary 
B-Tree search: 
O(m) time per node  
O(logm n) height implies O(m logm n) total time 
BUT: 
Insert and Delete have similar stories. 
 
What you should know: 
Motivation 
Definition 
Search algorithm and analysis 
 
What you should not know: 
Insert and Delete 
Dictionary ADT  
association between key and data 
 
  
Suppose we have the following info… 
 
 
 
 
 
 
 
…and we want to be able to retrieve a 
name, given a locker number.  
Locker 
Number 
Name 
103 Jay Hathaway 
92 Linda Stencel 
330 Bonnie Cook 
46 Rick Brown 
124 Kim Petersen 
… … 
Functionality: Find, Insert, and Remove 
Implementations shown? 
 
 
 
Hashing - using “hash tables” to implement _________ 
 
 
 
Suppose we have the following info… 
 
 
 
 
 
 
 
…and we want to be able to retrieve a 
name, given a locker number.  
Locker 
Number 
Name 
103 Jay Hathaway 
92 Linda Stencel 
330 Bonnie Cook 
46 Rick Brown 
124 Kim Petersen 
… … 
Now suppose our keys are not so nicely 
described… 
 
Course Number -> Schedule info 
Color -> BMP 
Vertex -> Set of incident edges 
Flight number -> arrival information 
URL -> html page 
dice roll -> payoff amt 
Some general vocabulary 
A dictionary is a structure supporting the following: 
 void insert(kType & k, dType & d) 
 void remove(kType & k) 
 dType find(kType & k) 
 
An associative array is a dictionary w a particular interface–  
Overloads the [] operator for insert and find: 
myDictionary[“Miguel”]  = 22; 
dType d = myDictionary[“Miguel”]; 
Hashing: 
 
(defn) Keyspace – a (mathematical) description of the keys for a set of data. 
 
Goal: use a function to map the keyspace into a small set of 
integers. 
 
What’s fuzzy about this goal? 
Basic Idea:  we seek a mapping,  h(k)   
hash 
function 
A perfect hash function: 
0 
1 
2 
3 
4 
5 
6 
7 
(Ann, black cat) 
(Ben, HP) 
(Cory, spy) 
(David, bball player) 
(Ellen, butterfly) 
(Finn, cereal killer) 
(Gus, ghost) 
(Harmony, bee) 
A contrived example: 
these keys have a fabulous hash fn. 
   a. each key hashes to a different int 
   b. collection of keys hash to a seq of ints 
