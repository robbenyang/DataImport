1 Operations on Languages
Operations on Languages
â€¢ Recall: A language is a set of strings
â€¢ We can consider new languages derived from operations on given languages
â€“ e.g., L1 âˆª L2, L1 âˆ© L2, . . .
â€¢ A simple but powerful collection of operations:
â€“ Union, Concatenation and Kleene Closure
Union is a familiar operation on sets. We define and explain the other two operations below.
Concatenation of Languages
Definition 1. Given languages L1 and L2, we define their concatenation to be the language L1 â—¦
L2 = {xy | x âˆˆ L1, y âˆˆ L2}
Example 2. â€¢ L1 = {hello} and L2 = {world} then L1 â—¦ L2 = {helloworld}
â€¢ L1 = {00, 10}; L2 = {0, 1}. L1 â—¦ L2 = {000, 001, 100, 101}
â€¢ L1 = set of strings ending in 0; L2 = set of strings beginning with 01. L1 â—¦L2 = set of strings
containing 001 as a substring
â€¢ L â—¦ {} = L. L â—¦ âˆ… = âˆ….
Kleene Closure
Definition 3.
Ln =
{
{} if n = 0
Lnâˆ’1 â—¦ L otherwise L
âˆ— =
â‹ƒ
iâ‰¥0
Li
i.e., Li is L â—¦ L â—¦ Â· Â· Â· â—¦ L (concatenation of i copies of L), for i > 0.
Lâˆ—, the Kleene Closure of L: set of strings formed by taking any number of strings (possibly
none) from L, possibly with repetitions and concatenating all of them.
â€¢ If L = {0, 1}, then L0 = {}, L2 = {00, 01, 10, 11}. Lâˆ— = set of all binary strings (including
).
â€¢ âˆ…0 = {}. For i > 0, âˆ…i = âˆ…. âˆ…âˆ— = {}
â€¢ âˆ… is one of only two languages whose Kleene closure is finite. Which is the other? {}âˆ— = {}.
1
2 Regular Expressions
2.1 Definition and Identities
Regular Expressions
A Simple Programming Language
Figure 1: Stephen Cole Kleene
A regular expression is a formula for representing a (complex) language in terms of â€œelementaryâ€
languages combined using the three operations union, concatenation and Kleene closure.
Regular Expressions
Formal Inductive Definition
Syntax and Semantics
A regular expression over an alphabet Î£ is of one of the following forms:
Syntax Semantics
âˆ… L(âˆ…) = {}
Basis  L() = {}
a L(a) = {a}
(R1 âˆªR2) L((R1 âˆªR2)) = L(R1) âˆª L(R2)
Induction (R1 â—¦R2) L((R1 â—¦R2)) = L(R1) â—¦ L(R2)
(Râˆ—1) L((Râˆ—1)) = L(R1)âˆ—
Notational Conventions
Removing the brackets To avoid cluttering of parenthesis, we adopt the following conventions.
â€¢ Precedence: âˆ—, â—¦,âˆª. For example, R âˆª Sâˆ— â—¦ T means (R âˆª ((Sâˆ—) â—¦ T ))
â€¢ Associativity: (Râˆª(SâˆªT )) = ((RâˆªS)âˆªT ) = RâˆªSâˆªT and (Râ—¦(Sâ—¦T )) = ((Râ—¦S)â—¦T ) = Râ—¦Sâ—¦T .
Also will sometimes omit â—¦: e.g. will write RS instead of R â—¦ S
Regular Expression Examples
2
R L(R)
(0 âˆª 1)âˆ— = ({0} âˆª {1})âˆ— = {0, 1}âˆ—
0âˆ… âˆ…
0âˆ— âˆª (0âˆ—10âˆ—10âˆ—10âˆ—)âˆ— Strings where the number of 1s is divisible by 3
(0 âˆª 1)âˆ—001(0 âˆª 1)âˆ— Strings that have 001 as a substring
(10)âˆ— âˆª (01)âˆ— âˆª 0(10)âˆ— âˆª 1(01)âˆ— Strings that consist of alternating 0s and 1s
( âˆª 1)(01)âˆ—( âˆª 0) Strings that consist of alternating 0s and 1s
(0 âˆª )(1 âˆª 10)âˆ— Strings that do not have two consecutive 0s
Regular Languages
Definition 4. A language L âŠ† Î£âˆ— is a regular language iff there is a regular expression R such that
L(R) = L.
Some Regular Expression Identities
We say R1 = R2 if L(R1) = L(R2).
â€¢ Commutativity: R1 âˆªR2 = R2 âˆªR1 (but R1 â—¦R2 6= R2 â—¦R1 typically)
â€¢ Associativity: (R1 âˆªR2) âˆªR3 = R1 âˆª (R2 âˆªR3) and (R1 â—¦R2) â—¦R3 = R1 â—¦ (R2 â—¦R3)
â€¢ Distributivity: R â—¦ (R1 âˆªR2) = R â—¦R1 âˆªR â—¦R2 and (R1 âˆªR2) â—¦R = R1 â—¦R âˆªR2 â—¦R
â€¢ Concatenating with : R â—¦  =  â—¦R = R
â€¢ Concatenating with âˆ…: R â—¦ âˆ… = âˆ… â—¦R = âˆ…
â€¢ R âˆª âˆ… = R. R âˆª  = R iff  âˆˆ L(R)
â€¢ (Râˆ—)âˆ— = Râˆ—
â€¢ âˆ…âˆ— = 
Useful Notation
Definition 5. Define R+ = RRâˆ—. Thus, Râˆ— = R+ âˆª . In addition, R+ = Râˆ— iff  âˆˆ L(R).
3
