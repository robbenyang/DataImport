1 
MP2 extended, due 9/20, 11:59p. 
MP3 released, EC due 9/27, due 10/08 
 
 
1 
Announcements 
animal ** farm; 
 
farm = new animal*[3]; 
farm[0] = new dog; 
farm[1] = new pig; 
farm[2] = new horse; 
 
for (int i=0; i<3;i++) 
    farm[i]->speak(); 
Polymorphism:  objects of different types can employ methods of the same 
name and parameterization. 
Last time: Inheritance provides DYNAMIC polymorphism—type dependent 
functions can be selected at run-time.  Wikipedia: Polymorphism in OOP 
 
 
 
 
 
 
 
Now: “templates” are C++ implementation of static polymorphism, where 
type dependent functions are chosen at compile-time. 
void swapInt(int x, int y){ 
   int temp; 
   temp = x; 
   x = y; 
   y = temp; 
} 
int main(){ 
  int a = 1; int b = 2; 
   char c = ‘n’; char d = ‘m’; 
   swapInt(a,b); 
   swapChar(c,d); 
   cout << a << “ “ << b << endl; 
   cout << c << “ “ << d << endl; 
} 
void swapChar(char x, char y){ 
   char temp; 
   temp = x; 
   x = y; 
   y = temp; 
} 
What do you notice about this code? 
Function templates: 
 
template <class T> 
void swapUs(T & x, T & y){ 
   T temp; 
   temp = x; 
   x = y; 
   y = temp; 
} 
int main(){ 
  int a = 1; int b = 2; 
   char c = ‘n’; char d = ‘m’; 
   swapUs      (a,b); 
   swapUs      (c,d); 
   cout << a << “ “ << b << endl; 
   cout << c << “ “ << d << endl; 
} 
Classes can be given templates too: 
0 1 2 3 4 5 6 7 
Class templates: 
int main () {        
   mypair<int> myobject(100, 75);   
   cout << myobject.getmax();   
   return 0; 
} 
template <class T> 
class mypair {     
private: 
   T a, b;   
public:     
   mypair (T first, T second); 
   T getmax (); 
}; 
template <class T> 
T mypair<T>::getmax () {   
   T retmax;   
   retmax = (a>b? a : b);   
   return retmax; 
} 
 
template <class T> 
mypair<T>::mypair(T first,T second){ 
   a = first;  
   b = second; 
} 
Class templates: 
Challenge1:  write the function signature for the copy constructor (if we needed one) for this class. 
:: ( 
) 
template <class T> 
T mypair<T>::getmax() {   
   T retmax;   
   retmax = (a>b? a : b);   
   return retmax; 
} 
 
template <class T> 
mypair<T>::mypair(T first, T second){ 
   a = first;  
   b = second; 
} 
template <class T> 
class mypair {     
private: 
   T a, b;   
public:     
   mypair(T first, T second); 
   T getmax(); 
}; 
Challenge2:  How do you declare a dynamic array of mypairs of integers? 
Challenge3:  How do you allocate memory if you want that array to have 8 elements? 
A note on templates: 
template <class T, class U> 
T addEm(T a, U b) { 
   return a + b; 
} 
 
int main() { 
   addEm<int,int>(3,4); 
   addEm<double,int>(3.2,4); 
   addEm<int,double>(4,3.2); 
   addEm<string,int>(“hi”,4); 
   addEm<int,string>(4,“hi”); 
} 
Template compilation: 
 Old:    New: 
