1 Introduction
Parenthesis Matching
Problem
Describe the set of arithmetic expressions with correctly matched parenthesis.
Arithmetic expressions with correctly matched parenthesis cannot be described by a regular
expression
â€¢ Let L be the language of correct expressions
â€¢ Suppose h maps number and variables to , and opening parenthesis to 0 and closing paren-
thesis to 1 then h(L) âŠ† {0, 1}âˆ—
â€¢ h(L) âˆ© 0âˆ—1âˆ— = {0n1n | n â‰¥ 0} which is not regular.
This is an example of a context-free language, that we study.
Parenthesis Matching
Inductive Definition
Ignoring numbers and variables, and focussing only on parenthesis, correctly matched expressions
can be defined as
â€¢ The  is a valid expression
â€¢ A valid string ( 6= ) must either be
â€“ The concatenation of two correctly matched expressions, or
â€“ It must begin with ( and end with ) and moreover, once the first and last symbols are
removed, the resulting string must correspond to a valid expression.
Parenthesis Matching
Grammar
Taking E to be the set of correct expressions, the inductive definition can be succinctly written as
E â†’ 
E â†’ EE
E â†’ (E)
English Sentences
1
English sentences can be described as
ã€ˆSã€‰ â†’ ã€ˆNP ã€‰ã€ˆV P ã€‰
ã€ˆNP ã€‰ â†’ ã€ˆCNã€‰ | ã€ˆCNã€‰ã€ˆPP ã€‰
ã€ˆV P ã€‰ â†’ ã€ˆCV ã€‰ | ã€ˆCV ã€‰ã€ˆPP ã€‰
ã€ˆPP ã€‰ â†’ ã€ˆP ã€‰ã€ˆCNã€‰
ã€ˆCNã€‰ â†’ ã€ˆAã€‰ã€ˆNã€‰
ã€ˆCV ã€‰ â†’ ã€ˆV ã€‰ | ã€ˆV ã€‰ã€ˆNP ã€‰
ã€ˆAã€‰ â†’ a | the
ã€ˆNã€‰ â†’ boy | girl | flower
ã€ˆV ã€‰ â†’ touches | likes | sees
ã€ˆP ã€‰ â†’ with
English Sentences
Examples
noun-phrsï¸· ï¸¸ï¸¸ ï¸·
aï¸¸ï¸·ï¸·ï¸¸
article
boyï¸¸ï¸·ï¸·ï¸¸
noun
verb-phrsï¸·ï¸¸ï¸¸ï¸·
seesï¸¸ï¸·ï¸·ï¸¸
verb
noun-phrsï¸· ï¸¸ï¸¸ ï¸·
theï¸¸ï¸·ï¸·ï¸¸
article
boyï¸¸ï¸·ï¸·ï¸¸
noun
verb-phrsï¸· ï¸¸ï¸¸ ï¸·
seesï¸¸ï¸·ï¸·ï¸¸
verb
a flowerï¸¸ ï¸·ï¸· ï¸¸
noun-phrs
Applications
Such rules (or grammars) play a key role in
â€¢ Parsing programming languages
â€¢ Markup Languages like HTML and XML.
â€¢ Modelling software
2 Formal Definition
2.1 Grammars
Context-Free Grammars
Definition 1. A context-free grammar (CFG) is G = (V,Î£, R, S) where
â€¢ V is a finite set of variables also called nonterminals or syntactic categories. Each variable
represents a language.
2
â€¢ Î£ is a finite set of symbols, disjoint from V , called terminals, that form the strings of the
language.
â€¢ R is a finite set of rules or productions. Each production is of the form Aâ†’ Î± where A âˆˆ V
and Î± âˆˆ (V âˆª Î£)âˆ—
â€¢ S âˆˆ V is the start symbol; it is the variable that represents the language being defined.
Other variables represent auxiliary languages that are used to define the language of the start
symbol.
Examples
Example 2. Let Gpar = (V,Î£, R, S) be
â€¢ V = {E}
â€¢ Î£ = {(, )}
â€¢ R = {E â†’ , E â†’ EE,E â†’ (E)}
â€¢ S = E
Example 3. A string w is a palindrome if w = wR.
Gpal = ({S}, {0, 1}, R, S) defines palindromes over {0, 1}, where R is
S â†’ 
S â†’ 0
S â†’ 1
S â†’ 0S0
S â†’ 1S1
Or more briefly, R = {S â†’  | 0 | 1 | 0S0 | 1S1}
Example 4. Consider the language of all arithmetic expressions (E) built out of integers (N) and
identifiers (I), using only + and âˆ—
Gexp = ({E, I,N}, {a, b, 0, 1, (, ),+, âˆ—,âˆ’}, R,E) where R is
E â†’ I |N | E + E | E âˆ— E | (E)
I â†’ a | b | Ia | Ib
N â†’ 0 | 1 |N0 |N1 | âˆ’N | +N
Derivations
Informal Overview
Expand the start symbol using one of its rules. Further expand the resulting string by expanding
one of the variables in the string, by the RHS of one of its rules. Repeat until you get a string of
terminals.
For the grammar Gpal = ({S}, {0, 1}, {S â†’  | 0 | 1 | 0S0 | 1S1}, S) we have
S â‡’ 0S0â‡’ 00S00â‡’ 001S100â‡’ 0010100
3
Definition 5. Let G = (V,Î£, R, S) be a CFG. We say Î±AÎ² â‡’G Î±Î³Î², where Î±, Î², Î³ âˆˆ (V âˆª Î£)âˆ—
and A âˆˆ V if Aâ†’ Î³ is a rule of G.
We say Î±
âˆ—â‡’G Î² if either Î± = Î² or there are Î±0, Î±1, . . . Î±n such that
Î± = Î±0 â‡’G Î±1 â‡’G Î±2 â‡’G Â· Â· Â· â‡’G Î±n = Î²
Notation
When G is clear from the context, we will write â‡’ and âˆ—â‡’ instead of â‡’G and âˆ—â‡’G.
Context-Free Language
Definition 6. The language of CFG G = (V,Î£, R, S), denoted L(G) is the collection of strings
over the terminals derivable from S using the rules in R. In other words,
L(G) = {w âˆˆ Î£âˆ— | S âˆ—â‡’ w}
Definition 7. A language L is said to be context-free if there is a CFG G such that L = L(G).
2.2 Proving Properties
Palindromes Revisited
Recall, Lpal = {w âˆˆ {0, 1}âˆ— | w = wR} is the language of palindromes.
ConsiderGpal = ({S}, {0, 1}, R, S) defines palindromes over {0, 1}, whereR = {S â†’ |0|1|0S0|1S1}
Proposition 8. L(Gpal) = Lpal
Proof. To prove the proposition, we need to show that Lpal âŠ† L(Gpal) and L(Gpal) âŠ† Lpal.
Lpal âŠ† L(Gpal): Let w âˆˆ Lpal. We prove that S âˆ—â‡’ w by induction on |w|.
â€¢ Base Cases: If |w| = 0 or |w| = 1 then w =  or 0 or 1. And S â†’  | 0 | 1.
â€¢ Induction Step: If |w| â‰¥ 2 and w = wR then it must begin and with the same symbol. Let
w = 0x0. Now, wR = 0xR0 = w = 0x0; thus, xR = x. By induction hypothesis, S
âˆ—â‡’ x.
Hence S â‡’ 0S0 âˆ—â‡’ 0x0. If w = 1x1 the argument is similar.
L(Gpal) âŠ† Lpal: Let w âˆˆ L(G), i.e., S âˆ—â‡’ w. We will show w âˆˆ Lpal by induction on the number
of derivation steps.
â€¢ Base Case: If the derivation has only one step then the derivation must be S â‡’ , S â‡’ 0 or
S â‡’ 1. Thus w =  or 0 or 1 and is in LPal.
â€¢ Induction Step: Consider an (n+ 1)-step derivation of w. It must be of the form S â‡’ 0S0 âˆ—â‡’
0x0 = w or S â‡’ 1S1 âˆ—â‡’ 1x1 = w. In either case S âˆ—â‡’ x in n-steps. Hence x âˆˆ LPal and so
w = wR.
4
Proving correctness
Example II
Let Ljâ‰¥2i = {aibj | j â‰¥ 2i}. Consider the following grammar Giâ‰¥2i = ({S,B}, {a, b}, R, S) where
R = {S â†’ aSbb |B; B â†’  | bB}
Proposition 9. L(Gjâ‰¥2i) = Ljâ‰¥2i.
Proof. Like in the previous example, to prove correctness, we will show that L(Gjâ‰¥2i) âŠ‡ Ljâ‰¥2i and
L(Gjâ‰¥2i) âŠ† Ljâ‰¥2i. And as in the previous example, the easiest way to do this, is to prove the first
part by induction on the length of the string w âˆˆ Ljâ‰¥2i, and the second part by induction on the
length of the derivation. However, in order for these proofs to work out, we also need to strengthen
the claim: the correctness only states that the set of strings derivable from S is exactly those that
belong to the set Ljâ‰¥2i, but for the induction proof to go through, we also need to describe the set
of strings that are derivable from B. This is very similar to the way induction proofs needed to be
strengthened for DFAs. In this case, the strengthened statement we will establish is as follows:
âˆ€w âˆˆ {a, b}âˆ—. S âˆ—â‡’ w iff w âˆˆ Ljâ‰¥2i and
B
âˆ—â‡’ w iff w âˆˆ L(bâˆ—)
â‡: Need to show that
âˆ€w âˆˆ {a, b}âˆ—. w âˆˆ Ljâ‰¥2i â‡’ S âˆ—â‡’ w and
w âˆˆ L(bâˆ—) â‡’ B âˆ—â‡’ w
We will prove this by induction on |w|.
â€¢ Base Case: Consider w = . Now, we have derivations, S â‡’ B â‡’  and B â‡’ , which
establish the base case.
â€¢ Ind. Hyp.: Assume that the claim holds for all w such that |w| < n.
â€¢ Ind. Step: Consider w = bn âˆˆ L(bâˆ—), where n > 0. Then, w = bu, where u = bnâˆ’1 âˆˆ L(bâˆ—).
By induction hypothesis, we have B
âˆ—â‡’ bnâˆ’1 = u. Thus, we have a derivation, B â‡’ bB âˆ—â‡’
bu = w. This establishes one part of the induction step.
Consider w = aibj âˆˆ Ljâ‰¥2i, where j â‰¥ 2i and i + j = n. Now, if i = 0, then w = bj ,
where j > 0. In other words, w âˆˆ L(bâˆ—). Now by the first part of the induction step, we
have B
âˆ—â‡’ bj = w. And so we have a derivation, S â‡’ B âˆ—â‡’ bj = w. On the other hand, if
i > 0, then w = aubb, where u = aiâˆ’1bjâˆ’2. Now if j â‰¥ 2i then j âˆ’ 2 â‰¥ 2i âˆ’ 2 = 2(i âˆ’ 1).
Thus, u âˆˆ Ljâ‰¥2i. By induction hypothesis, we have S âˆ—â‡’ u. Hence, we have a derivation,
S â‡’ aSbb âˆ—â‡’ aubb = w. This finished the induction step.
â‡’: Need to show that
âˆ€w âˆˆ {a, b}âˆ—. S âˆ—â‡’ w â‡’ w âˆˆ Ljâ‰¥2i and
B
âˆ—â‡’ w â‡’ w âˆˆ L(bâˆ—)
We will prove this by induction on the number of derivation steps for w.
5
â€¢ Base Case: Suppose B â‡’ w. Since the only rule that has only terminals on the right-hand
side is B â†’ , we have w =  âˆˆ L(bâˆ—). This establishes one part of the base case. On the
other hand, there is no rule with left-hand side S and right-hand side only terminals. Hence,
no string of terminals can be derived from S in 1 step, and so the base case for this condition
holds vaccuously.
â€¢ Ind. Hyp.: We assume that if B âˆ—â‡’ w in < n steps then w âˆˆ L(bâˆ—), and if S âˆ—â‡’ w in < n
steps then w âˆˆ Ljâ‰¥2i.
â€¢ Ind. Step: Let B âˆ—â‡’ w in n(> 1) steps. Because of the rules, we know that this derivation
is going to be of the form, B â‡’ bB âˆ—â‡’ bu = w, where B âˆ—â‡’ u in n âˆ’ 1 steps. By induction
hypothesis, u âˆˆ L(bâˆ—), and thus, w = bu âˆˆ L(bâˆ—). This finishes part one of the induction step.
Let S
âˆ—â‡’ w in n steps. Then there are two possibilities for the form of derivation. First case
is, S â‡’ B âˆ—â‡’ w. Since B âˆ—â‡’ w in n âˆ’ 1 steps, it means that (from induction hypothesis)
w âˆˆ L(bâˆ—) âŠ† Ljâ‰¥2i. The second case is that S â‡’ aSbb âˆ—â‡’ aubb = w, where S âˆ—â‡’ u in n âˆ’ 1
steps. By induction hypothesis, u âˆˆ Ljâ‰¥2i and so u = aibj , for some i, j such that j â‰¥ 2i.
Now w = aubb = a(aibj)bb = ai+1bj+2. Since j â‰¥ 2i, we have j + 2 â‰¥ 2i+ 2 = 2(i+ 1). Thus,
w âˆˆ Ljâ‰¥2i which establishes the second part of the induction step.
2.3 Parse Trees
Parse Trees
For CFG G = (V,Î£, R, S), a parse tree (or derivation tree) of G is a tree satisfying the following
conditions:
â€¢ Each interior node is labeled by a variable in V
â€¢ Each leaf is labeled by either a variable, a terminal or ; a leaf labeled by  must be the only
child of its parent.
â€¢ If an interior node labeled by A with children labeled by X1, X2, . . . Xk (from the left), then
Aâ†’ X1X2 Â· Â· Â·Xk must be a rule.
S
0 S
1 S
1 S

1
1
0
Figure 1: Example Parse Tree with yield 011110
6
Yield of a parse tree is the concatenation of leaf labels (leftâ€“right)
Parse Trees and Derivations
Proposition 10. Let G = (V,Î£, R, S) be a CFG. For any A âˆˆ V and Î± âˆˆ (V âˆª Î£)âˆ—, A âˆ—â‡’ Î± iff
there is a parse tree with root labeled A and whose yield is Î±.
Proof. (â‡’): Proof by induction on the number of steps in the derivation.
â€¢ Base Case: If Aâ‡’ Î± then Aâ†’ Î± is a rule in G. There is a tree of height 1, with root A and
leaves the symbols in Î±.
A
Î±1 Î±2 Â· Â· Â· Î±n
Figure 2: Parse Tree for Base Case
â€¢ Induction Step: Let A âˆ—â‡’ Î± in k + 1 steps.
â€¢ Then A âˆ—â‡’ Î±1XÎ±2 â‡’ Î±1Î³Î±2 = Î±, where X â†’ X1 Â· Â· Â·Xn = Î³ is a rule
â€¢ By ind. hyp., there is a tree with root A and yield Î±1XÎ±2.
â€¢ Add leaves X1, . . . Xn and make them children of X. New tree is a parse tree with desired
yield.
A
Î±1 X Î±2
Î³
Figure 3: Parse Tree for Induction Step
(â‡): Assume that there is a parse tree with root A and yield Î±. Need to show that A âˆ—â‡’ Î±.
Proof by induction on the number of internal nodes in the tree.
â€¢ Base Case: If tree has only one internal node, then it has the form as in picture
â€¢ Then, Î± = X1 Â· Â· Â·Xn and Aâ†’ Î± is a rule. Thus, A âˆ—â‡’ Î±.
7
AÎ±1 Î±2 Â· Â· Â· Î±n
Figure 4: Parse Tree with one internal node
Induction Step: Suppose Î± is the yield of a tree with k + 1 interior nodes. Let X1, X2, . . . Xn be
the children of the root ordered from the left. Not all Xi are leaves, and A â†’ X1X2 Â· Â· Â·Xn must
be a rule.
â€¢ Let Î±i be the yield of the tree rooted at Xi; so Xi is a leaf Î±i = Xi
â€¢ Now if j < i then all the descendents of Xj are to the left of the descendents of Xi. So
Î± = Î±1Î±2 Â· Â· Â·Î±n.
â€¢ Each subtree rooted at Xi has at most k internal nodes. So if Xi is a leaf Xi âˆ—â‡’ Î±i and if Xi
is not a leaf then Xi
âˆ—â‡’ Î±i (ind. hyp.).
â€¢ Thus Aâ‡’ X1X2 Â· Â· Â·Xn âˆ—â‡’ Î±1X2 Â· Â· Â·Xn âˆ—â‡’ Î±1Î±2 Â· Â· Â·Xn âˆ—â‡’ Î±1 Â· Â· Â·Î±n = Î±
A
X1 X2 Â· Â· Â· Xn
Â· Â· Â·
Î±1 Î±2 Î±n
Figure 5: Tree with k + 1 internal nodes
Recap . . .
For a CFG G with variable A the following are equivalent
1. A
âˆ—â‡’ w
2. There is a parse tree with root A and yield w
Context-free-ness
CFGs have the property that if X
âˆ—â‡’ Î³ then Î±XÎ² âˆ—â‡’ Î±Î³Î²
8
3 Ambiguity
3.1 The Concept
Ambiguity through examples
Example 11. English sentences can be described as
ã€ˆSã€‰ â†’ ã€ˆNP ã€‰ã€ˆV P ã€‰
ã€ˆNP ã€‰ â†’ ã€ˆCNã€‰ | ã€ˆCNã€‰ã€ˆPP ã€‰
ã€ˆV P ã€‰ â†’ ã€ˆCV ã€‰ | ã€ˆCV ã€‰ã€ˆPP ã€‰
ã€ˆPP ã€‰ â†’ ã€ˆP ã€‰ã€ˆCNã€‰
ã€ˆCNã€‰ â†’ ã€ˆAã€‰ã€ˆNã€‰
ã€ˆCV ã€‰ â†’ ã€ˆV ã€‰ | ã€ˆV ã€‰ã€ˆNP ã€‰
ã€ˆAã€‰ â†’ a | the
ã€ˆNã€‰ â†’ boy | girl | bat
ã€ˆV ã€‰ â†’ hits | likes | sees
ã€ˆP ã€‰ â†’ with
The sentence â€œthe girl hits the boy with the batâ€ has the following parse trees
ã€ˆSã€‰
ã€ˆNP ã€‰
ã€ˆCNã€‰
ã€ˆAã€‰
the
ã€ˆNã€‰
girl
ã€ˆV P ã€‰
ã€ˆV ã€‰
hits
ã€ˆNP ã€‰
ã€ˆCNã€‰
ã€ˆAã€‰
the
ã€ˆNã€‰
boy
ã€ˆPP ã€‰
ã€ˆP ã€‰
with
ã€ˆCNã€‰
ã€ˆAã€‰
the
ã€ˆNã€‰
bat
ã€ˆSã€‰
ã€ˆNP ã€‰
ã€ˆCNã€‰
ã€ˆAã€‰
the
ã€ˆNã€‰
girl
ã€ˆV P ã€‰
ã€ˆCV ã€‰
ã€ˆV ã€‰
hits
ã€ˆNP ã€‰
ã€ˆCNã€‰
ã€ˆAã€‰
the
ã€ˆNã€‰
boy
ã€ˆPP ã€‰
ã€ˆP ã€‰
with
ã€ˆCNã€‰
ã€ˆAã€‰
the
ã€ˆNã€‰
bat
9
Example 12. Consider the language of all arithmetic expressions (E) built out of integers (N) and
identifiers (I), using only + and âˆ—
Gexp = ({E, I,N}, {a, b, 0, 1, (, ),+, âˆ—,âˆ’}, R,E) where R is
E â†’ I |N | âˆ’N | E + E | E âˆ— E | (E)
I â†’ a | b | Ia | Ib
N â†’ 0 | 1 |N0 |N1
The parse trees for expression a+ b âˆ— a in the grammar Gexp is
E
E
I
a
+ E
E
I
b
âˆ— E
I
a
E
E
E
I
a
+ E
I
b
âˆ— E
I
a
Ambiguity
Definition 13. A grammar G = (V,Î£, R, S) is said to be ambiguous if there is w âˆˆ Î£âˆ— for which
there are two different parse trees.
Warning!
Existence of two derivations for a string does not mean the grammar is ambiguous!
3.2 Removing Ambiguity
Removing Ambiguity
Ambiguity maybe removed either by
10
â€¢ Using the semantics to change the rules. For example, if we knew who had the bat (the girl
or the boy) from the context, we would know which is the right interpretation.
â€¢ Adding precedence to operators. For example, âˆ— binds more tightly than +, or â€œelseâ€ binds
with the innermost â€œifâ€.
An Example
Recall, Gexp has the following rules
E â†’ I |N | âˆ’N | E + E | E âˆ— E | (E)
I â†’ a | b | Ia | Ib
N â†’ 0 | 1 |N0 |N1
New CFG Gâ€²exp has the rules
I â†’ a | b | Ia | Ib
N â†’ 0 | 1 |N0 |N1
F â†’ I |N | âˆ’N | (E)
T â†’ F | T âˆ— F
E â†’ T | E + T
Ambiguity: Computational Problems
Removing Ambiguity
Problem: Given CFG G, find CFG Gâ€² such that L(G) = L(Gâ€²) and Gâ€² is unambiguous.
There is no algorithm that can solve the above problem!
Deciding Ambiguity
Problem: Given CFG G, determine if G is ambiguous.
There is no algorithm that can solve the above problem!
Inherently Ambiguous Languages
Problem: Is it the case that for every CFG G, there is a grammar Gâ€² such that L(G) = L(Gâ€²) and
Gâ€² is unambiguous, even if Gâ€² cannot be constructed algorithmically?
No! There are context-free languages L such that every grammar for L is ambiguous.
Definition 14. A context-free language L is said to be inherently ambiguous if every grammar G
for L is ambiguous.
Inherently Ambiguous Languages
An Example
11
Consider
L = {aibjck | i = j or j = k}
One can show that any CFG G for L will have two parse trees on anbncn, for all but finitely many
values of n
â€¢ One that checks that number of aâ€™s = number of bâ€™s
â€¢ Another that checks that number of bâ€™s = number of câ€™s
12
