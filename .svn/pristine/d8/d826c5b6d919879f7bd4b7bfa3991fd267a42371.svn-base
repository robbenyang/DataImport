1 Introduction
Parenthesis Matching
Problem
Describe the set of arithmetic expressions with correctly matched parenthesis.
Arithmetic expressions with correctly matched parenthesis cannot be described by a regular
expression
• Let L be the language of correct expressions
• Suppose h maps number and variables to , and opening parenthesis to 0 and closing paren-
thesis to 1 then h(L) ⊆ {0, 1}∗
• h(L) ∩ 0∗1∗ = {0n1n | n ≥ 0} which is not regular.
This is an example of a context-free language, that we study.
Parenthesis Matching
Inductive Definition
Ignoring numbers and variables, and focussing only on parenthesis, correctly matched expressions
can be defined as
• The  is a valid expression
• A valid string ( 6= ) must either be
– The concatenation of two correctly matched expressions, or
– It must begin with ( and end with ) and moreover, once the first and last symbols are
removed, the resulting string must correspond to a valid expression.
Parenthesis Matching
Grammar
Taking E to be the set of correct expressions, the inductive definition can be succinctly written as
E → 
E → EE
E → (E)
English Sentences
1
English sentences can be described as
〈S〉 → 〈NP 〉〈V P 〉
〈NP 〉 → 〈CN〉 | 〈CN〉〈PP 〉
〈V P 〉 → 〈CV 〉 | 〈CV 〉〈PP 〉
〈PP 〉 → 〈P 〉〈CN〉
〈CN〉 → 〈A〉〈N〉
〈CV 〉 → 〈V 〉 | 〈V 〉〈NP 〉
〈A〉 → a | the
〈N〉 → boy | girl | flower
〈V 〉 → touches | likes | sees
〈P 〉 → with
English Sentences
Examples
noun-phrs︷ ︸︸ ︷
a︸︷︷︸
article
boy︸︷︷︸
noun
verb-phrs︷︸︸︷
sees︸︷︷︸
verb
noun-phrs︷ ︸︸ ︷
the︸︷︷︸
article
boy︸︷︷︸
noun
verb-phrs︷ ︸︸ ︷
sees︸︷︷︸
verb
a flower︸ ︷︷ ︸
noun-phrs
Applications
Such rules (or grammars) play a key role in
• Parsing programming languages
• Markup Languages like HTML and XML.
• Modelling software
2 Formal Definition
2.1 Grammars
Context-Free Grammars
Definition 1. A context-free grammar (CFG) is G = (V,Σ, R, S) where
• V is a finite set of variables also called nonterminals or syntactic categories. Each variable
represents a language.
2
• Σ is a finite set of symbols, disjoint from V , called terminals, that form the strings of the
language.
• R is a finite set of rules or productions. Each production is of the form A→ α where A ∈ V
and α ∈ (V ∪ Σ)∗
• S ∈ V is the start symbol; it is the variable that represents the language being defined.
Other variables represent auxiliary languages that are used to define the language of the start
symbol.
Examples
Example 2. Let Gpar = (V,Σ, R, S) be
• V = {E}
• Σ = {(, )}
• R = {E → , E → EE,E → (E)}
• S = E
Example 3. A string w is a palindrome if w = wR.
Gpal = ({S}, {0, 1}, R, S) defines palindromes over {0, 1}, where R is
S → 
S → 0
S → 1
S → 0S0
S → 1S1
Or more briefly, R = {S →  | 0 | 1 | 0S0 | 1S1}
Example 4. Consider the language of all arithmetic expressions (E) built out of integers (N) and
identifiers (I), using only + and ∗
Gexp = ({E, I,N}, {a, b, 0, 1, (, ),+, ∗,−}, R,E) where R is
E → I |N | E + E | E ∗ E | (E)
I → a | b | Ia | Ib
N → 0 | 1 |N0 |N1 | −N | +N
Derivations
Informal Overview
Expand the start symbol using one of its rules. Further expand the resulting string by expanding
one of the variables in the string, by the RHS of one of its rules. Repeat until you get a string of
terminals.
For the grammar Gpal = ({S}, {0, 1}, {S →  | 0 | 1 | 0S0 | 1S1}, S) we have
S ⇒ 0S0⇒ 00S00⇒ 001S100⇒ 0010100
3
Definition 5. Let G = (V,Σ, R, S) be a CFG. We say αAβ ⇒G αγβ, where α, β, γ ∈ (V ∪ Σ)∗
and A ∈ V if A→ γ is a rule of G.
We say α
∗⇒G β if either α = β or there are α0, α1, . . . αn such that
α = α0 ⇒G α1 ⇒G α2 ⇒G · · · ⇒G αn = β
Notation
When G is clear from the context, we will write ⇒ and ∗⇒ instead of ⇒G and ∗⇒G.
Context-Free Language
Definition 6. The language of CFG G = (V,Σ, R, S), denoted L(G) is the collection of strings
over the terminals derivable from S using the rules in R. In other words,
L(G) = {w ∈ Σ∗ | S ∗⇒ w}
Definition 7. A language L is said to be context-free if there is a CFG G such that L = L(G).
2.2 Proving Properties
Palindromes Revisited
Recall, Lpal = {w ∈ {0, 1}∗ | w = wR} is the language of palindromes.
ConsiderGpal = ({S}, {0, 1}, R, S) defines palindromes over {0, 1}, whereR = {S → |0|1|0S0|1S1}
Proposition 8. L(Gpal) = Lpal
Proof. To prove the proposition, we need to show that Lpal ⊆ L(Gpal) and L(Gpal) ⊆ Lpal.
Lpal ⊆ L(Gpal): Let w ∈ Lpal. We prove that S ∗⇒ w by induction on |w|.
• Base Cases: If |w| = 0 or |w| = 1 then w =  or 0 or 1. And S →  | 0 | 1.
• Induction Step: If |w| ≥ 2 and w = wR then it must begin and with the same symbol. Let
w = 0x0. Now, wR = 0xR0 = w = 0x0; thus, xR = x. By induction hypothesis, S
∗⇒ x.
Hence S ⇒ 0S0 ∗⇒ 0x0. If w = 1x1 the argument is similar.
L(Gpal) ⊆ Lpal: Let w ∈ L(G), i.e., S ∗⇒ w. We will show w ∈ Lpal by induction on the number
of derivation steps.
• Base Case: If the derivation has only one step then the derivation must be S ⇒ , S ⇒ 0 or
S ⇒ 1. Thus w =  or 0 or 1 and is in LPal.
• Induction Step: Consider an (n+ 1)-step derivation of w. It must be of the form S ⇒ 0S0 ∗⇒
0x0 = w or S ⇒ 1S1 ∗⇒ 1x1 = w. In either case S ∗⇒ x in n-steps. Hence x ∈ LPal and so
w = wR.
4
Proving correctness
Example II
Let Lj≥2i = {aibj | j ≥ 2i}. Consider the following grammar Gi≥2i = ({S,B}, {a, b}, R, S) where
R = {S → aSbb |B; B →  | bB}
Proposition 9. L(Gj≥2i) = Lj≥2i.
Proof. Like in the previous example, to prove correctness, we will show that L(Gj≥2i) ⊇ Lj≥2i and
L(Gj≥2i) ⊆ Lj≥2i. And as in the previous example, the easiest way to do this, is to prove the first
part by induction on the length of the string w ∈ Lj≥2i, and the second part by induction on the
length of the derivation. However, in order for these proofs to work out, we also need to strengthen
the claim: the correctness only states that the set of strings derivable from S is exactly those that
belong to the set Lj≥2i, but for the induction proof to go through, we also need to describe the set
of strings that are derivable from B. This is very similar to the way induction proofs needed to be
strengthened for DFAs. In this case, the strengthened statement we will establish is as follows:
∀w ∈ {a, b}∗. S ∗⇒ w iff w ∈ Lj≥2i and
B
∗⇒ w iff w ∈ L(b∗)
⇐: Need to show that
∀w ∈ {a, b}∗. w ∈ Lj≥2i ⇒ S ∗⇒ w and
w ∈ L(b∗) ⇒ B ∗⇒ w
We will prove this by induction on |w|.
• Base Case: Consider w = . Now, we have derivations, S ⇒ B ⇒  and B ⇒ , which
establish the base case.
• Ind. Hyp.: Assume that the claim holds for all w such that |w| < n.
• Ind. Step: Consider w = bn ∈ L(b∗), where n > 0. Then, w = bu, where u = bn−1 ∈ L(b∗).
By induction hypothesis, we have B
∗⇒ bn−1 = u. Thus, we have a derivation, B ⇒ bB ∗⇒
bu = w. This establishes one part of the induction step.
Consider w = aibj ∈ Lj≥2i, where j ≥ 2i and i + j = n. Now, if i = 0, then w = bj ,
where j > 0. In other words, w ∈ L(b∗). Now by the first part of the induction step, we
have B
∗⇒ bj = w. And so we have a derivation, S ⇒ B ∗⇒ bj = w. On the other hand, if
i > 0, then w = aubb, where u = ai−1bj−2. Now if j ≥ 2i then j − 2 ≥ 2i − 2 = 2(i − 1).
Thus, u ∈ Lj≥2i. By induction hypothesis, we have S ∗⇒ u. Hence, we have a derivation,
S ⇒ aSbb ∗⇒ aubb = w. This finished the induction step.
⇒: Need to show that
∀w ∈ {a, b}∗. S ∗⇒ w ⇒ w ∈ Lj≥2i and
B
∗⇒ w ⇒ w ∈ L(b∗)
We will prove this by induction on the number of derivation steps for w.
5
• Base Case: Suppose B ⇒ w. Since the only rule that has only terminals on the right-hand
side is B → , we have w =  ∈ L(b∗). This establishes one part of the base case. On the
other hand, there is no rule with left-hand side S and right-hand side only terminals. Hence,
no string of terminals can be derived from S in 1 step, and so the base case for this condition
holds vaccuously.
• Ind. Hyp.: We assume that if B ∗⇒ w in < n steps then w ∈ L(b∗), and if S ∗⇒ w in < n
steps then w ∈ Lj≥2i.
• Ind. Step: Let B ∗⇒ w in n(> 1) steps. Because of the rules, we know that this derivation
is going to be of the form, B ⇒ bB ∗⇒ bu = w, where B ∗⇒ u in n − 1 steps. By induction
hypothesis, u ∈ L(b∗), and thus, w = bu ∈ L(b∗). This finishes part one of the induction step.
Let S
∗⇒ w in n steps. Then there are two possibilities for the form of derivation. First case
is, S ⇒ B ∗⇒ w. Since B ∗⇒ w in n − 1 steps, it means that (from induction hypothesis)
w ∈ L(b∗) ⊆ Lj≥2i. The second case is that S ⇒ aSbb ∗⇒ aubb = w, where S ∗⇒ u in n − 1
steps. By induction hypothesis, u ∈ Lj≥2i and so u = aibj , for some i, j such that j ≥ 2i.
Now w = aubb = a(aibj)bb = ai+1bj+2. Since j ≥ 2i, we have j + 2 ≥ 2i+ 2 = 2(i+ 1). Thus,
w ∈ Lj≥2i which establishes the second part of the induction step.
2.3 Parse Trees
Parse Trees
For CFG G = (V,Σ, R, S), a parse tree (or derivation tree) of G is a tree satisfying the following
conditions:
• Each interior node is labeled by a variable in V
• Each leaf is labeled by either a variable, a terminal or ; a leaf labeled by  must be the only
child of its parent.
• If an interior node labeled by A with children labeled by X1, X2, . . . Xk (from the left), then
A→ X1X2 · · ·Xk must be a rule.
S
0 S
1 S
1 S

1
1
0
Figure 1: Example Parse Tree with yield 011110
6
Yield of a parse tree is the concatenation of leaf labels (left–right)
Parse Trees and Derivations
Proposition 10. Let G = (V,Σ, R, S) be a CFG. For any A ∈ V and α ∈ (V ∪ Σ)∗, A ∗⇒ α iff
there is a parse tree with root labeled A and whose yield is α.
Proof. (⇒): Proof by induction on the number of steps in the derivation.
• Base Case: If A⇒ α then A→ α is a rule in G. There is a tree of height 1, with root A and
leaves the symbols in α.
A
α1 α2 · · · αn
Figure 2: Parse Tree for Base Case
• Induction Step: Let A ∗⇒ α in k + 1 steps.
• Then A ∗⇒ α1Xα2 ⇒ α1γα2 = α, where X → X1 · · ·Xn = γ is a rule
• By ind. hyp., there is a tree with root A and yield α1Xα2.
• Add leaves X1, . . . Xn and make them children of X. New tree is a parse tree with desired
yield.
A
α1 X α2
γ
Figure 3: Parse Tree for Induction Step
(⇐): Assume that there is a parse tree with root A and yield α. Need to show that A ∗⇒ α.
Proof by induction on the number of internal nodes in the tree.
• Base Case: If tree has only one internal node, then it has the form as in picture
• Then, α = X1 · · ·Xn and A→ α is a rule. Thus, A ∗⇒ α.
7
Aα1 α2 · · · αn
Figure 4: Parse Tree with one internal node
Induction Step: Suppose α is the yield of a tree with k + 1 interior nodes. Let X1, X2, . . . Xn be
the children of the root ordered from the left. Not all Xi are leaves, and A → X1X2 · · ·Xn must
be a rule.
• Let αi be the yield of the tree rooted at Xi; so Xi is a leaf αi = Xi
• Now if j < i then all the descendents of Xj are to the left of the descendents of Xi. So
α = α1α2 · · ·αn.
• Each subtree rooted at Xi has at most k internal nodes. So if Xi is a leaf Xi ∗⇒ αi and if Xi
is not a leaf then Xi
∗⇒ αi (ind. hyp.).
• Thus A⇒ X1X2 · · ·Xn ∗⇒ α1X2 · · ·Xn ∗⇒ α1α2 · · ·Xn ∗⇒ α1 · · ·αn = α
A
X1 X2 · · · Xn
· · ·
α1 α2 αn
Figure 5: Tree with k + 1 internal nodes
Recap . . .
For a CFG G with variable A the following are equivalent
1. A
∗⇒ w
2. There is a parse tree with root A and yield w
Context-free-ness
CFGs have the property that if X
∗⇒ γ then αXβ ∗⇒ αγβ
8
3 Ambiguity
3.1 The Concept
Ambiguity through examples
Example 11. English sentences can be described as
〈S〉 → 〈NP 〉〈V P 〉
〈NP 〉 → 〈CN〉 | 〈CN〉〈PP 〉
〈V P 〉 → 〈CV 〉 | 〈CV 〉〈PP 〉
〈PP 〉 → 〈P 〉〈CN〉
〈CN〉 → 〈A〉〈N〉
〈CV 〉 → 〈V 〉 | 〈V 〉〈NP 〉
〈A〉 → a | the
〈N〉 → boy | girl | bat
〈V 〉 → hits | likes | sees
〈P 〉 → with
The sentence “the girl hits the boy with the bat” has the following parse trees
〈S〉
〈NP 〉
〈CN〉
〈A〉
the
〈N〉
girl
〈V P 〉
〈V 〉
hits
〈NP 〉
〈CN〉
〈A〉
the
〈N〉
boy
〈PP 〉
〈P 〉
with
〈CN〉
〈A〉
the
〈N〉
bat
〈S〉
〈NP 〉
〈CN〉
〈A〉
the
〈N〉
girl
〈V P 〉
〈CV 〉
〈V 〉
hits
〈NP 〉
〈CN〉
〈A〉
the
〈N〉
boy
〈PP 〉
〈P 〉
with
〈CN〉
〈A〉
the
〈N〉
bat
9
Example 12. Consider the language of all arithmetic expressions (E) built out of integers (N) and
identifiers (I), using only + and ∗
Gexp = ({E, I,N}, {a, b, 0, 1, (, ),+, ∗,−}, R,E) where R is
E → I |N | −N | E + E | E ∗ E | (E)
I → a | b | Ia | Ib
N → 0 | 1 |N0 |N1
The parse trees for expression a+ b ∗ a in the grammar Gexp is
E
E
I
a
+ E
E
I
b
∗ E
I
a
E
E
E
I
a
+ E
I
b
∗ E
I
a
Ambiguity
Definition 13. A grammar G = (V,Σ, R, S) is said to be ambiguous if there is w ∈ Σ∗ for which
there are two different parse trees.
Warning!
Existence of two derivations for a string does not mean the grammar is ambiguous!
3.2 Removing Ambiguity
Removing Ambiguity
Ambiguity maybe removed either by
10
• Using the semantics to change the rules. For example, if we knew who had the bat (the girl
or the boy) from the context, we would know which is the right interpretation.
• Adding precedence to operators. For example, ∗ binds more tightly than +, or “else” binds
with the innermost “if”.
An Example
Recall, Gexp has the following rules
E → I |N | −N | E + E | E ∗ E | (E)
I → a | b | Ia | Ib
N → 0 | 1 |N0 |N1
New CFG G′exp has the rules
I → a | b | Ia | Ib
N → 0 | 1 |N0 |N1
F → I |N | −N | (E)
T → F | T ∗ F
E → T | E + T
Ambiguity: Computational Problems
Removing Ambiguity
Problem: Given CFG G, find CFG G′ such that L(G) = L(G′) and G′ is unambiguous.
There is no algorithm that can solve the above problem!
Deciding Ambiguity
Problem: Given CFG G, determine if G is ambiguous.
There is no algorithm that can solve the above problem!
Inherently Ambiguous Languages
Problem: Is it the case that for every CFG G, there is a grammar G′ such that L(G) = L(G′) and
G′ is unambiguous, even if G′ cannot be constructed algorithmically?
No! There are context-free languages L such that every grammar for L is ambiguous.
Definition 14. A context-free language L is said to be inherently ambiguous if every grammar G
for L is ambiguous.
Inherently Ambiguous Languages
An Example
11
Consider
L = {aibjck | i = j or j = k}
One can show that any CFG G for L will have two parse trees on anbncn, for all but finitely many
values of n
• One that checks that number of a’s = number of b’s
• Another that checks that number of b’s = number of c’s
12
