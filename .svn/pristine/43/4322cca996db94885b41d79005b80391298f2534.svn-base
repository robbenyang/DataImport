lw $12, 0($3) 
Data Memory 
$3 
$12 
…	  
0x10010000 0x00 
0x11 
0x22 
0x33 
Register File 
0x10010000 
0x10010001 
0x10010002 
0x10010003 
2 (Add)
32
alu_op[2:0]
write_enable
itype
except
opcode[5:0]
funct[5:0]
MIPS decoder
A[31:0]
alu_op[2:0]
out[31:0]
B[31:0]
ALU
rsDatarsNum
reset
rdNum
rtDatartNum
rdWriteEnable
rdData
Register File
reset
clk
wr_enable
Rdest
Rt
Rs
zero
negative
overflow
0
1
wr_enable
itype
itype
alu_op[2:0]
reset
enable
Q[31:0]
D[31:0]
PC Register
Sign 
Extender
out[31:0]
in[15:0]
data[31:0]
addr[29:0]
Instruction
Memory
4
inst[31:0]
PC[31:0]
ALU
1
nextPC[31:0]
0
1
itype
inst[25:21]
inst[20:16]
inst[15:11]
inst[20:16]
inst[5:0]
inst[15:0]
inst[31:26]
except
PC
[3
1:
2]
Rt
Rd
imm16
imm32
32
30
32
3
5
5
5
16
32
6
6
32
32
32
32
32
3
3
control_type
0 1 2 3
2 (Add)
ALU
3
Shift Left 2
out[31:0]
in[29:0]30 32
inst[25:21] 00 (for LSBs)
PC[31:28] (for MSBs)
branch
offset
branch
offset
32
control_type control_type
Data	  Memory	  
Addr	  
Data_in	  
Data_out	  
word_we	  
byte_we	  
lbu rt, offset(rs) 
Data Memory 
$3 
$12 
…	  
0x10010000 0xF1 
0xF1 
0xF2 
0xF3 
Register File 
0x10010000 
0x10010001 
0x10010002 
0x10010003 
MIPS	  Load	  &	  Stores	  
address: offset + R[rs] 
$rt <- Memory[Addres] 
Loads a word of 4 bytes 
address: offset + R[rs] 
$rt[0:7]  <- Memory[address] 
$rt[8:31] <- 24’b0 
lw rt, offset(rs) 
lbu $12, 2($3) 
