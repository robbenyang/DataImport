8/29/13 1 
Programming Languages and 
Compilers (CS 421) 
Elsa L Gunter 
2112 SC, UIUC 
http://courses.engr.illinois.edu/cs421 
Based in part on slides by Mattox Beckman, as updated 
by Vikram Adve and Gul Agha 
8/29/13 2 
Contact Information - Elsa L Gunter 
n  Office: 2112 SC 
n  Office hours: 
n  Tuesdays 3:30pm – 4:40pm  
n  Thursdays 3:30pm – 4:20pm 
n  Also by appointment 
n  May add more if it seems called for 
n  Email: egunter@illinois.edu 
8/29/13 3 
Contact Information - TAs 
n  Teaching Assistants Office: 0207 SC 
n  Yodsawalai Chodpathumwan 
n  Email: ychodpa2@illinois.edu 
n  Hours: Thurs 1:00pm – 1:50pm &  
    Fri 9:00am – 9:50am 
n  Andrei Stefanescu 
n  Email: stefane1@illinois.edu 
n  Hours: Mon 1:30pm – 2:20pm & 
    Tues 1:00pm - 1:50pm 
8/29/13 4 
Contact Information - TAs 
n  Jicong Wang 
n  Email: wang220@illinois.edu 
n  Hours: Wed 11:00am – 11:50am &  
    Fri 11:00am – 11:50am 
8/29/13 5 
Course Website 
n  http://courses.engr.illinois.edu/cs421 
n  Main page - summary of news items 
n  Policy - rules governing course 
n  Lectures - syllabus and slides 
n  MPs - information about homework 
n  Exams 
n  Unit Projects - for 4 credit students 
n  Resources - tools and helpful info 
n  FAQ 
8/29/13 6 
Some Course References 
n  No required textbook. 
n  Essentials of Programming Languages (2nd Edition) 
by Daniel P. Friedman, Mitchell Wand and 
Christopher T. Haynes, MIT Press 2001. 
n  Compilers: Principles, Techniques, and Tools, (also 
known as "The Dragon Book"); by Aho, Sethi, and 
Ullman. Published by Addison-Wesley. ISBN: 
0-201-10088-6. 
n  Modern Compiler Implementation in ML by Andrew 
W. Appel, Cambridge University Press 1998 
n  Additional ones for Ocaml given separately 
8/29/13 7 
Course Grading 
n  Homework 20%  
n  About 12 MPs (in Ocaml) and 12 written assignments 
n  Submitted by handin on EWS linux machines 
n  MPs – plain text code that compiles; HWs – pdf  
n  Late submission penalty: 20% of assignments total value 
n  2 Midterms - 20% each 
n  In class – Oct 10, Nov 14 
n  DO NOT MISS EXAM DATES!  
n  Final 40% - Dec 17, 1:30pm – 4:30pm 
n  Percentages are approximate 
n  Exams may weigh more if homework is much better 
8/29/13 8 
Course Homework 
n  You may discuss homeworks and their solutions 
with others 
n  You may work in groups, but you must list 
members with whom you worked if you share 
solutions or solution outlines 
n  Each student must turn in their own solution 
separately 
n  You may look at examples from class and other 
similar examples from any source 
n  Note: University policy on plagiarism still holds - cite your 
sources if you are not the sole author of your solution 
8/29/13 9 
Course Homework and Exams 
n  Problems from homework may appear verbatim, or 
with some modification on exams 
n  Caution: Failure to be able to do homework 
problems when they appear on the exam may 
cause you to loose credit for the assignment from 
which they came, if you turned in a solution for the 
problem on the assignment 
8/29/13 10 
Course Objectives 
n  New programming paradigm 
n  Functional programming 
n  Order of Evaluation 
n  Tail Recursion 
n  Continuation Passing Style 
n  Phases of an interpreter / compiler 
n  Lexing and parsing 
n  Type checking 
n  Evaluation 
n  Programming Language Semantics 
n  Lambda Calculus 
n  Operational Semantics 
8/29/13 11 
OCAML 
n  Compiler is on the EWS-linux systems at 
n  /usr/local/bin/ocaml 
n  A (possibly better, non-PowerPoint) text 
version of this lecture can be found at 
n  http://course.engr.illinois.edu/class/cs421/
lectures/ocaml-intro-shell.txt 
n  For the OCAML code for today’s lecture see 
n  http://course.engr.illinois.edu/class/cs421/
lectures/ocaml-intro.ml 
8/29/13 12 
WWW Addresses for OCAML 
n  Main CAML home: 
http://caml.inria.fr/index.en.html 
n  To install OCAML on your computer see:  
n  http://caml.inria.fr/ocaml/release.en.html 
8/29/13 13 
References for CAML 
n  Supplemental texts (not required): 
n   The Objective Caml system release 4.0, by 
Xavier Leroy, online manual 
n  Introduction to the Objective Caml 
Programming Language, by Jason Hickey 
n  Developing Applications With Objective 
Caml, by Emmanuel Chailloux, Pascal 
Manoury, and Bruno Pagano, on O’Reilly 
n  Available online from course resources 
8/29/13 14 
OCAML 
n  CAML is European descendant of original ML 
n  American/British version is SML 
n  O is for object-oriented extension 
n  ML stands for Meta-Language 
n  ML family designed for implementing 
theorem provers 
n  It was the meta-language for programming the 
“object” language of the theorem prover 
n  Despite obscure original application area, OCAML 
is a full general-purpose programming language 
8/29/13 15 
Features of OCAML 
n  Higher order applicative language 
n  Call-by-value parameter passing 
n  Modern syntax 
n  Parametric polymorphism 
n  Aka structural polymorphism 
n  Automatic garbage collection 
n  User-defined algebraic data types 
n  It’s fast - winners of the 1999 and 2000 ICFP 
Programming Contests used OCAML 
8/29/13 16 
Why learn OCAML? 
n  Many features not clearly in languages you 
have already learned 
n  Assumed basis for much research in 
programming language research 
n  Closely related to popular  
n  OCAML is particularly efficient for 
programming tasks involving languages (eg 
parsing, compilers, user interfaces) 
n  Used at Microsoft  for writing SLAM, a formal 
methods tool for C programs 
8/29/13 17 
Session in OCAML 
% ocaml 
Objective Caml version 3.12.0   
# (* Read-eval-print loop; expressions and 
declarations *) 
   2 + 3;;     (* Expression *) 
-  : int = 5 
# 3 < 2;; 
- : bool = false 
8/29/13 18 
No Overloading for Basic Arithmetic Operations 
# 15 * 2;; 
- : int = 30 
# 1.35 + 0.23;;  (* Wrong type of addition *) 
Characters 0-4: 
  1.35 + 0.23;;  (* Wrong type of addition *) 
  ^^^^ 
Error: This expression has type float but an 
expression was expected of type 
         int 
# 1.35 +. 0.23;; 
- : float = 1.58 
No Implicit Coercion  
# 1.0 * 2;; (* No Implicit Coercion *) 
Characters 0-3: 
  1.0 * 2;; (* No Implicit Coercion *) 
  ^^^ 
Error: This expression has type float but an 
expression was expected of type 
         int 
8/29/13 19 
8/29/13 20 
Sequencing Expressions 
# "Hi there";;  (* has type string *) 
- : string = "Hi there" 
# print_string "Hello world\n";;  (* has type unit *) 
Hello world 
- : unit = () 
# (print_string "Bye\n"; 25);;  (* Sequence of exp *) 
Bye 
- : int = 25 
8/29/13 21 
Terminology 
n  Output refers both to the result returned 
from a function application  
n  As in + outputs integers, whereas +. outputs 
floats 
n  And to text printed as a side-effect of a 
computation 
n  As in print_string “\n” outputs a carriage return 
n  In terms of values, it outputs ( ) (“unit”) 
n  We will standardly use “output” to refer to 
the value returned 
Declarations; Sequencing of Declarations 
# let x = 2 + 3;;   (* declaration *) 
val x : int = 5 
# let test = 3 < 2;; 
val test : bool = false 
# let a = 3 let b = a + 2;; (* Sequence of dec 
*) 
val a : int = 3 
val b : int = 5 
8/29/13 22 
8/29/13 23 
Environments 
n  Environments record what value is associated with 
a given identifier 
n  Central to the semantics and implementation of a 
language 
n  Notation 
ρ = {name1 → value1, name2→ value2, …} 
Using set notation, but describes a partial function 
n  Often stored as list, or stack 
n  To find value start from left and take first match 
8/29/13 24 
Global Variable Creation 
# 2 + 3;;     (* Expression *) 
// doesn’t affect the environment 
# let test = 3 < 2;;       (* Declaration *) 
val test : bool = false 
//  ρ1 = {test → false} 
# let a = 1 let b = a + 4;; (* Seq of dec *) 
//  ρ2 = {b → 5, a → 1, test → false} 
New Bindings Hide Old 
//  ρ2 = {b → 5, a → 1, test → false} 
let test = 3.7;; 
 
n  What is the environment after this 
declaration? 
8/29/13 25 
New Bindings Hide Old 
//  ρ2 = {b → 5, a → 1, test → false} 
let test = 3.7;; 
 
n  What is the environment after this 
declaration? 
//  ρ3 = {a → 3, b → 5, test → 3.7} 
 
8/29/13 26 
8/29/13 27 
Local let binding 
//  ρ3 = {a → 3, b → 5, test → 3.7} 
# let c = 
    let b = a + a 
//  ρ4 = {b → 6} + ρ3 
//      ={b → 6, a → 3, test → 3.7} 
    in b * b;; 
val c : int = 36 
//  ρ5 = {c → 36, a → 3, b → 5, test → 3.7} 
# b;; 
- : int = 5 
8/29/13 28 
Local Variable Creation 
// ρ5 = {c → 36, b → 5, a → 3, test → 3.7} 
# let b = 5 * 4 
// ρ6 = {b → 20, c → 36, a → 3, test → 3.7} 
    in 2 * b;; 
- : int = 40 
// ρ7 = ρ5 
# b;; 
- : int = 5 
8/29/13 29 
Booleans (aka Truth Values) 
# true;; 
- : bool = true 
# false;; 
- : bool = false 
 
# if y > x then 25 else 0;; 
- : int = 25 
8/29/13 30 
Booleans 
# 3 > 1 && 4 > 6;; 
- : bool = false 
# 3 > 1 || 4 > 6;; 
- : bool = true 
# (print_string "Hi\n"; 3 > 1) || 4 > 6;; 
Hi 
- : bool = true 
# 3 > 1 || (print_string "Bye\n"; 4 > 6);; 
- : bool = true 
# not (4 > 6);; 
- : bool = true 
Tuples 
# let s = (5,"hi",3.2);; 
val s : int * string * float = (5, "hi", 3.2) 
# let (a,b,c) = s;;  (* (a,b,c) is a pattern *) 
val a : int = 5 
val b : string = "hi" 
val c : float = 3.2 
# let x = 2, 9.3;; (* tuples don't require parens in 
Ocaml *) 
val x : int * float = (2, 9.3) 
 
8/29/13 31 
Tuples 
#  (*Tuples can be nested *) 
let d = ((1,4,62),("bye",15),73.95);; 
val d : (int * int * int) * (string * int) * float = 
  ((1, 4, 62), ("bye", 15), 73.95) 
#  (*Patterns can be nested *) 
let (p,(st,_),_) = d;; (* _ matches all, binds nothing 
*) 
val p : int * int * int = (1, 4, 62) 
val st : string = "bye" 
8/29/13 32 
8/29/13 33 
Functions 
# let plus_two n = n + 2;; 
val plus_two : int -> int = <fun> 
# plus_two 17;; 
- : int = 19 
# let plus_two = fun n -> n + 2;; 
val plus_two : int -> int = <fun> 
# plus_two 14;; 
- : int = 16 
First definition syntactic sugar for second 
8/29/13 34 
Using a nameless function 
# (fun x -> x * 3) 5;;   (* An application *) 
- : int = 15 
# ((fun y -> y +. 2.0), (fun z -> z * 3));;      
(* As data *) 
- : (float -> float) * (int -> int) = (<fun>, 
<fun>) 
 
Note: in fun v -> exp(v), scope of variable is 
only the body exp(v) 
8/29/13 35 
Values fixed at declaration time 
# let x = 12;; 
val x : int = 12 
# let plus_x y = y + x;; 
val plus_x : int -> int = <fun> 
# plus_x 3;; 
 
What is the result? 
8/29/13 36 
Values fixed at declaration time 
# let x = 12;; 
val x : int = 12 
# let plus_x y = y + x;; 
val plus_x : int -> int = <fun> 
# plus_x 3;; 
- : int = 15 
8/29/13 37 
Values fixed at declaration time 
# let x = 7;;   (* New declaration, not an 
update *) 
val x : int = 7 
# plus_x 3;; 
 
What is the result this time? 
8/29/13 38 
Values fixed at declaration time 
# let x = 7;;   (* New declaration, not an 
update *) 
val x : int = 7 
# plus_x 3;; 
- : int = 15 
8/29/13 39 
Functions with more than one argument 
# let add_three x y z = x + y + z;; 
val add_three : int -> int -> int -> int = <fun> 
# let t = add_three 6 3 2;;  
val t : int = 11 
# let add_three = 
   fun x -> (fun y -> (fun z -> x + y + z));; 
val add_three : int -> int -> int -> int = <fun> 
 Again, first syntactic sugar for second 
8/29/13 40 
Partial application of functions 
  let add_three x y z = x + y + z;; 
 
# let h = add_three 5 4;; 
val h : int -> int = <fun> 
# h 3;; 
- : int = 12 
# h 7;; 
- : int = 16 
8/29/13 41 
Functions as arguments 
# let thrice f x = f (f (f x));; 
val thrice : ('a -> 'a) -> 'a -> 'a = <fun> 
# let g = thrice plus_two;; 
val g : int -> int = <fun> 
# g 4;; 
- : int = 10 
# thrice (fun s -> "Hi! " ^ s) "Good-bye!";; 
- : string = "Hi! Hi! Hi! Good-bye!" 
8/29/13 42 
Question 
n  Observation: Functions are first-class values 
in this language 
n  Question: What value does the environment 
record for a function variable? 
 
n  Answer: a closure 
8/29/13 43 
Save the Environment! 
n  A closure is a pair of an environment and an 
association of a sequence of variables (the 
input variables) with an expression (the 
function body), written: 
f → < (v1,…,vn) → exp, ρf > 
n  Where ρf is the environment in effect when f 
is defined (if f is a simple function) 
8/29/13 44 
Closure for plus_x 
n  When plus_x was defined, had environment: 
ρplus_x = {x → 12, …, y → 24, …} 
n  Closure for plus_x: 
<y → y + x, ρplus_x > 
n  Environment just after plus_x defined: 
 {plus_x → <y → y + x, ρplus_x >} + ρplus_x 
8/29/13 45 
Evaluation of Application of plus_x;; 
n  Have environment: 
 ρ = {plus_x → <y → y + x, ρplus_x >, … , 
                y → 3, …} 
 where ρplus_x  = {x → 12, … , y →   24, …} 
n  Eval (plus_x y, ρ) rewrites to 
n  Eval (app <y → y + x, ρplus_x > 3, ρ) 
rewrites to 
n  Eval (y + x, {y → 3} +ρplus_x ) rewrites to 
n  Eval (3 + 12 , ρplus_x ) = 15 
Functions on tuples 
# let plus_pair (n,m) = n + m;; 
val plus_pair : int * int -> int = <fun> 
# plus_pair (3,4);; 
- : int = 7 
# let double x = (x,x);; 
val double : 'a -> 'a * 'a = <fun> 
# double 3;; 
- : int * int = (3, 3) 
# double "hi";; 
- : string * string = ("hi", "hi") 
8/29/13 46 
8/29/13 47 
• Each clause: pattern on 
left, expression on right 
• Each x, y has scope of 
only its clause 
• Use first matching clause 
Match Expressions 
# let triple_to_pair triple = 
  match triple 
  with (0, x, y) -> (x, y) 
  | (x, 0, y) -> (x, y) 
  | (x, y, _) -> (x, y);; 
val triple_to_pair : int * int * int -> int * int = 
<fun> 
8/29/13 48 
Closure for plus_pair 
n  Assume ρplus_pair was the environment just 
before plus_pair defined 
n  Closure for plus_pair: 
<(n,m) → n + m, ρplus_pair> 
n  Environment just after plus_pair defined: 
 {plus_pair → <(n,m) → n + m, ρplus_pair >} 
+ ρplus_pair 
8/29/13 49 
Evaluation of Application with Closures 
n  In environment ρ, evaluate left term to closure,                 
c = <(x1,…,xn) → b, ρ> 
n  (x1,…,xn) variables in (first) argument  
n   Evaluate the right term to values, (v1,…,vn) 
n  Update the environment ρ to 
   ρ’ = {x1 → v1,…, xn →vn}+ ρ 
n  Evaluate body b in environment ρ’ 
8/29/13 50 
Evaluation of Application of plus_pair 
n  Assume environment  
ρ = {x → 3…,  
        plus_pair →<(n,m) →n + m, ρplus_pair>} +        
        ρplus_pair 
n  Eval (plus_pair (4,x), ρ)= 
n  Eval (app <(n,m) →n + m, ρplus_pair> (4,x), ρ)) = 
n  Eval (app <(n,m) →n + m, ρplus_pair> (4,3), ρ)) = 
n  Eval (n + m, {n -> 4, m -> 3} + ρplus_pair) = 
n  Eval (4 + 3, {n -> 4, m -> 3} + ρplus_pair) = 7 
Closure question 
n  If we start in an empty environment, and we 
execute: 
 let f = fun => n + 5;; 
 (* 0 *) 
 let pair_map g (n,m) = (g n, g m);; 
 let f = pair_map f;; 
 
What is the environment at (* 0 *)? 
8/29/13 51 
Answer 
ρ0 = {f → <n → n + 5, { }>} 
8/29/13 52 
Closure question 
n  If we start in an empty environment, and we 
execute: 
 let f = fun => n + 5;; 
 let pair_map g (n,m) = (g n, g m);; 
 (* 1 *) 
 let f = pair_map f;; 
 
What is the environment at (* 1 *)? 
8/29/13 53 
Answer 
ρ0 = {f → <n → n + 5, { }>} 
ρ1 = {pair_map → <g (n,m) = (g n, g m), 
                            {f → <n → n + 5, { }>}>, 
         f → <n → n + 5, { }>} 
 
8/29/13 54 
Closure question 
n  If we start in an empty environment, and we 
execute: 
 let f = fun => n + 5;; 
 let pair_map g (n,m) = (g n, g m);; 
 let f = pair_map f;; 
(* 2*) 
 
What is the environment at (* 2 *)? 
8/29/13 55 
Answer 
 
 
8/29/13 56 
8/29/13 57 
Curried vs Uncurried 
n  Recall  
val add_three : int -> int -> int -> int = <fun> 
n  How does it differ from 
# let add_triple (u,v,w) = u + v + w;; 
val add_triple : int * int * int -> int = <fun> 
n  add_three is curried; 
n  add_triple is uncurried 
8/29/13 58 
Curried vs Uncurried 
# add_triple (6,3,2);; 
- : int = 11 
# add_triple 5 4;; 
Characters 0-10: 
  add_triple 5 4;; 
  ^^^^^^^^^^ 
This function is applied to too many arguments, 
maybe you forgot a `;' 
# fun x -> add_triple (5,4,x);; 
: int -> int = <fun> 
8/29/13 59 
Consider this code:  
 
let x = 27;; 
let f x = 
      let x = 5 in 
           (fun x -> print_int x) 10;; 
f 12;; 
 
What value is printed? 
 5 
10 
12 
27 
Scoping Question 
