
Kevin C. Chang
Indexing
Database Systems
• Index– what is?
• Clustered/unclustered indexes.
• Dense/sparse indexes.
• Primary/secondary indexes.
• B+ trees
• Search, insertion, deletion on B+ trees.
• Hash tables 
• Extensible hash tables
• Search, insertion, deletion
• Linear hash tables
• Search, insertion, deletion
Concepts You Will Learn
Indexing (1 of 66)Default Section (1 of 2)
The Big Picture: Where We Are
Indexing (2 of 66)
Default Section (2 of 2)
Query Executor
Buffer Manager
Storage Manager
Tables, Indexes
Query Optimizer
Query Parser/Rewriter
Access Manager
Web/Mobile/Console Applications
S
Q
L
R
e
l
a
t
i
o
n
a
l
 
A
l
g
e
b
r
a
B
+
T
r
e
e
H
a
s
h
E
R
Transaction
Manager
Concurrency 
Control
Logging/
Recovery
Relational NonRelational
Information Extraction
XML 
Databases
Map Reduce
NoSQL 
Databases
Structured SemiStructured
Why Do We Learn This?
Indexing (3 of 66)Why Do We Learn This? (0 of 0)
Index: What, Why, and How?
Indexing (4 of 66)Index: What, Why, and How? (0 of 14)
• To build an index.
• But what is an index? 
• Examples in the real world?
Q: What is “indexing”? 
Indexing (5 of 66)Index: What, Why, and How? (1 of 14)
What is “indexing”? 
Indexing (6 of 66)Index: What, Why, and How? (2 of 14)
•An index on a file speeds up selections on the search key 
field(s) 
•Search key = any subset of the fields of a relation
• Search key is not the same as key (minimal set of fields that 
uniquely identify a record in a relation).
•Entries in an index: (k, r), where:
• k = the key
• r = the record OR record id OR record ids
Indexes
Indexing (7 of 66)Index: What, Why, and How? (3 of 14)
•Clustered/unclustered
• Clustered = records sorted in the key order
• Unclustered = no
•Dense/sparse
• Dense = each record has an entry in the index
• Sparse = only some records have
•Primary/secondary
• Primary = on the primary key
• Secondary = on any key
• Some textbooks interpret these differently
•B+ tree / Hash table / …
Types of Indexes
Indexing (8 of 66)Index: What, Why, and How? (4 of 14)
• Clustered: File is sorted on the index attribute
• Dense: sequence of (key,pointer) pairs
Ex: Clustered, Dense Index
Indexing (9 of 66)
10
20
30
40
50
60
70
80
10
20
30
40
50
60
70
80
Index: What, Why, and How? (5 of 14)
• Sparse index: one key per data block
Clustered, Sparse Index
Indexing (10 of 66)
10
30
50
70
90
110
130
150
10
20
30
40
50
60
70
80
Index: What, Why, and How? (6 of 14)
How if duplicate keys?
Indexing (11 of 66)Index: What, Why, and How? (7 of 14)
• Dense index: point to the first record with that key
Clustered Index with Duplicate Keys
Indexing (12 of 66)
10
20
30
40
50
60
70
80
10
10
10
20
20
20
30
40
Index: What, Why, and How? (8 of 14)
• Sparse index: pointer to lowest search key in each block:
• OK? 
Try search for 20
Clustered Index with Duplicate Keys
Indexing (13 of 66)
10
10
20
30
10
10
10
20
20
20
30
40
Index: What, Why, and How? (9 of 14)
• Better: pointer to lowest new search key in each block:
• Search for 20
Clustered Index with Duplicate Keys
Indexing (14 of 66)
10
20
30
40
50
60
70
80
10
10
10
20
30
30
40
50
Index: What, Why, and How? (10 of 14)
• Often for indexing other attributes than primary key
• Always dense (why ?)
Unclustered Indexes
Indexing (15 of 66)
10
10
20
20
20
30
30
30
20
30
30
20
10
20
10
30
Index: What, Why, and How? (11 of 14)
Summary Clustered vs. Unclustered Index
Indexing (16 of 66)
Data entries
(Index File)
(Data file)
Data Records
Data entries
Data Records
CLUSTERED UNCLUSTERED
Index: What, Why, and How? (12 of 14)
Composite Search Keys
• Composite Search Keys: Search 
on a combination of fields.
• Equality query: Every field 
value is equal to a constant 
value. E.g. wrt <sal,age> index:
• age=20 and sal =75
• Range query: Some field value 
is not a constant. E.g.:
• age =20; or age=20 and sal > 10
Indexing (17 of 66)
sue 13 75
bob
cal
joe 12
10
20
8011
12
name age sal
<sal, age>
<age, sal> <age>
<sal>
12,20
12,10
11,80
13,75
20,12
10,12
75,13
80,11
11
12
12
13
10
20
75
80
Data records
sorted by name
Data entries in index
sorted by <sal,age>
Data entries
sorted by <sal>
Examples of composite key
indexes using lexicographic order.
Index: What, Why, and How? (13 of 14)
• How many indexes? Where?
• What are keys? What are records?
• Clustered?
• Dense?
• Primary?
Q: Our textbook as example: Indexes? 
Indexing (18 of 66)Index: What, Why, and How? (14 of 14)
B+ Trees
Indexing (19 of 66)B+ Trees (0 of 26)
Kevin C. Chang
B+ Trees
Indexing (20 of 66)
What’s wrong with sequential index?
B+ Trees (1 of 26)
B‐Trees/B+Trees: B_ ?_ _? _ _ Trees
• Intuition:
• Give up on sequentiality of index
• Try to get “balance” by dynamic reorganization
• B+trees:
• Textbook refers to B+trees (a popular variant) as B‐trees (as most people do)
• Distinction will be clear later (ok to confuse now)
Indexing (21 of 66)B+ Trees (2 of 26)
Behind the Scene: 
UIUC (Alumni) Contribution!
Prof. Rudolf Bayer
Rudolf Bayer studied Mathematics in Munich and at the University of Illinois, 
where he received his Ph.D. in 1966. After working at Boeing Research Labs he 
became an Associate Professor at Purdue University. He is a Professor of 
Informatics at the Technische Universität München since 1972 and … …
The 2001 SIGMOD Innovations Award goes to Prof. Rudolf Bayer of the Technical 
University of Munich, for his invention of the B‐Tree (with Edward M. 
McCreight), of B‐Tree prefix compression, and of lock coupling (a.k.a. crabbing) 
for concurrent access to B‐Trees (with Mario Schkolnick). All of these techniques 
are widely used in commercial database products. ……
The Original Publication
Rudolf Bayer, Edward M. McCreight: Organization and Maintenance of 
Large Ordered Indices. Acta Informatica 1: 173-189(1972)
Indexing (22 of 66)B+ Trees (3 of 26)
Behind the Scene: And he said Hello!
Indexing (23 of 66)B+ Trees (4 of 26)
• Parameter d = the degree
• Each node has [d, 2d] keys (except root)
• Internal node:
• Leaf:
B+ Trees Basics
Indexing (24 of 66)
30 120 240
[X , 30) [30, 120) [120, 240) [240, Y)
40 50 60
40 50 60
next leaf
B+ Trees (5 of 26)
B+ Tree Example
Indexing (25 of 66)
80
20 60 100 120 140
10 15 18 20 30 40 50 60 65 80 85 90
10 15 18 20 30 40 50 60 65 80 85 90
d = 2
B+ Trees (6 of 26)
• How large d ?
• Example:
• Key size = 4 bytes
• Pointer size = 8 bytes
• Block size = 4096 byes
• 2d x 4  + (2d+1) x 8  <=  4096
• d = 170
B+ Tree Design
Indexing (26 of 66)B+ Trees (7 of 26)
