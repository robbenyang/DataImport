1 Variants of Turing Machines
1.1 Multi-Tape TM
Multi-Tape Turing Machine
0 1 1 0 unionsq unionsq
1 0 unionsq 0 0 unionsq
0 0 1 unionsq unionsq
finite-state
control
â€¢ Input on Tape 1
â€¢ Initially all heads scanning cell 1, and tapes 2 to k blank
â€¢ In one step: Read symbols under each of the k-heads, and depending on the current con-
trol state, write new symbols on the tapes, move the each tape head (possibly in different
directions), and change state.
Multi-Tape Turing Machine
Formal Definition
A k-tape Turing Machine is M = (Q,Î£,Î“, Î´, q0, qacc, qrej) where
â€¢ Q is a finite set of control states
â€¢ Î£ is a finite set of input symbols
â€¢ Î“ âŠ‡ Î£ is a finite set of tape symbols. Also, a blank symbol unionsq âˆˆ Î“ \ Î£
â€¢ q0 âˆˆ Q is the initial state
â€¢ qacc âˆˆ Q is the accept state
â€¢ qrej âˆˆ Q is the reject state, where qrej 6= qacc
â€¢ Î´ : (Q \ {qacc, qrej})Ã— Î“k â†’ QÃ— (Î“Ã— {L,R})k is the transition function.
Computation, Acceptance and Language
â€¢ A configuration of a multi-tape TM must describe the state, contents of all k-tapes, and
positions of all k-heads. Thus, c âˆˆ QÃ— (Î“âˆ—{âˆ—}Î“Î“âˆ—)k, where âˆ— denotes the head position.
1
â€¢ Accepting configuration is one where the state is qacc, and starting configuration on input w
is (q0, âˆ—w, âˆ—unionsq, . . . , âˆ—unionsq)
â€¢ Formal definition of a single step is skipped.
â€¢ w is accepted by M , if from the starting configuration with w as input, M reaches an accepting
configuration.
â€¢ L(M) = {w | w accepted by M}
Expressive Power of multi-tape TM
Theorem 1. For any k-tape Turing Machine M , there is a single tape TM single(M) such that
L(single(M)) = L(M).
Challenges
â€¢ How do we store k-tapes in one?
â€¢ How do we simulate the movement of k independent heads?
Storing Multiple Tapes
0 1 1 unionsq
1 0 unionsq unionsq
finite-state
control
Figure 1: Multi-tape TM M
(1, Â·, 0, âˆ—) (0, âˆ—, 1, Â·) (unionsq, Â·, 1, Â·) unionsq
finite-state
control
Figure 2: 1-tape equivalent single(M)
Store in cell i contents of cell i of all tapes. â€œMarkâ€ head position of tape with âˆ—.
Simulating One Step
Challenge 1: Head of 1-Tape TM is pointing to one cell. How do we find out all the k symbols that
are being read by the k heads, which maybe in different cells?
2
â€¢ Read the tape from left to right, storing the contents of the cells being scanned in the state,
as we encounter them.
Challenge 2: After this scan, 1-tape TM knows the next step of k-tape TM. How do we change
the contents and move the heads?
â€¢ Once again, scan the tape, change all relevant contents, â€œmoveâ€ heads (i.e., move âˆ—s), and
change state.
Overall Construction
First we outline the high-level algorithm for the 1-tape TM. On input w
1. First the machine will rewrite input w to be in â€œnewâ€ format.
2. To simulate one step
â€¢ Read from left-to-right remembering symbols read on each tape, and move all the way
back to leftmost position.
â€¢ Read from left-to-right, changing symbols, and moving those heads that need to be
moved right.
â€¢ Scan back from right-to-left moving the heads that need to be moved left.
Formally, let M = (Q,Î£,Î“, Î´, q0, qacc, qrej). To define the machine single(M) it is useful to
identify modes that single(M) could be in while simulating M . The modes are
mode = {init,back-init, read, back-read,fix-right, fix-left}
where
â€¢ init means that the machine is rewriting input in new format
â€¢ back-init means the machine is just going back all the way to the leftmost cell after â€œinitial-
lizingâ€ the tape
â€¢ read means the machine is scanning from left to right to read all symbols being read by k-tape
machine
â€¢ back-read means the machine is going back to leftmost cell after the â€œreadâ€ phase
â€¢ fix-right means the machine is scanning from left to right and is going to make all tape changes
and move those heads that need to be moved right
â€¢ fix-left means the machine is scanning right to left and moving all heads that need to be
moved left
Now single(M) = (Qâ€²,Î£â€²,Î“â€², Î´â€², qâ€²0, qâ€²acc, qâ€²rej) where
3
â€¢ Recall, based on the high-level description, single(M) needs to remember a few things in its
state. It needs to keep track of the current â€œmodeâ€; Ms state; during the read phase the
symbols being scanned by each head of M ; at the end of the read phase, the new symbols to
be written and direction to move the heads. Thus,
Qâ€² = {qâ€²0, qâ€²acc, qâ€²rej} âˆª (modesÃ—QÃ— (Î“Ã— {L,R, âˆ—})k)
where qâ€²0, qâ€²acc, qâ€²rej are new initial, accept and reject states, respectively. â€œâˆ—â€ is new special
symbol that we will use to when placing new head positions, and can be ignored for now.
Intuitively, when the mode is â€œreadâ€ the directions donâ€™t mean anything, and symbols in
Î“ will be the symbols that M is scanning. During the â€œfixâ€ phases the directions are the
directions each head needs to be moved, and the symbols are the new symbols to be written.
â€¢ Î£â€² = Î£; the input alphabet does not change
â€¢ On the tape, we write the contents of one cell of each of the k-tapes and whether the head
scans that position or not. Thus, Î“â€² = {B,unionsq} âˆª (Î“Ã—{Â·, âˆ—})k, where B will be a new left-end-
marker, as it will be useful for single(M) to know when it has finished scanning all the way
to the left. unionsq as always is the blank symbol of the machine.
â€¢ The initial state, accept state and reject states are the new states qâ€²0, qâ€²acc, and qâ€²rej.
We will now formally define the transition function Î´. We will describe Î´ for various cases below;
for a case not covered below, we will assume our usual convention that the machine single(M) goes
to the reject state qâ€²rej and moves the head left.
Initial State In the first step, single(M) will move to the â€œinitialization phaseâ€, which will write
a (new) left endmarker, and rewrite the tape in the correct format for the future. Thus, from
initial state qâ€²0 you go to a state whose â€œmodeâ€ is init. Since we are going to insert a new
left end-marker, we need to â€œshiftâ€ all symbols of the input one-space to right, which can
be accomplished by remembering the next symbol to be written in the state. So Î´â€²(qâ€²0, a) =
(ã€ˆinit, q0, a, âˆ—, 0, L, 0, L, . . . , 0, Lã€‰,B); the symbols 0 and L donâ€™t mean anything (and so can be
changed to whatever you please), and the âˆ— remembers that when we write the next symbol
all heads must be in that position.
Initialization In the initialization phase, we just read a symbol and write it in the â€œnew formatâ€,
which means writing blank symbols for all the other tape cells, and moving right. When we
scan the entire input to go back left, i.e., change mode to back-init. There are two caveats to
this. First we are shifting symbols of the input one position to the right because of the left
endmarker B; so we actually write what we remembered in our state, and remember what
we read in the state. Also, in the first position, we need to â€œplaceâ€ all the heads; this is
remembered because of âˆ—. So we have
Î´â€²(ã€ˆinit, q0, a, âˆ—, 0, L, . . . , 0, Lã€‰, b) = (ã€ˆinit, q0, b, L, 0, L, . . . , 0, Lã€‰, (a, âˆ—,unionsq, âˆ—, . . . ,unionsq, âˆ—),R)
Î´â€²(ã€ˆinit, q0, a, L, 0, L, . . . , 0, Lã€‰, b) = (ã€ˆinit, q0, b, L, 0, L, . . . , 0, Lã€‰, (a, Â·,unionsq, Â·, . . . ,unionsq, Â·),R)
Î´â€²(ã€ˆinit, q0, a, L, 0, L, . . . , 0, Lã€‰,unionsq) = (ã€ˆback-init, q0, 0, L, . . . , 0, Lã€‰, (a, Â·,unionsq, Â·, . . . ,unionsq, Â·), L)
4
Ending Initialization After we have rewritten the tape, we move the head all the way back, and
move to the next phase which is â€œreadingâ€. Here, the fact that we wrote a left end-marker
will be useful in realizing, when we have gone all the way back. So formally,
Î´â€²(ã€ˆback-init, q0, 0, L, . . . , 0, Lã€‰, b) = (ã€ˆback-init, q0, 0, L, . . . , 0, Lã€‰, b, L)
Î´â€²(ã€ˆback-init, q0, 0, L, . . . , 0, Lã€‰,B) = (ã€ˆread, q0, 0, L, . . . , 0, Lã€‰,B,R)
where b 6= B
Reading Here we scan the tape to the right, and whenever we encounter a position, where there
is a tape head (i.e., a âˆ— in the appropriate position), we will remember that symbol in the
state. When we reach the right end (i.e., read a unionsq), we know all the information to determine
the next step of M . We will remember the new symbols to right and directions of the head
in the state, and move to the next phase back-read where we just go back all the way to the
left end. These two cases are formally given as
â€¢ Suppose the current state is P = ã€ˆread, q, a1, d1, . . . , ai, di, . . . , ak, dkã€‰, and we read a
symbol X = (b1, h1, . . . , bi, hi, . . . , bk, hk), where if hi = âˆ— that means that the ith tape
head is read this position, and if hi = Â· then the ith tape head is not reading this position.
Thus,
Î´â€²(P,X) = (ã€ˆq, aâ€²1, d1, . . . , aâ€²i, di, . . . , aâ€²k, dkã€‰, X,R)
where aâ€²i = ai if hi = Â· and aâ€²i = bi if hi = âˆ—.
â€¢ Suppose the current state is P = ã€ˆread, q, a1, d1, . . . , ai, di, . . . , ak, dkã€‰, and we read unionsq.
This means we have finished scanning and all the symbols ai are the symbols that are
being read by M , and its state is q. So suppose M â€™s transition function Î´ says
Î´(q, a1, a2, . . . , ak) = (q
â€², b1, dâ€²1, . . . bk, d
â€²
k)
That is, it says â€œreplace symbol ai on tape i by bi and move its head in direction d
â€²
iâ€.
Then
Î´â€²(P,unionsq) = (ã€ˆback-read, qâ€², b1, dâ€²1, . . . bk, dâ€²kã€‰,unionsq, L)
So the new state of M , symbols to be written and direction of heads in stored in the state
and we go back.
Ending Reading After reading and determining the next step, we move the head all the way
back, and move to the next phase which is fixing the tape to reflect the new situation. Here,
the fact that we wrote a left end-marker will be useful in realizing when we have gone all the
way back. So formally,
Î´â€²(ã€ˆback-read, q, a1, d1, . . . , ak, dkã€‰, b) = (ã€ˆback-read, q, a1, d1, . . . , ak, dkã€‰, b, L)
Î´â€²(ã€ˆback-read, q, a1, d1, . . . , ak, dkã€‰,B) = (ã€ˆfix-right, q, a1, d1, . . . , ak, dkã€‰,B,R)
where b 6= B.
Right Scan of Fixing In this phase we move all the way to the right. Along the way, we change
the symbols to new symbols, wherever the old heads were, and move all heads that need to
be moved right. To move a head right, we will use â€œâˆ—â€ in the state to remember that the
old head position of the tape is in current cell, and it needs to be moved to the next cell.
Finally, there is the boundary case of moving the head on some tape to right of the rightmost
non-blank symbol on any tape. We will capture these cases formally.
5
â€¢ Let the current state of single(M) be P = ã€ˆfix-right, q, a1, d1, . . . , ak, dkã€‰ and let the
symbol being read be X = (b1, h1, . . . bk, hk). In such a situation, single(M) will move
to state P â€² = ã€ˆfix-right, q, a1, dâ€²1, . . . , ak, dâ€²kã€‰, move R and write X â€² = (bâ€²1, hâ€²1, . . . bâ€²k, hâ€²k).
P â€² and X â€² are determined as follows. If hi = âˆ— (that is, tape iâ€™s head was here) and
di = R then b
â€²
i = ai (write new symbol), h
â€²
i = Â· (new head is not here), and dâ€²i = âˆ—
(remember to put head in next cell). If hi = âˆ— and di = L then bâ€²i = ai (write new
symbol), hâ€²i = hi (defer head movement to next phase), and d
â€²
i = di. If hi = Â· and di = âˆ—
(i.e., we remember new head position is here) then bâ€²i = bi (donâ€™t change symbol), h
â€²
i = âˆ—
(new head is here), and dâ€²i = R (this was the original direction). If hi = Â· and di 6= âˆ—
then bâ€²i = bi and d
â€²
i = di.
â€¢ Consider the case when the state is P = ã€ˆfix-right, q, a1, d1, . . . , ak, dkã€‰, and unionsq is on
the tape. There are two possibilities. If di 6= âˆ— for every i then we move to state
P â€² = ã€ˆfix-left, q, a1, d1, . . . qk, dkã€‰, write unionsq and move L. On the other hand, suppose there
is some i such that di = âˆ—. Then we move to state P â€² = ã€ˆfix-right, q, a1, dâ€²1, . . . ak, dâ€²kã€‰,
move R and write X â€² = (bâ€²1, hâ€²1, . . . bâ€²k, h
â€²
k), where X
â€² and P â€² are given as follows. First
bâ€²i = unionsq for all i. Next, if di = âˆ— then hi = âˆ— and dâ€²i = R. On the other hand if di 6= âˆ—
then hâ€²i = Â· and dâ€²i = di.
Left Scan of Fixing In this phase we move all the way to the left, and along the way we move
all the head positions that needed to be moved left. These changes are similar to the case
of moving heads to the right, except for the case when moving a head left from the leftmost
position.
â€¢ Let the current state of single(M) be P = ã€ˆfix-left, q, a1, d1, . . . , ak, dkã€‰ and let the symbol
being read be X = (b1, h1, . . . bk, hk). In such a situation, single(M) will move to state
P â€² = ã€ˆfix-left, q, a1, dâ€²1, . . . , ak, dâ€²kã€‰, move L and write X â€² = (b1, hâ€²1, . . . bk, hâ€²k). P â€² and X â€²
are determined as follows. If hi = âˆ— and di = L (that is this tapeâ€™s head needs to be
moved left) then hâ€²i = Â· (new head is not here), and dâ€²i = âˆ— (remember to put head in next
cell). If hi = âˆ— and di = R then hâ€²i = hi and dâ€²i = di (donâ€™t do anything since we already
handled the right moves). If hi = Â· and di = âˆ— (i.e., we remember new head position is
here) then hâ€²i = âˆ— (new head is here), and dâ€²i = L (this was the original direction). If
hi = Â· and di 6= âˆ— then hâ€²i = hi and dâ€²i = di.
â€¢ Now we consider the case when we finish the left scan, i.e., the symbol being read is
B. Let the state be P = ã€ˆfix-left, q, a1, d1, . . . , ak, dkã€‰. Now there are two possibilities.
Either there are no pending left moves, i.e., di 6= âˆ— for all i, or there is a pending left
move di = âˆ— for some i. In the first case, we fixed all the moves correctly, and so we
move to state P â€² = ã€ˆread, q, a1, d1, . . . , ak, dkã€‰, write B, and move R, and start simulating
the next step. In the second case, we need to re-mark some head positions (since on
left moves from the end of the tape, we stay there). We will do this in two steps. First
single(M) will remain in state P , write B, and move R. In the next step, the transitions
already defined, will place the heads correctly, move left in a state without pending head
moves to read B and will be handled by the previous case.
Acceptance/Rejection If M accepts/rejects (i.e., its state is qacc or qrej) then single(M) will
6
move to its accept/reject state.
Î´â€²(ã€ˆread, qacc, a1, d1, . . . , ak, dkã€‰, b) = (qâ€²acc, b, L)
Î´â€²(ã€ˆread, qrej, a1, d1, . . . , ak, dkã€‰, b) = (qâ€²rej, b, L)
1.2 Nondeterministic TM
Nondeterministic Turing Machine
Deterministic TM: At each step, there is one possible next state, symbols to be written and direction
to move the head, or the TM may halt.
Nondeterministic TM: At each step, there are finitely many possibilities. So formally, M =
(Q,Î£,Î“, Î´, q0, qacc, qrej), where
â€¢ Q,Î£,Î“, q0, qacc, qrej are as before for 1-tape machine
â€¢ Î´ : (Q \ {qacc, qrej})Ã— Î“â†’ P(QÃ— Î“Ã— {L,R})
Computation, Acceptance and Language
â€¢ A configuration of a nondeterministic TM is exactly the same as that of a 1-tape TM. So are
notions of starting configuration and accepting configuration.
â€¢ A single step ` is defined similarly. X1X2 Â· Â· Â·Xiâˆ’1qXi Â· Â· Â·Xn ` X1X2 Â· Â· Â· pXiâˆ’1Y Â· Â· Â·Xn, if
(p, Y, L) âˆˆ Î´(q,Xi); case for right moves is analogous.
â€¢ w is accepted by M , if from the starting configuration with w as input, M reaches an accepting
configuration, for some sequence of choices at each step.
â€¢ L(M) = {w | w accepted by M}
Expressive Power of Nondeterministic TM
Theorem 2. For any nondeterministic Turing Machine M , there is a (deterministic) TM det(M)
such that L(det(M)) = L(M).
Proof Idea
det(M) will simulate M on the input.
â€¢ Idea 1: det(M) tries to keep track of all possible â€œconfigurationsâ€ that M could possibly be
after each step. Works for DFA simulation of NFA but not convenient here.
â€¢ Idea 2: det(M) will simulate M on each possible sequence of computation steps that M may
try in each step.
7
Nondeterministic Computation
c = q0w
c1 Â· Â· Â· ci Â· Â· Â· Â· Â· Â· cr
Â· Â· Â· Â· Â· Â· cij Â· Â· Â· cr1 Â· Â· Â· crr
Â· Â· Â· Â· Â· Â·
â€¢ If r = maxq,X |Î´(q,X)| then the runs of M can be organized as an r-branching tree.
â€¢ ci1i2Â·Â·Â·in is the configuration of M after n-steps, where choice i1 is taken in step 1, i2 in step
2, and so on.
â€¢ Input w is accepted iff âˆƒ accepting configuration in tree.
Deterministic Simulation
Proof Idea
The machine det(M) will search for an accepting configuration in computation tree
â€¢ The configuration at any vertex can be obtained by simulating M on the appropriate sequence
of nondeterministic choices
â€¢ det(M) will perform a BFS on the tree. Why not a DFS?
Observe that det(M) may not terminate if w is not accepted.
Proof Details
det(M) will use 3 tapes to simulate M (note, multitape TMs are equivalent to 1-tape TMs)
â€¢ Tape 1, called input tape, will always hold input w
â€¢ Tape 2, called simulation tape, will be used as M â€™s tape when simulating M on a sequence
of nondeterministic choices
â€¢ Tape 3, called choice tape, will store the current sequence of nondeterministic choices
Execution of det(M)
8
1. Initially: Input tape contains w, simulation tape and choice tape are blank
2. Copy contents of input tape onto simulation tape
3. Simulate M using simulation tape as its (only) tape
(a) At the next step of M , if state is q, simulation tape head reads X, and choice tape head
reads i, then simulate the ith possibility in Î´(q,X); if i is not a valid choice, then goto
step 4
(b) After changing state, simulation tape contents, and head position on simulation tape,
move choice tapeâ€™s head to the right. If Tape 3 is now scanning unionsq, then goto step 4
(c) If M accepts then accept and halt, else goto step 3(1) to simulate the next step of M .
4. Write the lexicographically next choice sequence on choice tape, erase everything on simula-
tion tape and goto step 2.
Deterministic Simulation
In a nutshell
â€¢ det(M) simulates M over and over again, for different sequences, and for different number of
steps.
â€¢ If M accepts w then there is a sequence of choices that will lead to acceptance. det(M) will
eventually have this sequence on choice tape, and then its simulation M will accept.
â€¢ If M does not accept w then no sequence of choices leads to acceptance. det(M) will therefore
never halt!
1.3 Random Access Machine
Random Access Machines
This is an idealized model of modern computers. Have a finite number of â€œregistersâ€, an infinite
number of available memory locations, and store a sequence of instructions or â€œprogramâ€ in memory.
â€¢ Initially, the program instructions are stored in a contiguous block of memory locations start-
ing at location 1. All registers and memory locations, other than those storing the program,
are set to 0.
Instruction Set
â€¢ add X, Y: Add the contents of registers X and Y and store the result in X.
â€¢ loadc X, I: Place the constant I in register X.
9
â€¢ load X, M: Load the contents of memory location M into register X.
â€¢ loadI X, M: Load the contents of the location â€œpointed toâ€ by the contents of M into register
X.
â€¢ store X, M: store the contents of register X in memory location M .
â€¢ jmp M: The next instruction to be executed is in location M .
â€¢ jmz X, M: If register X is 0, then jump to instruction M .
â€¢ halt: Halt execution.
Expressive Power of RAMs
Theorem 3. Anything computed on a RAM can be computed on a Turing machine.
Proof. We outline a proof sketch in next.
Capturing State of RAM
In order to simulate the RAM, the TM stores contents of registers, memory etc., in different tapes
as follows.
â€¢ Instruction Counter Tape: Stores the memory location where the next instrcution is stored;
initially it is 1.
â€¢ Memory Address Tape: Stores the address of memeory location where a load/store operation
is to be performed.
â€¢ Register Tape: Stores the contents of each of the registers.
â€“ Has register index followed by contents of each register as follows: #ã€ˆRegisterNumberã€‰ âˆ—
ã€ˆRegisterValueã€‰# Â· Â· Â· . For example, if register 1 has 11, register 2 has 100, register 3 has
11011, etc, then tape contains #1 âˆ— 11#10 âˆ— 100#11 âˆ— 11011# Â· Â· Â·
â€¢ Memory Tape: Like register tape, store #ã€ˆAddressã€‰ âˆ— ã€ˆContentsã€‰#
â€“ To store an instruction, have opcode, ã€ˆargumentsã€‰
â€¢ Work Tapes: Have 3 additional work tapes to simulate steps of the RAM
Simulating a RAM
â€¢ TM starts with the program stored in memory, and the instruction location tape initalized
to 1.
10
â€¢ Each step of the RAM is simulated using many steps.
â€“ Read the instruction counter tape
â€“ Search for the relevant instruction in memory
â€“ Store the opcode of instruction and register address (of argument) in the finite control.
Store the memory addres (of argument) in memory address tape.
â€“ Retrieve the values from register tape and/or memory tape and store them in work tape
â€“ Perform the operation using work tapes
â€“ Update instruction counter tape, register tape, and memory tape.
Example: ADD instruction
â€¢ Suppose instruction counter tape holds 101.
â€¢ TM searches memory tape for the pattern #101âˆ—.
â€¢ Suppose the memory tape contains Â· Â· Â·#101 âˆ— ã€ˆaddã€‰, 11, 110# Â· Â· Â·
â€¢ TM stores â€œaddâ€, 11 and 110 in its finite control. In other words, it moves to a state qadd 11,110
whose job it is to add the contents of register 11 and 110 and put the result in 11.
â€¢ Search the register tape for the pattern #11âˆ—. Suppose the register tape contains Â· Â· Â·#11 âˆ—
10110# Â· Â· Â· ; in other words, the contents of register 11 is 10110. Copy 10110 to one of the
work-tapes.
â€¢ Search the register tape for pattern #101âˆ—, and copy the contents of register onto work tape
2.
â€¢ Compute the sum of the contents of the work tapes
â€¢ Search the register tape for #11âˆ— and replace the string 10110 by the answer computed on
the work tape. This may involve shifting contents of the register tape to the right (or left).
â€¢ Add 1 to the instruction counter tape.
2 Church-Turing Thesis
2.1 Universality of the Model
Robustness of the Class of TM Languages
Various efforts to capture mechanical computation have the same expressive power.
â€¢ Non-Turing Machine models: random access machines, Î»-calculus, type 0 grammars, first-
order reasoning, pi-calculus, . . .
11
â€¢ Enhanced Turing Machine models: TM with 2-way infinite tape, multi-tape TM, nondeter-
ministic TM, probabilistic Turing Machines, quantum Turing Machines . . .
â€¢ Restricted Turing Machine models: queue machines, 2-stack machines, 2-counter machines,
. . .
2.2 Church-Turing Thesis
Church-Turing Thesis
â€œAnything solvable via a mechanical procedure can be solved on a Turing Machine.â€
â€¢ Not a mathematical statement that can be proved or disproved!
â€¢ Strong evidence based on the fact that many attempts to define computation yield the same
expressive power
Consequences
â€¢ In the course, we will use an informal pseudo-code to argue that a problem/language can be
solved on Turing machines
â€¢ To show that something can be solved on Turing machines, you can use any programming
language of choice, unless the problem specifically asks you to design a Turing Machine
12
