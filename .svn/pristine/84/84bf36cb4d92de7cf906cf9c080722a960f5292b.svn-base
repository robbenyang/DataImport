1 
Data Mining:  
 Concepts and Techniques 
 (3rd ed.) 
 
— Chapter 7 — 
Jiawei Han, Micheline Kamber, and Jian Pei 
University of Illinois at Urbana-Champaign & 
Simon Fraser University 
©2013 Han, Kamber & Pei.  All rights reserved. 
October 22, 2013 Data Mining: Concepts and Techniques 2 
3 
Chapter 7 : Advanced Frequent Pattern Mining 
 Pattern Mining: A Road Map 
 Pattern Mining in Multi-Level, Multi-Dimensional Space 
 Constraint-Based Frequent Pattern Mining 
 Mining High-Dimensional Data and Colossal Patterns 
 Mining Compressed or Approximate Patterns  
 Sequential Pattern Mining 
 Graph Pattern Mining 
 Summary 
R
e
s
e
a
rc
h
 o
n
 P
a
tt
e
rn
 M
in
in
g
: 
A
 R
o
a
d
 M
a
p
 
4 
5 
Chapter 7 : Advanced Frequent Pattern Mining 
 Pattern Mining: A Road Map 
 Pattern Mining in Multi-Level, Multi-Dimensional Space 
 Mining Multi-Level Association 
 Mining Multi-Dimensional Association 
 Mining Quantitative Association Rules 
 Mining Rare Patterns and Negative Patterns 
 Constraint-Based Frequent Pattern Mining 
 Mining High-Dimensional Data and Colossal Patterns 
 Mining Compressed or Approximate Patterns  
 Sequential Pattern Mining 
 Graph Pattern Mining 
 Summary 
6 
Mining Multiple-Level Association Rules 
 Items often form hierarchies 
 Flexible support settings  
 Items at the lower level are expected to have lower 
support 
 Exploration of shared multi-level mining (Agrawal & 
Srikant@VLB’95, Han & Fu@VLDB’95) 
uniform support 
Milk 
[support = 10%] 
2% Milk  
[support = 6%] 
Skim Milk  
[support = 4%] 
Level 1 
min_sup = 5% 
Level 2 
min_sup = 5% 
Level 1 
min_sup = 5% 
Level 2 
min_sup = 3% 
reduced support 
7 
Multi-level Association: Flexible Support and 
Redundancy filtering 
 Flexible min-support thresholds: Some items are more valuable but 
less frequent 
 Use non-uniform, group-based min-support 
 E.g., {diamond, watch, camera}: 0.05%; {bread, milk}: 5%; … 
 Redundancy Filtering: Some rules may be redundant due to 
“ancestor” relationships between items 
 milk  wheat bread  [support = 8%, confidence = 70%] 
 2% milk  wheat bread [support = 2%, confidence = 72%] 
The first rule is an ancestor of the second rule 
 A rule is redundant if its support is close to the “expected” value, 
based on the rule’s ancestor 
8 
Chapter 7 : Advanced Frequent Pattern Mining 
 Pattern Mining: A Road Map 
 Pattern Mining in Multi-Level, Multi-Dimensional Space 
 Mining Multi-Level Association 
 Mining Multi-Dimensional Association 
 Mining Quantitative Association Rules 
 Mining Rare Patterns and Negative Patterns 
 Constraint-Based Frequent Pattern Mining 
 Mining High-Dimensional Data and Colossal Patterns 
 Mining Compressed or Approximate Patterns  
 Sequential Pattern Mining 
 Graph Pattern Mining 
 Summary 
9 
Mining Multi-Dimensional Association 
 Single-dimensional rules: 
buys(X, “milk”)  buys(X, “bread”) 
 Multi-dimensional rules:  2 dimensions or predicates 
 Inter-dimension assoc. rules (no repeated predicates) 
age(X,”19-25”)  occupation(X,“student”)  buys(X, “coke”) 
 hybrid-dimension assoc. rules (repeated predicates) 
age(X,”19-25”)   buys(X, “popcorn”)  buys(X, “coke”) 
 Categorical Attributes: finite number of possible values, no 
ordering among values—data cube approach 
 Quantitative Attributes: Numeric, implicit ordering among 
values—discretization, clustering, and gradient approaches 
 
10 
Chapter 7 : Advanced Frequent Pattern Mining 
 Pattern Mining: A Road Map 
 Pattern Mining in Multi-Level, Multi-Dimensional Space 
 Mining Multi-Level Association 
 Mining Multi-Dimensional Association 
 Mining Quantitative Association Rules 
 Mining Rare Patterns and Negative Patterns 
 Constraint-Based Frequent Pattern Mining 
 Mining High-Dimensional Data and Colossal Patterns 
 Mining Compressed or Approximate Patterns  
 Sequential Pattern Mining 
 Graph Pattern Mining 
 Summary 
11 
Mining Quantitative Associations 
Techniques can be categorized by how numerical attributes, 
such as age or salary are treated 
1. Static discretization based on predefined concept 
hierarchies (data cube methods) 
2. Dynamic discretization based on data distribution 
(quantitative rules, e.g., Agrawal & Srikant@SIGMOD96)  
3. Clustering: Distance-based association (e.g., Yang & 
Miller@SIGMOD97)  
 One dimensional clustering then association 
4. Deviation: (such as Aumann and Lindell@KDD99) 
Sex = female   =>   Wage: mean=$7/hr (overall mean = $9) 
12 
Static Discretization of Quantitative Attributes 
 Discretized prior to mining using concept hierarchy. 
 Numeric values are replaced by ranges 
 In relational database, finding all frequent k-predicate sets 
will require k or k+1 table scans 
 Data cube is well suited for mining 
 The cells of an n-dimensional  
cuboid correspond to the  
predicate sets 
 Mining from data cubes 
can be much faster 
(income) (age) 
() 
(buys) 
(age, income) (age,buys) (income,buys) 
(age,income,buys) 
13 
Quantitative Association Rules Based on Statistical 
Inference Theory [Aumann and Lindell@DMKD’03] 
 Finding extraordinary and therefore interesting phenomena, e.g., 
(Sex = female)  => Wage: mean=$7/hr (overall mean = $9) 
 LHS: a subset of the population  
 RHS: an extraordinary behavior of this subset 
 The rule is accepted only if a statistical test (e.g., Z-test) confirms the 
inference with high confidence 
 Subrule: highlights the extraordinary behavior of a subset of the pop. 
of the super rule  
 E.g., (Sex = female) ^ (South = yes) => mean wage = $6.3/hr 
 Two forms of rules 
 Categorical => quantitative rules, or Quantitative => quantitative rules 
 E.g., Education in [14-18] (yrs) => mean wage = $11.64/hr 
 Open problem: Efficient methods for LHS containing two or more 
quantitative attributes 
14 
Chapter 7 : Advanced Frequent Pattern Mining 
 Pattern Mining: A Road Map 
 Pattern Mining in Multi-Level, Multi-Dimensional Space 
 Mining Multi-Level Association 
 Mining Multi-Dimensional Association 
 Mining Quantitative Association Rules 
 Mining Rare Patterns and Negative Patterns 
 Constraint-Based Frequent Pattern Mining 
 Mining High-Dimensional Data and Colossal Patterns 
 Mining Compressed or Approximate Patterns  
 Sequential Pattern Mining 
 Graph Pattern Mining 
 Summary 
15 
Negative and Rare Patterns 
 Rare patterns: Very low support but interesting 
 E.g., buying Rolex watches 
 Mining: Setting individual-based or special group-based 
support threshold for valuable items 
 Negative patterns 
 Since it is unlikely that one buys Ford Expedition (an 
SUV car) and Toyota Prius (a hybrid car) together, Ford 
Expedition and Toyota Prius are likely negatively 
correlated patterns 
 Negatively correlated patterns that are infrequent tend to 
be more interesting than those that are frequent 
16 
Defining Negative Correlated Patterns (I) 
 Definition 1 (support-based)  
 If itemsets X and Y are both frequent but rarely occur together, i.e.,  
sup(X U Y) < sup (X) * sup(Y) 
 Then X and Y are negatively correlated 
 Problem: A store sold two needle 100 packages A and B, only one 
transaction containing both A and B. 
 When there are in total 200 transactions, we have  
s(A U B) = 0.005, s(A) * s(B) = 0.25, s(A U B) < s(A) * s(B) 
 When there are 105 transactions, we have 
s(A U B) = 1/105, s(A) * s(B) = 1/103 * 1/103, s(A U B) > s(A) * s(B) 
 Where is the problem? —Null transactions, i.e., the support-based 
definition is not null-invariant! 
17 
Defining Negative Correlated Patterns (II) 
 Definition 2 (negative itemset-based)  
 X is a negative itemset if (1) X = Ā U B, where B is a set of positive 
items, and Ā is a set of negative items, |Ā|≥ 1, and (2) s(X) ≥ μ 
 Itemsets X is negatively correlated,  if 
 
 
 This definition suffers a similar null-invariant problem 
 Definition 3 (Kulzynski measure-based)  If itemsets X and Y are 
frequent, but (P(X|Y) + P(Y|X))/2 < є, where є is a negative pattern 
threshold, then X and Y are negatively correlated. 
 Ex. For the same needle package problem, when no matter there are 
200 or 105 transactions, if є = 0.05, we have 
(P(A|B) + P(B|A))/2 = (0.01 + 0.01)/2 < є 
18 
Chapter 7 : Advanced Frequent Pattern Mining 
 Pattern Mining: A Road Map 
 Pattern Mining in Multi-Level, Multi-Dimensional Space 
 Constraint-Based Frequent Pattern Mining 
 Mining High-Dimensional Data and Colossal Patterns 
 Mining Compressed or Approximate Patterns  
 Sequential Pattern Mining 
 Graph Pattern Mining 
 Summary 
19 
Constraint-based (Query-Directed) Mining 
 Finding all the patterns in a database autonomously? — unrealistic! 
 The patterns could be too many but not focused! 
 Data mining should be an interactive process  
 User directs what to be mined using a data mining query 
language (or a graphical user interface) 
 Constraint-based mining 
 User flexibility: provides constraints on what to be mined 
 Optimization: explores such constraints for efficient mining — 
constraint-based mining: constraint-pushing, similar to push 
selection first in DB query processing 
 Note: still find all the answers satisfying constraints, not finding 
some answers in “heuristic search” 
20 
Constraints in Data Mining 
 Knowledge type constraint:  
 classification, association, etc. 
 Data constraint — using SQL-like queries  
 find product pairs sold together in stores in Chicago this 
year 
 Dimension/level constraint 
 in relevance to region, price, brand, customer category 
 Rule (or pattern) constraint 
 small sales (price < $10) triggers big sales (sum > 
$200) 
 Interestingness constraint 
 strong rules: min_support  3%, min_confidence   
60% 
Meta-Rule Guided Mining 
 Meta-rule can be in the rule form with partially instantiated predicates 
and constants  
P1(X, Y) ^ P2(X, W) => buys(X, “iPad”) 
 The resulting rule derived can be 
age(X, “15-25”) ^ profession(X, “student”) => buys(X, “iPad”) 
 In general, it can be in the form of  
P1 ^ P2 ^ … ^ Pl => Q1 ^ Q2 ^ … ^ Qr  
 Method to find meta-rules 
 Find frequent (l+r) predicates (based on min-support threshold) 
 Push constants deeply when possible into the mining process (see 
the remaining discussions on constraint-push techniques) 
 Use confidence, correlation, and other measures when possible 
21 
22 
Constraint-Based Frequent Pattern Mining 
 Pattern space pruning constraints 
 Anti-monotonic: If constraint c is violated, its further mining can 
be terminated 
 Monotonic: If c is satisfied, no need to check c again 
 Succinct: c must be satisfied, so one can start with the data sets 
satisfying c 
 Convertible: c is not monotonic nor anti-monotonic, but it can be 
converted into it if items in the transaction can be properly 
ordered 
 Data space pruning constraint 
 Data succinct: Data space can be pruned at the initial pattern 
mining process 
 Data anti-monotonic: If a transaction t does not satisfy c, t can be 
pruned from its further mining 
23 
Pattern Space Pruning with Anti-Monotonicity Constraints 
 A constraint C is anti-monotone if the super 
pattern satisfies C, all of its sub-patterns do so 
too 
 In other words, anti-monotonicity: If an itemset 
S violates the constraint, so does any of its 
superset  
 Ex. 1. sum(S.price)  v  is anti-monotone 
 Ex. 2. range(S.profit)  15 is anti-monotone 
 Itemset ab violates C 
 So does every superset of ab 
 Ex. 3. sum(S.Price)  v  is not anti-monotone 
 Ex. 4. support count  is anti-monotone: core 
property used in Apriori 
TID Transaction 
10 a, b, c, d, f 
20 b, c, d, f, g, h 
30 a, c, d, e, f 
40 c, e, f, g 
TDB (min_sup=2) 
Item Profit 
a 40 
b 0 
c -20 
d 10 
e -30 
f 30 
g 20 
h -10 
24 
Pattern Space Pruning with Monotonicity Constraints 
 A constraint C is monotone if the pattern 
satisfies C, we do not need to check C in 
subsequent mining 
 Alternatively, monotonicity: If an itemset S 
satisfies the constraint, so does any of its 
superset  
 Ex. 1. sum(S.Price)  v  is monotone 
 Ex. 2. min(S.Price)  v  is monotone 
 Ex. 3. C: range(S.profit)  15 
 Itemset ab satisfies C 
 So does every superset of ab 
TID Transaction 
10 a, b, c, d, f 
20 b, c, d, f, g, h 
30 a, c, d, e, f 
40 c, e, f, g 
TDB (min_sup=2) 
Item Profit 
a 40 
b 0 
c -20 
d 10 
e -30 
f 30 
g 20 
h -10 
25 
Data Space Pruning with Data Anti-monotonicity 
 A constraint c is data anti-monotone if for a pattern 
p cannot satisfy a transaction t under c, p’s 
superset cannot satisfy t under c either 
 The key for data anti-monotone is recursive data 
reduction 
 Ex. 1. sum(S.Price)  v  is data anti-monotone 
 Ex. 2. min(S.Price)  v  is data anti-monotone 
 Ex. 3. C: range(S.profit)  25 is data anti-
monotone 
 Itemset {b, c}’s projected DB:   
 T10’: {d, f, h},  T20’: {d, f, g, h}, T30’: {d, f, g} 
 since C cannot satisfy T10’, T10’ can be pruned 
TID Transaction 
10 a, b, c, d, f, h 
20 b, c, d, f, g, h 
30 b, c, d, f, g 
40 c, e, f, g 
TDB (min_sup=2) 
Item Profit 
a 40 
b 0 
c -20 
d -15 
e -30 
f -10 
g 20 
h -5 
26 
Pattern Space Pruning with Succinctness 
 Succinctness: 
 Given A1, the set of items satisfying a succinctness 
constraint C, then any set S satisfying C is based on 
A1 , i.e., S contains a subset belonging to A1 
 Idea: Without looking at the transaction database, 
whether an itemset S satisfies constraint C can be 
determined based on the selection of items   
 min(S.Price)  v  is succinct 
 sum(S.Price)  v  is not succinct 
 Optimization: If C is succinct, C is pre-counting pushable 
27 
Apriori + Constraint  
TID Items
100 1 3 4
200 2 3 5
300 1 2 3 5
400 2 5
Database D itemset sup.
{1} 2
{2} 3
{3} 3
{4} 1
{5} 3
itemset sup.
{1} 2
{2} 3
{3} 3
{5} 3
Scan D 
C1 
L1 
itemset
{1 2}
{1 3}
{1 5}
{2 3}
{2 5}
{3 5}
itemset sup
{1 2} 1
{1 3} 2
{1 5} 1
{2 3} 2
{2 5} 3
{3 5} 2
itemset sup
{1 3} 2
{2 3} 2
{2 5} 3
{3 5} 2
L2 
C2 C2 
Scan D 
C3 L3 itemset
{2 3 5}
Scan D itemset sup
{2 3 5} 2
Constraint:  
Sum{S.price} < 5 
28 
Constrained Apriori : Push a Succinct Constraint 
Deep  
TID Items
100 1 3 4
200 2 3 5
300 1 2 3 5
400 2 5
Database D itemset sup.
{1} 2
{2} 3
{3} 3
{4} 1
{5} 3
itemset sup.
{1} 2
{2} 3
{3} 3
{5} 3
Scan D 
C1 
L1 
itemset
{1 2}
{1 3}
{1 5}
{2 3}
{2 5}
{3 5}
itemset sup
{1 2} 1
{1 3} 2
{1 5} 1
{2 3} 2
{2 5} 3
{3 5} 2
itemset sup
{1 3} 2
{2 3} 2
{2 5} 3
{3 5} 2
L2 
C2 C2 
Scan D 
C3 L3 itemset
{2 3 5}
Scan D itemset sup
{2 3 5} 2
Constraint:  
min{S.price } <= 1 
not immediately  
to be used 
29 
Constrained FP-Growth: Push a Succinct 
Constraint Deep  
Constraint:  
min{S.price } <= 1 
TID Items
100 1 3 4
200 2 3 5
300 1 2 3 5
400 2 5
TID Items
100 1 3
200 2 3 5
300 1 2 3 5
400 2 5
Remove  
infrequent 
length 1 
FP-Tree 
TID Items
100 3 4
300 2 3 5
1-Projected DB 
No Need to project on 2, 3, or 5 
30 
Constrained FP-Growth: Push a Data 
Anti-monotonic Constraint Deep  
Constraint:  
min{S.price } <= 1 
TID Items
100 1 3 4
200 2 3 5
300 1 2 3 5
400 2 5
TID Items
100 1 3
300 1 3 
FP-Tree 
Single branch, we are done 
Remove from data 
31 
Constrained FP-Growth: Push a Data 
Anti-monotonic Constraint Deep 
Constraint:  
range{S.price } > 25 
min_sup >= 2 
FP-Tree 
TID Transaction 
10 a, c, d, f, h 
20 c, d, f, g, h 
30 c, d, f, g 
B-Projected DB 
B 
FP-Tree 
TID Transaction 
10 a, b, c, d, f, h 
20 b, c, d, f, g, h 
30 b, c, d, f, g 
40 a, c, e, f, g 
TID Transaction 
10 a, b, c, d, f, h 
20 b, c, d, f, g, h 
30 b, c, d, f, g 
40 a, c, e, f, g 
Item Profit 
a 40 
b 0 
c -20 
d -15 
e -30 
f -10 
g 20 
h -5 
Recursive 
Data  
Pruning 
Single branch: 
bcdfg: 2 
32 
Convertible Constraints: Ordering Data in 
Transactions 
 Convert tough constraints into anti-
monotone or monotone by properly 
ordering items 
 Examine C: avg(S.profit)  25 
 Order items in value-descending 
order 
 <a, f, g, d, b, h, c, e> 
 If an itemset afb violates C 
 So does afbh, afb* 
 It becomes anti-monotone! 
TID Transaction 
10 a, b, c, d, f 
20 b, c, d, f, g, h 
30 a, c, d, e, f 
40 c, e, f, g 
TDB (min_sup=2) 
Item Profit 
a 40 
b 0 
c -20 
d 10 
e -30 
f 30 
g 20 
h -10 
33 
Strongly Convertible Constraints 
 avg(X)  25 is convertible anti-monotone w.r.t. 
item value descending order R: <a, f, g, d, b, 
h, c, e> 
 If an itemset af violates a constraint C, so 
does every itemset with af as prefix, such as 
afd  
 avg(X)  25 is convertible monotone w.r.t. item 
value ascending order R-1: <e, c, h, b, d, g, f, 
a> 
 If an itemset d satisfies a constraint C, so 
does itemsets df and dfa, which having d as 
a prefix 
 Thus, avg(X)  25 is strongly convertible 
Item Profit 
a 40 
b 0 
c -20 
d 10 
e -30 
f 30 
g 20 
h -10 
34 
Can Apriori Handle Convertible Constraints? 
 A convertible, not monotone nor anti-monotone 
nor succinct constraint cannot be pushed deep 
into the an Apriori mining algorithm 
 Within the level wise framework, no direct 
pruning based on the constraint can be made 
 Itemset df violates constraint C: avg(X) >= 
25 
 Since adf satisfies C, Apriori needs df to 
assemble adf, df cannot be pruned 
 But it can be pushed into frequent-pattern 
growth framework! 
Item Value 
a 40 
b 0 
c -20 
d 10 
e -30 
f 30 
g 20 
h -10 
35 
Pattern Space Pruning w. Convertible Constraints 
 C: avg(X) >= 25, min_sup=2 
 List items in every transaction in value 
descending order R: <a, f, g, d, b, h, c, e> 
 C is convertible anti-monotone w.r.t. R 
 Scan TDB once 
 remove infrequent items 
 Item h is dropped 
 Itemsets a and f are good, … 
 Projection-based mining 
 Imposing an appropriate order on item 
projection 
 Many tough constraints can be converted into 
(anti)-monotone 
TID Transaction 
10 a, f, d, b, c 
20 f, g, d, b, c 
30  a, f, d, c, e 
40  f, g, h, c, e 
TDB (min_sup=2) 
Item Value 
a 40 
f 30 
g 20 
d 10 
b 0 
h -10 
c -20 
e -30 
36 
Handling Multiple Constraints 
 Different constraints may require different or even 
conflicting item-ordering 
 If there exists an order R s.t. both C1 and C2 are 
convertible w.r.t. R, then there is no conflict between 
the two convertible constraints 
 If there exists conflict on order of items 
 Try to satisfy one constraint first 
 Then using the order for the other constraint to 
mine frequent itemsets in the corresponding 
projected database 
37 
Constraint-Based Mining — A General Picture 
Constraint Anti-monotone Monotone Succinct 
v  S no yes yes 
S  V no yes yes 
S  V yes no yes 
min(S)  v no yes yes 
min(S)  v yes no yes 
max(S)  v yes no yes 
max(S)  v no yes yes 
count(S)  v yes  no weakly 
count(S)  v no yes weakly 
sum(S)  v ( a    S, a  0 ) yes no no 
sum(S)  v ( a    S, a  0 ) no yes no 
range(S)  v yes no no 
range(S)  v no yes no 
avg(S)  v,   { ,  ,   } convertible convertible no 
support(S)     yes no no 
support(S)      no yes no 
38 
What Constraints Are Convertible? 
Constraint 
Convertible anti-
monotone 
Convertible 
monotone 
Strongly 
convertible 
avg(S)  ,  v Yes Yes Yes 
median(S)  ,  v Yes Yes Yes 
sum(S)  v (items could be of any value, 
v  0) 
Yes No No 
sum(S)  v (items could be of any value, 
v  0) 
No Yes No 
sum(S)  v (items could be of any value, 
v  0) 
No Yes No 
sum(S)  v (items could be of any value, 
v  0) 
Yes No No 
…… 
39 
Chapter 7 : Advanced Frequent Pattern Mining 
 Pattern Mining: A Road Map 
 Pattern Mining in Multi-Level, Multi-Dimensional Space 
 Constraint-Based Frequent Pattern Mining 
 Mining High-Dimensional Data and Colossal Patterns 
 Mining Compressed or Approximate Patterns  
 Sequential Pattern Mining 
 Graph Pattern Mining 
 Summary 
40 
Mining Colossal Frequent Patterns 
 F. Zhu, X. Yan, J. Han, P. S. Yu, and H. Cheng, “Mining Colossal 
Frequent Patterns by Core Pattern Fusion”, ICDE'07.  
 We have many algorithms, but can we mine large (i.e., colossal) 
patterns? ― such as just size around 50 to 100?  Unfortunately, not! 
 Why not? ― the curse of “downward closure” of frequent patterns 
 The “downward closure” property 
 Any sub-pattern of a frequent pattern is frequent. 
 Example.  If (a1, a2, …, a100) is frequent, then a1, a2, …, a100, (a1, 
a2), (a1, a3), …, (a1, a100), (a1, a2, a3), … are all frequent!  There 
are about 2100 such frequent itemsets!  
 No matter using breadth-first search (e.g., Apriori) or depth-first 
search (FPgrowth), we have to examine so many patterns 
 Thus the downward closure property leads to explosion! 
41 
Closed/maximal patterns may 
partially alleviate the problem but not 
really solve it: We often need to mine 
scattered large patterns! 
Let the minimum support threshold 
σ= 20 
There are        frequent patterns of 
size 20 
Each is closed and maximal  
# patterns = 
 
The size of the answer set is 
exponential to n 
Colossal Patterns: A Motivating Example 
T1 = 1 2 3 4 ….. 39 40 
T2 = 1 2 3 4 ….. 39 40 
:              . 
:                  . 
:                       . 
:                            . 
T40=1 2 3 4 ….. 39 40 
 






20
40
T1 = 2 3 4 ….. 39 40 
T2 = 1 3 4 ….. 39 40 
:             . 
:                 . 
:                      . 
:                           . 
T40=1 2 3 4 ……  39  
 
nn
n n2
/2
2/






Then delete the items on the diagonal 
Let’s make a set of 40 transactions 
42 
Colossal Pattern Set: Small but Interesting 
 It is often the case that 
only a small number of 
patterns are colossal, 
i.e., of large size 
 
 Colossal patterns are 
usually attached with 
greater importance than 
those of small pattern 
sizes 
43 
Mining Colossal Patterns: Motivation and 
Philosophy 
 Motivation: Many real-world tasks need mining colossal patterns 
 Micro-array analysis in bioinformatics (when support is low) 
 Biological sequence patterns 
 Biological/sociological/information graph pattern mining 
 No hope for completeness 
 If the mining of mid-sized patterns is explosive in size, there is no 
hope to find colossal patterns efficiently by insisting “complete set” 
mining philosophy 
 Jumping out of the swamp of the mid-sized results 
 What we may develop is a philosophy that may jump out of the 
swamp of mid-sized results that are explosive in size and jump to 
reach colossal patterns 
 Striving for mining almost complete colossal patterns 
 The key is to develop a mechanism that may quickly reach colossal 
patterns and discover most of them 
44 
Let the min-support threshold σ= 20 
Then there are         closed/maximal 
frequent patterns of size 20 
However, there is only one with size 
greater than 20, (i.e., colossal): 
α= {41,42,…,79} of size 39 
Alas, A Show of Colossal Pattern Mining! 






20
40T1 = 2 3 4 …..  39 40 
T2 = 1 3 4 …..  39 40 
:             . 
:                 . 
:                      . 
:                           . 
T40=1 2 3 4 ……   39  
 T41= 41 42 43 ….. 79  
T42= 41 42 43 ….. 79  
:             . 
:                 . 
T60= 41 42 43  …  79  
 
The existing fastest mining algorithms 
(e.g., FPClose, LCM) fail to complete 
running 
Our algorithm outputs this colossal 
pattern in seconds 
45 
Methodology of Pattern-Fusion Strategy 
 Pattern-Fusion traverses the tree in a bounded-breadth way 
 Always pushes down a frontier of a bounded-size candidate 
pool  
 Only a fixed number of patterns in the current candidate pool 
will be used as the starting nodes to go down in the pattern tree 
― thus avoids the exponential search space 
 Pattern-Fusion identifies “shortcuts” whenever possible 
 Pattern growth is not performed by single-item addition but by 
leaps and bounded: agglomeration of multiple patterns in the 
pool 
 These shortcuts will direct the search down the tree much more 
rapidly towards the colossal patterns 
46 
Observation: Colossal Patterns and Core Patterns 
A colossal pattern α 
D 
Dα 
α1 
Transaction Database D 
Dα1 
Dα2 
α2 
α 
αk 
Dαk 
Subpatterns α1 to αk cluster tightly around the colossal pattern α by 
sharing a similar support.  We call such subpatterns core patterns of α 
47 
Robustness of Colossal Patterns 
 Core Patterns 
    Intuitively, for a frequent pattern α, a subpattern β is a τ-core 
pattern of α if β shares a similar support set with α, i.e.,  
 
 
where τ is called the core ratio 
 Robustness of Colossal Patterns 
    A colossal pattern is robust in the sense that it tends to have much 
more core patterns than small patterns 


 
||
||
D
D
10 
48 
Example: Core Patterns 
 A colossal pattern has far more core patterns than a small-sized pattern 
 A colossal pattern has far more core descendants of a smaller size c 
 A random draw from a complete set of pattern of size c would more 
likely to pick a core descendant of a colossal pattern 
 A colossal pattern can be generated by merging a set of core patterns 
Transaction (# of Ts) Core Patterns (τ = 0.5) 
(abe) (100) (abe), (ab), (be), (ae), (e) 
(bcf) (100) (bcf), (bc), (bf) 
(acf) (100) (acf), (ac), (af) 
(abcef) (100) (ab), (ac), (af), (ae), (bc), (bf), (be) (ce), (fe), (e), 
(abc), (abf), (abe), (ace), (acf), (afe), (bcf), (bce), 
(bfe), (cfe), (abcf), (abce), (bcfe), (acfe), (abfe), (abcef) 
50 
Colossal Patterns Correspond to Dense Balls 
 Due to their robustness, 
colossal patterns correspond to 
dense balls 
 Ω( 2^d) in population 
 A random draw in the pattern 
space will hit somewhere in the 
ball with high probability 
51 
Idea of Pattern-Fusion Algorithm 
 Generate a complete set of frequent patterns up to a 
small size 
 Randomly pick a pattern β, and β has a high probability to 
be a core-descendant of some colossal pattern α 
 Identify all α’s descendants in this complete set, and 
merge all of them ― This would generate a much larger 
core-descendant of α 
 In the same fashion, we select K patterns.  This set of 
larger core-descendants will be the candidate pool for the 
next iteration 
52 
Pattern-Fusion: The Algorithm 
 Initialization (Initial pool): Use an existing algorithm to 
mine all frequent patterns up to a small size, e.g., 3 
 Iteration (Iterative Pattern Fusion): 
 At each iteration, k seed patterns are randomly picked 
from the current pattern pool 
 For each seed pattern thus picked, we find all the 
patterns within a bounding ball centered at the seed 
pattern 
 All these patterns found are fused together to generate 
a set of super-patterns.  All the super-patterns thus 
generated form a new pool for the next iteration 
 Termination: when the current pool contains no more 
than K patterns at the beginning of an iteration 
53 
Why Is Pattern-Fusion Efficient? 
 A bounded-breadth pattern 
tree traversal 
 It avoids explosion in 
mining mid-sized ones 
 Randomness comes to help 
to stay on the right path 
 Ability to identify “short-cuts” 
and take “leaps” 
 fuse small patterns 
together in one step to 
generate new patterns of 
significant sizes 
 Efficiency  
54 
Pattern-Fusion Leads to Good Approximation 
 Gearing toward colossal patterns 
 The larger the pattern, the greater the chance it will 
be generated 
 Catching outliers 
 The more distinct the pattern, the greater the chance 
it will be generated 
 
55 
Experimental Setting 
 Synthetic data set 
 Diagn an n x (n-1) table where i
th row has integers from 1 to n 
except i.  Each row is taken as an itemset. min_support is n/2. 
 Real data set 
 Replace: A program trace data set collected from the “replace” 
program, widely used in software engineering research 
 ALL: A popular gene expression data set, a clinical data on ALL-AML 
leukemia (www.broad.mit.edu/tools/data.html). 
 Each item is a column, representing the activitiy level of 
gene/protein in the same 
 Frequent pattern would reveal important correlation between 
gene expression patterns and disease outcomes 
56 
Experiment Results on Diagn 
 LCM run time increases 
exponentially with pattern 
size n 
 Pattern-Fusion finishes 
efficiently 
 The approximation error of 
Pattern-Fusion (with min-sup 
20) in comparison with the 
complete set) is rather close 
to uniform sampling (which 
randomly picks K patterns 
from the complete answer 
set) 
57 
Experimental Results on ALL 
 ALL: A popular gene expression data set with 38 
transactions, each with 866 columns 
 There are 1736 items in total 
 The table shows a high frequency threshold of 30 
 
58 
Experimental Results on REPLACE 
 REPLACE 
 A program trace data set, recording 4395 calls 
and transitions 
 The data set contains 4395 transactions with 
57 items in total 
 With support threshold of 0.03, the largest 
patterns are of size 44 
 They are all discovered by Pattern-Fusion with 
different settings of K and τ, when started with 
an initial pool of 20948 patterns of size <=3 
59 
Experimental Results on REPLACE 
 Approximation error when 
compared with the complete 
mining result 
 Example.  Out of the total 98 
patterns of size >=42, when 
K=100, Pattern-Fusion returns 
80 of them 
 A good approximation to the 
colossal patterns in the sense 
that any pattern in the 
complete set is on average at 
most 0.17 items away from one 
of these 80 patterns 
60 
Chapter 7 : Advanced Frequent Pattern Mining 
 Pattern Mining: A Road Map 
 Pattern Mining in Multi-Level, Multi-Dimensional Space 
 Constraint-Based Frequent Pattern Mining 
 Mining High-Dimensional Data and Colossal Patterns 
 Mining Compressed or Approximate Patterns  
 Sequential Pattern Mining 
 Graph Pattern Mining 
 Summary 
61 
Mining Compressed Patterns: δ-clustering  
 Why compressed patterns? 
 too many, but less meaningful 
 Pattern distance measure 
 
 
 δ-clustering: For each pattern P, 
find all patterns which can be 
expressed by P and their distance 
to P are within δ (δ-cover) 
 All patterns in the cluster can be 
represented by P 
 Xin et al., “Mining Compressed 
Frequent-Pattern Sets”, VLDB’05 
ID Item-Sets Support 
P1 {38,16,18,12} 205227 
P2 {38,16,18,12,17} 205211 
P3 {39,38,16,18,12,17} 101758 
P4 {39,16,18,12,17} 161563 
P5 {39,16,18,12} 161576 
 Closed frequent pattern  
 Report P1, P2, P3, P4, P5 
 Emphasize too much on 
support 
 no compression 
 Max-pattern, P3: info loss 
 A desirable output: P2, P3, P4 
 
62 
Redundancy-Award Top-k Patterns 
 Why redundancy-aware top-k patterns? 
 Desired patterns: high 
significance & low 
redundancy 
 Propose the MMS 
(Maximal Marginal 
Significance) for 
measuring the 
combined significance 
of a pattern set  
 Xin et al., Extracting 
Redundancy-Aware 
Top-K Patterns, KDD’06 
63 
Chapter 7 : Advanced Frequent Pattern Mining 
 Pattern Mining: A Road Map 
 Pattern Mining in Multi-Level, Multi-Dimensional Space 
 Constraint-Based Frequent Pattern Mining 
 Mining High-Dimensional Data and Colossal Patterns 
 Mining Compressed or Approximate Patterns  
 Sequential Pattern Mining 
 Graph Pattern Mining 
 Summary 
Sequence Databases & Sequential Patterns 
 Transaction databases, time-series databases vs. sequence 
databases 
 Frequent patterns vs. (frequent) sequential patterns  
 Applications of sequential pattern mining 
 Customer shopping sequences:  
 First buy computer, then CD-ROM, and then digital 
camera, within 3 months. 
 Medical treatments, natural disasters (e.g., earthquakes), 
science & eng. processes, stocks and markets, etc. 
 Telephone calling patterns, Weblog click streams 
 Program execution sequence data sets 
 DNA sequences and gene structures 
What Is Sequential Pattern Mining? 
 Given a set of sequences, find the complete set of 
frequent subsequences 
A sequence database  
A sequence : < (ef) (ab)  (df) c b > 
• An element may contain a set of items 
• Items within an element are unordered 
and we list them alphabetically  
<a(bc)dc> is a subsequence  
of <a(abc)(ac)d(cf)> 
Given support threshold min_sup = 2, <(ab)c> is a 
sequential pattern 
SID sequence 
10 <a(abc)(ac)d(cf)> 
20 <(ad)c(bc)(ae)> 
30 <(ef)(ab)(df)cb> 
40 <eg(af)cbc> 
Sequential pattern mining:  find the complete set of patterns, 
satisfying the minimum support (frequency) threshold 
Sequential Pattern Mining Algorithms 
 Concept introduction and an initial Apriori-like algorithm 
 Agrawal & Srikant: Mining sequential patterns, ICDE’95 
 Requirement: efficient, scalable, complete, minimal database scans, 
and be able to incorporate various kinds of user-specific constraints  
 Representative algorithms 
 GSP (Generalized Sequential Patterns): Srikant & Agrawal @ 
EDBT’96) 
 Vertical format-based mining: SPADE (Zaki@Machine Leanining’00) 
 Pattern-growth methods: PrefixSpan (Pei, Han et al. @ICDE’01) 
 Constraint-based sequential pattern mining (SPIRIT: Garofalakis, 
Rastogi, Shim@VLDB’99; Pei, Han, Wang @ CIKM’02) 
 Mining closed sequential patterns: CloSpan (Yan, Han et al. @SDM’03) 
The Apriori Property of Sequential Patterns 
 A basic property: Apriori (Agrawal & Sirkant’94)  
 If a sequence S is not frequent  
 Then none of the super-sequences of S is frequent 
 E.g, <hb> is infrequent  so do <hab> and <(ah)b> 
<a(bd)bcb(ade)> 50 
<(be)(ce)d> 40 
<(ah)(bf)abf> 30 
<(bf)(ce)b(fg)> 20 
<(bd)cb(ac)> 10 
Sequence Seq. ID Given support threshold 
min_sup =2  
GSP—Generalized Sequential Pattern Mining 
 GSP (Generalized Sequential Pattern) mining algorithm 
 proposed by Agrawal and Srikant, EDBT’96 
 Outline of the method 
 Initially, every item in DB is a candidate of length-1 
 for each level (i.e., sequences of length-k) do 
 scan database to collect support count for each 
candidate sequence 
 generate candidate length-(k+1) sequences from 
length-k frequent sequences using Apriori  
 repeat until no frequent sequence or no candidate can 
be found 
 Major strength: Candidate pruning by Apriori 
Finding Length-1 Sequential Patterns 
 Examine GSP using an example  
 Initial candidates: all singleton sequences 
 <a>, <b>, <c>, <d>, <e>, <f>, <g>, <h> 
 Scan database once, count support for candidates 
<a(bd)bcb(ade)> 50 
<(be)(ce)d> 40 
<(ah)(bf)abf> 30 
<(bf)(ce)b(fg)> 20 
<(bd)cb(ac)> 10 
Sequence Seq. ID 
min_sup =2  
Cand Sup 
<a> 3 
<b> 5 
<c> 4 
<d> 3 
<e> 3 
<f> 2 
<g> 1 
<h> 1 
GSP: Generating Length-2 Candidates 
<a> <b> <c> <d> <e> <f> 
<a> <aa> <ab> <ac> <ad> <ae> <af> 
<b> <ba> <bb> <bc> <bd> <be> <bf> 
<c> <ca> <cb> <cc> <cd> <ce> <cf> 
<d> <da> <db> <dc> <dd> <de> <df> 
<e> <ea> <eb> <ec> <ed> <ee> <ef> 
<f> <fa> <fb> <fc> <fd> <fe> <ff> 
<a> <b> <c> <d> <e> <f> 
<a> <(ab)> <(ac)> <(ad)> <(ae)> <(af)> 
<b> <(bc)> <(bd)> <(be)> <(bf)> 
<c> <(cd)> <(ce)> <(cf)> 
<d> <(de)> <(df)> 
<e> <(ef)> 
<f> 
51 length-2 
Candidates 
Without Apriori 
property, 
8*8+8*7/2=92 
candidates 
Apriori prunes  
44.57% candidates 
The GSP Mining Process 
<a> <b> <c> <d> <e> <f> <g> <h> 
<aa> <ab> … <af> <ba> <bb> … <ff> <(ab)> … <(ef)> 
<abb> <aab> <aba> <baa> <bab> … 
<abba> <(bd)bc> … 
<(bd)cba> 
1st scan: 8 cand. 6 length-1 seq. 
pat. 
2nd scan: 51 cand. 19 length-2 seq. 
pat. 10 cand. not in DB at all 
3rd scan: 46 cand. 19 length-3 seq. 
pat. 20 cand. not in DB at all 
4th scan: 8 cand. 6 length-4 seq. 
pat.  
5th scan: 1 cand. 1 length-5 seq. 
pat.  
Cand. cannot pass 
sup. threshold 
Cand. not in DB at all 
<a(bd)bcb(ade)> 50 
<(be)(ce)d> 40 
<(ah)(bf)abf> 30 
<(bf)(ce)b(fg)> 20 
<(bd)cb(ac)> 10 
Sequence Seq. ID 
min_sup =2  
The SPADE Algorithm 
 SPADE (Sequential PAttern Discovery using Equivalent 
Class) developed by Zaki 2001 
 A vertical format sequential pattern mining method 
 A sequence database is mapped to a large set of  
 Item: <SID, EID> 
 Sequential pattern mining is performed by  
 growing the subsequences (patterns) one item at a 
time by Apriori candidate generation 
73 
The SPADE Algorithm 
Bottlenecks of GSP and SPADE 
 A huge set of candidates could be generated 
 1,000 frequent length-1 sequences generate s huge number of 
length-2 candidates! 
 Multiple scans of database in mining 
 Breadth-first search 
 Mining long sequential patterns by growing from shorter patterns  
 Needs an exponential number of short candidates 
 A length-100 sequential pattern needs 1030                                          
candidate sequences! 
500,499,1
2
9991000
10001000 


30100
100
1
1012
100







i i
PrefixSpan: Mining Sequential Patterns by 
Prefix Projections 
 PrefixSpan Mining framework 
 Step 1: find length-1 sequential patterns 
 <a>, <b>, <c>, <d>, <e>, <f> 
 Step 2: divide search space. The complete set of seq. pat. can 
be partitioned into 6 subsets: 
 The ones having prefix <a>; 
 The ones having prefix <b>; 
 … 
 The ones having prefix <f> 
SID sequence 
10 <a(abc)(ac)d(cf)> 
20 <(ad)c(bc)(ae)> 
30 <(ef)(ab)(df)cb> 
40 <eg(af)cbc> 
Prefix Suffix (Prefix-Based Projection) 
<a> <(abc)(ac)d(cf)> 
<aa> <(_bc)(ac)d(cf)> 
<ab> <(_c)(ac)d(cf)> 
 Prefix and suffix 
 Given sequence <a(abc)(ac)d(cf)> 
 Prefixes: <a>, <aa>, <a(ab)> 
and <a(abc)> 
Finding Seq. Patterns with Prefix <a> 
 Only need to consider projections w.r.t. <a> 
 <a>-projected database:  
 <(abc)(ac)d(cf)> 
  <(_d)c(bc)(ae)> 
 <(_b)(df)cb> 
 <(_f)cbc> 
 Find all the length-2 seq. pat. Having prefix <a>: <aa>, 
<ab>, <(ab)>, <ac>, <ad>, <af> 
 Further partition into 6 subsets 
 Having prefix <aa>; 
 … 
 Having prefix <af> 
SID sequence 
10 <a(abc)(ac)d(cf)> 
20 <(ad)c(bc)(ae)> 
30 <(ef)(ab)(df)cb> 
40 <eg(af)cbc> 
Completeness of PrefixSpan 
SID sequence 
10 <a(abc)(ac)d(cf)> 
20 <(ad)c(bc)(ae)> 
30 <(ef)(ab)(df)cb> 
40 <eg(af)cbc> 
SDB 
Length-1 sequential patterns 
<a>, <b>, <c>, <d>, <e>, <f> 
<a>-projected database 
<(abc)(ac)d(cf)> 
<(_d)c(bc)(ae)> 
<(_b)(df)cb> 
<(_f)cbc> 
Length-2 sequential 
patterns 
<aa>, <ab>, <(ab)>, 
<ac>, <ad>, <af> 
Having prefix <a> 
Having prefix <aa> 
<aa>-proj. db … <af>-proj. db 
Having prefix <af> 
<b>-projected database … 
Having prefix <b> 
Having prefix <c>, …, <f> 
… … 
Major strength of PrefixSpan: 
• No candidate sequence needs to be generated 
• Projected databases keep shrinking 
Speed-up by Pseudo-Projection 
 Major cost of PrefixSpan: Constructing projected databases 
 Postfixes of sequences often appear repeatedly in 
recursive projected databases 
 When (projected) database can be held in main memory, 
use pointers to form pseudo-projections 
 Pointer to the sequence 
 Offset of the postfix 
s=<a(abc)(ac)d(cf)> 
<(abc)(ac)d(cf)> 
<(_c)(ac)d(cf)> 
<a> 
<ab> 
s|<a>: ( , 2) 
s|<ab>: ( , 4) 
Pseudo-Projection vs. Physical Projection 
 Pseudo-projection avoids physically copying postfixes 
 Efficient in running time and space when database 
can be held in main memory 
 However, it is not efficient when database cannot fit in 
main memory 
 Disk-based random accessing is very costly 
 Suggested Approach: 
 Integration of physical and pseudo-projection 
 Swapping to pseudo-projection when the data set fits 
in memory 
Performance of Sequential Pattern Mining 
Algorithms 
Performance comparison: 
with pseudo-projection vs. 
without pseudo-projection 
Performance comparison 
on Gazelle data set 
Performance comparison 
on data set C10T8S8I8 
CloSpan: Mining Closed Sequential Patterns 
 A closed sequential pattern s: there 
exists no superpattern s’ such that s’  כ 
s, and s’ and s have the same support  
 Which one is closed?  <abc>: 20, 
<abcd>:20, <abcde>: 15  
 Why mine close seq. patterns? 
 Reduces the number of (redundant) 
patterns but attains the same 
expressive power 
 Property: If s’  כ s, closed iff two 
project DBs have the same size 
 Using Backward Subpattern and 
Backward Superpattern pruning to 
prune redundant search space 
Performance Comparison: CloSpan vs. PrefixSpan 
Constraint-Based Seq.-Pattern Mining 
 Constraint-based sequential pattern mining 
 Constraints: User-specified, for focused mining of desired 
patterns 
 How to explore efficient mining with constraints? — 
Optimization  
 Classification of constraints 
 Anti-monotone: E.g., value_sum(S) < 150, min(S) > 10  
 Monotone: E.g., count (S) > 5, S  {PC, digital_camera} 
 Succinct: E.g., length(S)  10, S  {Pentium, MS/Office, 
MS/Money}  
 Convertible:  E.g., value_avg(S) < 25, profit_sum (S) > 
160, max(S)/avg(S) < 2, median(S) –  min(S) > 5 
 Inconvertible: E.g., avg(S) – median(S) = 0  
From Sequential Patterns to Structured Patterns 
 Sets, sequences, trees, graphs, and other structures  
 Transaction DB: Sets of items  
 {{i1, i2, …, im}, …} 
 Seq. DB: Sequences of sets:  
 {<{i1, i2}, …, {im, in, ik}>, …} 
 Sets of Sequences:  
 {{<i1, i2>, …, <im, in, ik>}, …} 
 Sets of trees: {t1, t2, …, tn} 
 Sets of graphs (mining for frequent subgraphs):  
 {g1, g2, …, gn} 
 Mining structured patterns in XML documents, bio-
chemical structures, etc. 
Alternative to Sequential Patterns: Episodes 
and Episode Pattern Mining 
 Alternative patterns: Episodes and regular expressions 
 Serial episodes: A  B 
 Parallel episodes: A & B 
 Regular expressions: (A|B)C*(D  E) 
 Methods for episode pattern mining 
 Method 1: Variations of Apriori/GSP-like algorithms 
 Method 2: Projection-based pattern growth 
 Can you work out the details? 
 Question: What is the difference between mining 
episodes and constraint-based pattern mining? 
86 
Chapter 7 : Advanced Frequent Pattern Mining 
 Pattern Mining: A Road Map 
 Pattern Mining in Multi-Level, Multi-Dimensional Space 
 Constraint-Based Frequent Pattern Mining 
 Mining High-Dimensional Data and Colossal Patterns 
 Mining Compressed or Approximate Patterns  
 Sequential Pattern Mining 
 Graph Pattern Mining 
 Summary 
Graph Pattern Mining 
 Frequent subgraphs 
 A (sub)graph is frequent if its support (occurrence 
frequency) in a given dataset is no less than a 
minimum support threshold 
 Applications of graph pattern mining 
 Mining biochemical structures 
 Program control flow analysis 
 Mining XML structures or Web communities 
 Building blocks for graph classification, clustering, 
compression, comparison, and correlation analysis 
Example: Frequent Subgraphs 
GRAPH DATASET 
FREQUENT PATTERNS 
(MIN SUPPORT IS 2) 
(A) (B) (C) 
(1) (2) 
89 
Properties of Graph Mining Algorithms 
 Search order 
 breadth vs. depth 
 Generation of candidate subgraphs 
 apriori vs. pattern growth 
 Elimination of duplicate subgraphs 
 passive vs. active 
 Support calculation 
 embedding store or not 
 Discover order of patterns 
 path  tree  graph 
90 
Apriori-Based Approach 
… 
G 
G1 
G2 
Gn 
k-edge 
(k+1)-edge 
G’ 
G’’ 
JOIN 
91 
Apriori-Based, Breadth-First Search 
 AGM (Inokuchi, et al. PKDD’00)  
 generates new graphs with one more node 
 Methodology: breadth-search, joining two graphs  
 FSG (Kuramochi and Karypis ICDM’01) 
 generates new graphs with one more edge 
92 
Pattern Growth Method 
… 
G 
G1 
G2 
Gn 
k-edge 
(k+1)-edge 
… 
(k+2)-edge 
… 
duplicate  
graph 
93 
GSPAN (Yan and Han ICDM’02) 
Right-Most Extension 
Theorem: Completeness 
The Enumeration of Graphs  
using Right-most Extension is  
COMPLETE 
94 
DFS Code 
 Flatten a graph into a sequence using depth first 
search 
0 
1 
2 
3 
4 
e0: (0,1) 
e1: (1,2) 
e2: (2,0) 
e3: (2,3) 
e4: (3,1) 
e5: (2,4) 
95 
DFS Lexicographic Order 
 Let Z be the set of DFS codes of all graphs.  Two DFS 
codes a and b have the relation a<=b (DFS 
Lexicographic Order in Z) if and only if one of the 
following conditions is true.  Let 
        a = (x0, x1, …, xn) and  
        b = (y0, y1, …, yn), 
(i) if there exists t, 0<= t <= min(m,n), xk=yk for all 
k, s.t. k<t, and xt < yt 
(ii) xk=yk for all k, s.t.  0<= k<= m and m <= n. 
96 
DFS Code Extension 
 Let a be the minimum DFS code of a graph G and b be 
a non-minimum DFS code of G.  For any DFS code d 
generated from b by one right-most extension, 
(i) d is not a minimum DFS code, 
(ii) min_dfs(d) cannot be extended from b, and 
(iii) min_dfs(d) is either less than a or can be 
extended from a. 
THEOREM [ RIGHT-EXTENSION ] 
The DFS code of a graph extended from a  
Non-minimum DFS code is NOT MINIMUM 
97 
GASTON (Nijssen and Kok KDD’04) 
 Extend graphs directly 
 Store embeddings 
 Separate the discovery of different types of 
graphs 
 path  tree  graph 
 Simple structures are easier to mine and 
duplication detection is much simpler 
98 
Graph Pattern Explosion Problem 
 If a graph is frequent, all of its subgraphs are 
frequent ─ the Apriori property  
 An n-edge frequent graph may have 2n 
subgraphs 
 Among 422 chemical compounds which are 
confirmed to be active in an AIDS antiviral 
screen dataset, there are 1,000,000 frequent 
graph patterns if the minimum support is 5% 
 
99 
Closed Frequent Graphs 
 Motivation:  Handling graph pattern explosion 
problem 
 Closed frequent graph 
 A frequent graph G is closed if there exists no 
supergraph of G that carries the same support 
as G 
 If some of G’s subgraphs have the same support, 
it is unnecessary to output these subgraphs 
(nonclosed graphs) 
 Lossless compression: still ensures that the 
mining result is complete 
100 
CLOSEGRAPH (Yan & Han, KDD’03) 
… 
A Pattern-Growth Approach 
G 
G1 
G2 
Gn 
k-edge 
(k+1)-edge  
At what condition, can we 
stop searching their children 
i.e., early termination? 
 
If G and G’ are frequent, G is a 
subgraph of G’.  If in any part 
of the graph in the dataset 
where G occurs, G’ also 
occurs, then we need not grow 
G, since none of G’s children will 
be closed except those of G’. 
101 
Handling Tricky Exception Cases 
(graph 1) 
a 
c 
b 
d 
(pattern 2) 
(pattern 1) 
(graph 2) 
a 
c 
b 
d 
a b 
a 
c 
d 
102 
Experimental Result 
 The AIDS antiviral screen compound dataset 
from NCI/NIH 
 The dataset contains 43,905 chemical 
compounds 
 Among these 43,905 compounds, 423 of them 
belongs to CA, 1081 are of CM, and the 
remaining are in class CI 
103 
Discovered Patterns 
20% 10% 
5% 
104 
Performance (1): Run Time 
Minimum support (in %) 
R
u
n
 t
im
e
 p
e
r
 p
a
tt
e
r
n
 
(
m
s
e
c
)
 
105 
Performance (2): Memory Usage 
Minimum support (in %) 
M
e
m
o
r
y
 u
s
a
g
e
 (
G
B
)
 
106 
Performance Comparison: Frequent vs. Closed 
CA 
1.0E+02
1.0E+03
1.0E+04
1.0E+05
1.0E+06
0.05 0.06 0.07 0.08 0.1
frequent graphs
closed frequent graphs
Minimum support 
N
u
m
b
e
r
 o
f 
p
a
tt
e
r
n
s
 
# of Patterns: Frequent vs. Closed 
1
10
100
1000
10000
0.05 0.06 0.07 0.08 0.1
FSG
Gspan
CloseGraph
Minimum support 
R
u
n
 t
im
e
 (
s
e
c
)
 
Runtime: Frequent vs. Closed 
CA 
107 
Chapter 7 : Advanced Frequent Pattern Mining 
 Pattern Mining: A Road Map 
 Pattern Mining in Multi-Level, Multi-Dimensional Space 
 Constraint-Based Frequent Pattern Mining 
 Mining High-Dimensional Data and Colossal Patterns 
 Mining Compressed or Approximate Patterns  
 Pattern Exploration and Application 
 Summary 
108 
Summary 
 Roadmap: Many aspects & extensions on pattern mining  
 Mining patterns in multi-level, multi dimensional space 
 Mining rare and negative patterns 
 Constraint-based pattern mining 
 Specialized methods for mining high-dimensional data 
and colossal patterns 
 Mining compressed or approximate patterns  
 Pattern exploration and understanding: Semantic 
annotation of frequent patterns  
  
109 
110 
Ref: Mining Multi-Level and Quantitative Rules 
 R. Srikant and R. Agrawal. Mining generalized association rules. 
VLDB'95. 
 J. Han and Y. Fu. Discovery of multiple-level association rules from 
large databases. VLDB'95. 
 R. Srikant and R. Agrawal. Mining quantitative association rules in 
large relational tables. SIGMOD'96. 
 T. Fukuda, Y. Morimoto, S. Morishita, and T. Tokuyama. Data mining 
using two-dimensional optimized association rules: Scheme, 
algorithms, and visualization. SIGMOD'96. 
 K. Yoda, T. Fukuda, Y. Morimoto, S. Morishita, and T. Tokuyama. 
Computing optimized rectilinear regions for association rules. KDD'97. 
 R.J. Miller and Y. Yang.  Association rules over interval data.  
SIGMOD'97. 
 Y. Aumann and Y. Lindell. A Statistical Theory for Quantitative 
Association Rules KDD'99.  
111 
Ref: Mining Other Kinds of Rules 
 R. Meo, G. Psaila, and S. Ceri.  A new SQL-like operator for mining 
association rules. VLDB'96. 
 B. Lent, A. Swami, and J. Widom.  Clustering association rules. 
ICDE'97. 
 A. Savasere, E. Omiecinski, and S. Navathe.  Mining for strong 
negative associations in a large database of customer transactions. 
ICDE'98. 
 D. Tsur, J. D. Ullman, S. Abitboul, C. Clifton, R. Motwani, and S. 
Nestorov.   Query flocks: A generalization of association-rule mining. 
SIGMOD'98. 
 F. Korn, A. Labrinidis, Y. Kotidis, and C. Faloutsos.  Ratio rules: A new 
paradigm for fast, quantifiable data mining. VLDB'98. 
 F. Zhu, X. Yan, J. Han, P. S. Yu, and H. Cheng, “Mining Colossal 
Frequent Patterns by Core Pattern Fusion”, ICDE'07.  
112 
Ref: Constraint-Based Pattern Mining 
 R. Srikant, Q. Vu, and R. Agrawal. Mining association rules with item 
constraints.  KDD'97 
 R. Ng, L.V.S. Lakshmanan, J. Han & A. Pang. Exploratory mining and 
pruning optimizations of constrained association rules. SIGMOD’98 
 G. Grahne, L. Lakshmanan, and X. Wang.  Efficient mining of 
constrained correlated sets. ICDE'00 
 J. Pei, J. Han, and L. V. S. Lakshmanan.  Mining Frequent Itemsets 
with Convertible Constraints. ICDE'01 
 J. Pei, J. Han, and W. Wang, Mining Sequential Patterns with 
Constraints in Large Databases, CIKM'02 
 F. Bonchi, F. Giannotti, A. Mazzanti, and D. Pedreschi. ExAnte: 
Anticipated Data Reduction in Constrained Pattern Mining, PKDD'03 
 F. Zhu, X. Yan, J. Han, and P. S. Yu, “gPrune: A Constraint Pushing 
Framework for Graph Pattern Mining”, PAKDD'07 
113 
Ref: Mining Sequential and Structured Patterns 
 R. Srikant and R. Agrawal. Mining sequential patterns: Generalizations 
and performance improvements. EDBT’96. 
 H. Mannila, H Toivonen, and A. I. Verkamo. Discovery of frequent 
episodes in event sequences. DAMI:97. 
 M. Zaki. SPADE: An Efficient Algorithm for Mining Frequent Sequences. 
Machine Learning:01. 
 J. Pei, J. Han, H. Pinto, Q. Chen, U. Dayal, and M.-C. Hsu.  PrefixSpan: 
Mining Sequential Patterns Efficiently by Prefix-Projected Pattern 
Growth.  ICDE'01. 
 M. Kuramochi and G. Karypis.  Frequent Subgraph Discovery.  ICDM'01. 
 X. Yan, J. Han, and R. Afshar.  CloSpan: Mining Closed Sequential 
Patterns in Large Datasets.  SDM'03. 
 X. Yan and J. Han.  CloseGraph: Mining Closed Frequent Graph 
Patterns.  KDD'03. 
114 
Ref: Mining Spatial, Multimedia, and Web Data 
 K. Koperski and J. Han, Discovery of Spatial Association Rules in 
Geographic Information Databases,  SSD’95. 
 O. R. Zaiane, M. Xin, J. Han, Discovering Web Access Patterns and 
Trends by Applying OLAP and Data Mining Technology on Web Logs. 
ADL'98. 
 O. R. Zaiane, J. Han, and H. Zhu, Mining Recurrent Items in 
Multimedia with Progressive Resolution Refinement.  ICDE'00. 
 D. Gunopulos and I. Tsoukatos.  Efficient Mining of Spatiotemporal 
Patterns.   SSTD'01. 
115 
Ref: Mining Frequent Patterns in Time-Series Data 
 B. Ozden, S. Ramaswamy, and A. Silberschatz. Cyclic association rules. 
ICDE'98. 
 J. Han, G. Dong and Y. Yin, Efficient Mining of Partial Periodic Patterns 
in Time Series Database, ICDE'99. 
 H. Lu, L. Feng, and J. Han.  Beyond Intra-Transaction Association 
Analysis: Mining Multi-Dimensional Inter-Transaction Association Rules.  
TOIS:00. 
 B.-K. Yi, N. Sidiropoulos, T. Johnson, H. V. Jagadish, C. Faloutsos, and 
A. Biliris. Online Data Mining for Co-Evolving Time Sequences. ICDE'00. 
 W. Wang, J. Yang, R. Muntz. TAR: Temporal Association Rules on 
Evolving Numerical Attributes. ICDE’01. 
 J. Yang, W. Wang, P. S. Yu. Mining Asynchronous Periodic Patterns in 
Time Series Data. TKDE’03. 
116 
Ref: FP for Classification and Clustering 
 G. Dong and J. Li. Efficient mining of emerging patterns: 
Discovering trends and differences.  KDD'99. 
 B. Liu, W. Hsu, Y. Ma. Integrating Classification and Association 
Rule Mining.  KDD’98. 
 W. Li, J. Han, and J. Pei.  CMAR: Accurate and Efficient 
Classification Based on Multiple Class-Association Rules.  ICDM'01. 
 H. Wang, W. Wang, J. Yang, and P.S. Yu.  Clustering by pattern 
similarity in large data sets.  SIGMOD’ 02.  
 J. Yang and W. Wang.  CLUSEQ: efficient and effective sequence 
clustering. ICDE’03.  
 X. Yin and J. Han. CPAR: Classification based on Predictive 
Association Rules.  SDM'03. 
 H. Cheng, X. Yan, J. Han, and C.-W. Hsu, Discriminative Frequent 
Pattern Analysis for Effective Classification”, ICDE'07. 
117 
Ref: Stream and Privacy-Preserving FP Mining 
 A. Evfimievski, R. Srikant, R. Agrawal, J. Gehrke.  Privacy Preserving 
Mining of Association Rules.  KDD’02. 
 J. Vaidya and C. Clifton.  Privacy Preserving Association Rule Mining 
in Vertically Partitioned Data.  KDD’02.  
 G. Manku and R. Motwani.   Approximate Frequency Counts over 
Data Streams.  VLDB’02. 
 Y. Chen, G. Dong, J. Han, B. W. Wah, and J. Wang.  Multi-
Dimensional Regression Analysis of Time-Series Data Streams.  
VLDB'02. 
 C. Giannella, J. Han, J. Pei, X. Yan and P. S. Yu.  Mining Frequent 
Patterns in Data Streams at Multiple Time Granularities, Next 
Generation Data Mining:03. 
 A. Evfimievski, J. Gehrke, and R. Srikant.  Limiting Privacy Breaches 
in Privacy Preserving Data Mining.  PODS’03.  
118 
Ref: Other Freq. Pattern Mining Applications 
 Y. Huhtala, J. Kärkkäinen, P. Porkka, H. Toivonen. Efficient 
Discovery of Functional and Approximate Dependencies Using 
Partitions. ICDE’98.  
 H. V. Jagadish, J. Madar, and R. Ng. Semantic Compression and 
Pattern Extraction with Fascicles.  VLDB'99. 
 T. Dasu, T. Johnson, S. Muthukrishnan, and V. Shkapenyuk. 
Mining Database Structure; or How to Build a Data Quality 
Browser. SIGMOD'02. 
 K. Wang, S. Zhou, J. Han.  Profit Mining: From Patterns to Actions. 
EDBT’02. 
Ref: Mining Sequential Patterns 
 R. Srikant and R. Agrawal. Mining sequential patterns: Generalizations and performance 
improvements. EDBT’96. 
 H. Mannila, H Toivonen, and A. I. Verkamo. Discovery of frequent episodes in event 
sequences. DAMI:97. 
 M. Zaki. SPADE: An Efficient Algorithm for Mining Frequent Sequences. Machine Learning, 
2001. 
 J. Pei, J. Han, H. Pinto, Q. Chen, U. Dayal, and M.-C. Hsu. PrefixSpan: Mining Sequential 
Patterns Efficiently by Prefix-Projected Pattern Growth.  ICDE'01 (TKDE’04). 
 J. Pei, J. Han and W. Wang, Constraint-Based Sequential Pattern Mining in Large 
Databases, CIKM'02. 
 X. Yan, J. Han, and R. Afshar.  CloSpan: Mining Closed Sequential Patterns in Large 
Datasets.  SDM'03. 
 J. Wang and J. Han, BIDE: Efficient Mining of Frequent Closed Sequences, ICDE'04. 
 H. Cheng, X. Yan, and J. Han, IncSpan: Incremental Mining of Sequential Patterns in 
Large Database, KDD'04. 
 J. Han, G. Dong and Y. Yin, Efficient Mining of Partial Periodic Patterns in Time Series 
Database, ICDE'99. 
 J. Yang, W. Wang, and P. S. Yu, Mining asynchronous periodic patterns in time series 
data, KDD'00. 
October 22, 2013 Data Mining: Concepts and Techniques 120 
121 
Chapter 7 : Advanced Frequent Pattern Mining 
 Frequent Pattern and Association Mining: A Road Map 
 Pattern Mining in Multi-Level, Multi-Dimensional Space  
 Mining Multilevel Association 
 Mining Multi-Dimensional Association 
 Mining Quantitative Association Rules 
 Exploring Alternative Approaches to Improve Efficiency and Scalability 
 Mining Closed and Max Patterns  
 Scalable Pattern Mining in High-Dimensional Data  
 Mining Colossal Patterns  
 Mining Beyond Typical Frequent Patterns  
  Mining Infrequent and Negative Patterns  
  Mining Compressed and Approximate Patterns  
  Constraint-Based Frequent Pattern Mining  
  Metarule-Guided Mining of Association Rules  
  Constraint-Based Pattern Generation: Montonicity, Anti-monotonicity, 
Succinctness, and Data Anti-monotonicity  
  Convertible Constraints: Ordering Data in Transactions  
  Advanced Applications of Frequent Patterns  
  Towards pattern-based classification and cluster analysis  
  Context Analysis: Generating Semantic Annotations for Frequent Patterns 
 Summary 
122 
Chapter 7 : Advanced Frequent Pattern Mining 
 Pattern Mining: A Road Map 
 Pattern Mining in Multi-Level, Multi-Dimensional Space 
 Constraint-Based Frequent Pattern Mining 
 Mining High-Dimensional Data and Colossal Patterns 
 Mining Compressed or Approximate Patterns  
 Pattern Exploration and Application 
 Summary 
  
 Do they all make sense? 
 What do they mean? 
 How are they useful? 
diaper beer 
female sterile (2) tekele 
Annotate patterns with semantic information 
morphological info. and simple statistics 
Semantic Information 
Not all frequent patterns are useful, only meaningful ones … 
How to Understand and Interpret Patterns? 
Word: “pattern” – from Merriam-Webster 
A Dictionary Analogy 
Non-semantic info. 
Examples of Usage 
Definitions indicating  
semantics 
Synonyms 
Related Words 
Semantic Analysis with Context Models 
 Task1: Model the context of a frequent pattern 
Based on the Context Model … 
 Task2: Extract strongest context indicators  
 Task3: Extract representative transactions  
 Task4: Extract semantically similar patterns 
Annotating DBLP Co-authorship & Title Pattern 
Substructure Similarity Search  
in Graph Databases  
X.Yan, P. Yu, J. Han 
… … 
… … 
Database: 
Title Authors 
Frequent Patterns 
P1:   { x_yan, j_han } 
Frequent Itemset 
P2:  “substructure search” 
Pattern { x_yan, j_han} 
Non Sup = … 
CI {p_yu}, graph pattern, … 
Trans. gSpan: graph-base…… 
SSPs { j_wang }, {j_han, p_yu}, … 
Semantic Annotations 
Context Units 
 <  { p_yu, j_han},  { d_xin }, … , “graph pattern”,  
… “substructure similarity”, … > 
Pattern = {xifeng_yan, jiawei_han}  Annotation Results: 
Context Indicator (CI) graph; {philip_yu}; mine close; graph pattern; sequential pattern; … 
Representative 
Transactions (Trans) 
> gSpan: graph-base substructure pattern mining; 
> mining close relational graph connect constraint; … 
Semantically Similar 
Patterns (SSP) 
{jiawei_han, philip_yu}; {jian_pei, jiawei_han}; {jiong_yang, philip_yu, 
wei_wang}; … 
Frequent Subgraph Mining Approaches 
 Apriori-based approach 
 AGM/AcGM: Inokuchi, et al. (PKDD’00) 
 FSG: Kuramochi and Karypis (ICDM’01) 
 PATH#: Vanetik and Gudes (ICDM’02, ICDM’04) 
 FFSM: Huan, et al. (ICDM’03) 
 Pattern growth approach 
 MoFa, Borgelt and Berthold (ICDM’02) 
 gSpan: Yan and Han (ICDM’02) 
 Gaston: Nijssen and Kok (KDD’04) 
128 
PATH (Vanetik and Gudes ICDM’02, ’04) 
 Apriori-based approach 
 Building blocks: edge-disjoint path 
A graph with 3 edge-disjoint  
paths 
• construct frequent paths 
• construct frequent graphs with 
2 edge-disjoint paths 
• construct graphs with k+1 
edge-disjoint paths from 
graphs with k edge-disjoint 
paths 
• repeat 
129 
FFSM (Huan, et al. ICDM’03) 
 Represent graphs using canonical adjacency matrix 
(CAM) 
 Join two CAMs or extend a CAM to generate a new 
graph 
 Store the embeddings of CAMs 
 All of the embeddings of a pattern in the database 
 Can derive the embeddings of newly generated CAMs 
130 
MoFa (Borgelt and Berthold ICDM’02) 
 Extend graphs by adding a new edge 
 Store embeddings of discovered frequent graphs 
 Fast support calculation 
 Also used in other later developed algorithms 
such as FFSM and GASTON 
 Expensive Memory usage  
 Local structural pruning 
 
