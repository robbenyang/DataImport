1 
Number  Systems  (in  Binary)	  
2 
Today’s  lecture  
  Represen:ng  things  with  bits  
  N	  bits	  gets	  you	  2N	  representa0ons  
  Unsigned  binary  number  representa:on  
  Conver0ng	  between	  binary	  and	  decimal	  
  Hexadecimal	  nota0on	  
  Binary  Addi:on  &  Bitwise  Logical  Opera:ons  
  Every	  opera0on	  has	  a	  width	  
  Two’s  complement  signed  binary  representa:on  
3 
Represen:ng  things  as  bits  
  We  said  everything  in  computers  is  bits  (e.g.,  1’s  and  0’s)  
  We  do  this  by  associa:ng  a  paIern  of  bits  with  a  thing  
(like  a  secret  decoder  ring…)  
  
  This  mapping  however  is  rarely  stored  explicitly  
  Rather	  it	  is	  used	  when	  we	  interpret	  the	  bits.	  
Bit pattern Marine Mammal 
0100101 Humpback Whale 
0100110 Leopard Seal 
0100111 Sea Otter 
0101000 West Indian Manatee 
0101001 Bottlenose Dolphin 
4 
How  many  bits  to  encode  N  possible  things?  
  1  bit  can  encode  2  possibili:es  (0,  1)  
1  
0  
Bits  =  1  
#  encodings  =  2  
5 
Represen:ng  Unsigned  numbers  
  Unsigned  numbers  are  the  set  of  non-­‐nega:ve  numbers:  
  0,	  1,	  2,	  3,	  4,	  5,	  …	  
  We  can  only  represent  a  range  of  these  numbers  
  Based	  on	  the	  #	  of	  bits	  we’re	  using	  to	  store	  the	  range	  
  3	  bits	  	  0	  –	  7	  	  (8  representa5ons)	  
  8	  bits	  	  0	  –	  255	  	  (256  representa5ons)	  
  But  what  encoding  should  we  use?    
6 
Decimal  review  
  Numbers  consist  of  a  bunch  of  digits,  each  with  a  weight:  
  The  weights  are  all  powers  of  the  base,  which  is  10.  We  
can  rewrite  the  weights  like  this:  
  To  find  the  decimal  value  of  a  number,  mul:ply  each  digit  
by  its  weight  and  sum  the  products.    
1" 6" 2" ." 3" 7" 5" Digits"
100" 10" 1" " 1/10" " 1/100" 1/1000" Weights"
"
"
1" 6" 2" ." 3" 7" 5" Digits"
102" 101" 100" " 10/1" 10/2" 10/3" Weights"
"
"
(1  x  102)  +  (6  x  101)  +  (2  x  100)  +  (3  x  10-­‐1)  +  (7  x  10-­‐2)  +  (5  x  10-­‐3)  =  162.375  
Consider    162.375  
7 
Unsigned  Binary  Number  Representa:on  
  We  use  the  same  scheme  to  represent  binary  numbers,  
except  the  weights  are  powers  of  2.  
  For  example,  here  is  1101  in  binary:  
  The  decimal  value  is:  
1" 1" 0" 1" Binary"digits,"or"bits"
23" 22" 21" 20" Weights"(in"base"10)"
"
"(1  x  23)  +  (1  x  22)  +  (0  x  21)  +  (1  x  20)  =    
        8       +            4       +            0           +            1            =  13  
Powers of 2:
20 = 1 24 = 16 28 = 256
21 = 2 25 = 32 29 = 512
22 = 4 26 = 64 210 = 1024
23 = 8 27 = 128
8 
Decimal  Binary  
  The  same  works  with  decimal  binary,  but  this  is  
uncommon  outside  of  floa:ng  point  representa:ons.  
  For  example,  here  is  1101.01  in  binary:  
  The  decimal  value  is:  
1" 1" 0" 1" ." 0" 1" Binary"digits,"or"bits"
23" 22" 21" 20" " 241" 242" Weights"(in"base"10)"
"
"
(1  x  23)  +  (1  x  22)  +  (0  x  21)  +  (1  x  20)  +  (0  x  2-­‐1)  +  (1  x  2-­‐2)  =    
        8       +            4       +            0           +            1            +              0            +        0.25      =  13.25  
9 
Conver:ng  decimal  to  binary  
  Decimal  integer    binary:  Keep  dividing  by  2  un:l  the  
quo:ent  is  0.  Collect  the  remainders  in  reverse  order.  
  Example:  162:  
  
  
  
162  /  2  =     rem  
              /  2  =     rem  
              /  2  =     rem  
              /  2  =     rem  
              /  2  =     rem  
              /  2  =     rem  
              /  2  =     rem  
              /  2  =     rem  
10 
To  convert  a  frac5on,  keep  
mul5plying  the  frac5onal  part  by  
2  un5l  it  becomes  0.  Collect  the  
integer  parts  in  forward  order.  
  
  
  
  
  
Conver:ng  decimal  to  binary  
  Decimal  integer    binary:  Keep  dividing  by  2  un:l  the  
quo:ent  is  0.  Collect  the  remainders  in  reverse  order.  
  Example:  162.375:  
  
  
  
  So,  162.37510  =  10100010.0112  
162  /  2  =  81   rem  0  
    81  /  2  =  40   rem  1  
    40  /  2  =  20   rem  0  
    20  /  2  =  10   rem  0  
    10  /  2  =  5   rem  0  
        5  /  2  =  2   rem  1  
        2  /  2  =  1   rem  0  
        1  /  2   =  0   rem  1  
0.375  x  2  =  0.750  
0.750  x  2  =  1.500  
0.500  x  2  =  1.000  
11 
Why  does  this  work?  
  This  works  for  conver:ng  from  decimal  to  any  base  
  Why?  Think  about  conver:ng  162.375  from  decimal  
to  decimal.  
  Each  division  strips  off  the  rightmost  digit  (the  
remainder).  The  quo:ent  represents  the  remaining  
digits  in  the  number.  
  Similarly,  to  convert  frac:ons,  each  mul:plica:on  
strips  off  the  leemost  digit  (the  integer  part).  The  
frac:on  represents  the  remaining  digits.  
162  /  10=  16   rem  2  
    16  /  10=  1   rem  6  
        1  /  10=  0   rem  1  
0.375  x  10  =  3.750  
0.750  x  10  =  7.500  
0.500  x  10  =  5.000  
12 
Wri:ng  Binary  Numbers  
  It  gets  tedious  to  write  32-­‐bit  numbers  like:  
     10011010111001101011000111111101  
  
  It  is  even  more  error  prone  to  copy  them.  
13 
13 
 
Decimal Binary Hex 
0 0000 0 
1 0001 1 
2 0010 2 
3 0011 3 
4 0100 4 
5 0101 5 
6 0110 6 
7 0111 7 
8 1000 8 
9 1001 9 
10 1010 A 
11 1011 B 
12 1100 C 
13 1101 D 
14 1110 E 
15 1111 F 
 
 
Hexadecimal  (base-­‐16)  
  The  hexadecimal  system  uses  16  digits:  
0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  
  We  can  write  our  32bit  number:  
   1001 1010 1110 0110 1011 0001 1111 1101 
        as  
  0x9AE6B1FD      (C/Java  style)  
  32’h9AE6B1FD (Verilog  style)  
  
  Hex  is  frequently  used  to  specify  things  like  
32-­‐bit  IP  addresses  and  24-­‐bit  colors.  
14 
Binary  and  hexadecimal  conversions  
  Conver:ng  from  hexadecimal  to  binary  is  easy:  just  replace  
each  hex  digit  with  its  equivalent  4-­‐bit  binary  sequence.  
  
  To  convert  from  binary  to  hex,  make  groups  of  4  bits,  star:ng  from  
the  binary  point.  Add  0s  to  the  ends  of  the  number  if  needed.  
Then,  just  convert  each  bit  group  to  its  corresponding  hex  digit.  
261.3516     =   2         6             1   .        3         516    
     =          0010   0110     0001   .  0011   01012  
10110100.0010112   =   1011   0100   .   0010   11002  
     =                        B                    4              .         2       C16  
1111 F 1011 B 0111 7 0011 3 
1110 E 1010 A 0110 6 0010 2 
1101 D 1001 9 0101 5 0001 1 
1100 C 1000 8 0100 4 0000 0 
Binary Hex Binary Hex Binary Hex Binary Hex 
15 
Binary  addi:on  by  hand            (5-­‐bit  numbers)  
  You  can  add  two  binary  numbers  one  column  at  a  :me  
star:ng  from  the  right,  just  as  you  add  two  decimal  numbers.  
  But  remember  that  it’s  binary.  For  example,  1  +  1  =  10  and  
you  have  to  carry!  
 
 0  1  0  1  1  Augend    (11) 
+  0  1  1  1  0  Addend    (14) 
      Sum 
16 
Binary  addi:on  by  hand  
  You  can  add  two  binary  numbers  one  column  at  a  :me  
star:ng  from  the  right,  just  as  you  add  two  decimal  numbers.  
  But  remember  that  it’s  binary.  For  example,  1  +  1  =  10  and  
you  have  to  carry!  
 1  1  1  0   Carry in 
 0  1  0  1  1  Augend 
+  0  1  1  1  0  Addend 
 1  1  0  0  1  Sum 
The initial carry in is implicitly 0 
most significant 
bit, or MSB 
least significant 
bit, or LSB 
17 
Limited  representa:on            (4-­‐bit  numbers)  
  What  if  we  do  that  same  addi:on,  using  only  4-­‐bit  numbers  
  (and	  where	  the	  result	  can	  only	  be	  4	  bits	  long…)	  
 
 1  0  1  1  Augend    (11) 
+  1  1  1  0  Addend    (14) 
     Sum 
18 
Bitwise  Logical  opera:ons  
  Most  computers  also  support  logical  opera:ons  like  AND,  
OR  and  NOT,  but  extended  to  mul:-­‐bit  words  instead  of  
just  single  bits.  
  To  apply  a  logical  opera:on  to  two  words  X  and  Y,  apply  
the  opera:on  on  each  pair  of  bits  Xi  and  Yi:  
  1   0  1   1  
AND   1   1   1   0  
  1   0  1   0  
  1   0  1   1  
OR   1   1   1   0  
  1   1   1   1  
  1   0  1   1  
XOR   1   1   1   0  
  0  1   0  1  
19 
  Languages  like  C,  C++  and  Java  provide  bitwise  logical  opera:ons:  
        &  (AND)   |  (OR)   ^  (XOR)   ~  (NOT)  
  These  opera:ons  treat  each  integer  as  a  bunch  of  individual  bits:  
        13  &  25  =  9      because   01101  &  11001  =  01001  
  Bitwise  operators  are  oeen  used  in  programs  to  set  a  bunch  of  
Boolean  op:ons,  or  flags,  with  one  argument.    
  They  are  not  the  same  as  the  operators  &&,  ||  and  !,  which  treat  
each  integer  as  a  single  logical  value  (0  is  false,  everything  else  is  
true):  
        13  &&  25  =  1      because   true  &&  true  =  true  
  
Bitwise  opera:ons  in  programming  
20 
  IP  addresses  are  actually  32-­‐bit  (or  128-­‐bit)  binary  numbers,  and  
bitwise  opera:ons  can  be  used  to  find  network  informa:on.  
  For  example,  you  can  bitwise-­‐AND  an  address  192.168.10.43  with  a  
“subnet  mask”  to  find  the  “network  address,”  or  which  network  
the  machine  is  connected  to.  
    192.168. 10. 43 = 11000000.10101000.00001010.00101011 
  & 255.255.255.224 = 11111111.11111111.11111111.11100000 
    192.168. 10. 32 = 11000000.10101000.00001010.00100000 
  You  can  use  bitwise-­‐OR  to  generate  a  “broadcast  address,”  for  
sending  data  to  all  machines  on  the  local  network.  
    192.168. 10. 43 = 11000000.10101000.00001010.00101011 
  |   0.  0.  0. 31 = 00000000.00000000.00000000.00011111 
    192.168. 10. 63 = 11000000.10101000.00001010.00111111  
Bitwise  opera:ons  in  networking  
21 
21 
Nega:ve  Numbers    
  It  is  useful  to  be  able  to  represent  nega:ve  numbers.  
  What  would  be  ideal  is:  
  If	  we	  could	  use	  the	  same  algorithm  to  add  signed  numbers  as  
we  use  for  unsigned  numbers  
  Then	  our	  computers	  wouldn’t	  need	  2	  kinds	  of	  adders,	  just	  1.	  
  This  is  achieved  using  the  2’s  complement  representa:on.  
  
22 
The  number  wheel  (4-­‐bit  unsigned  #’s)  
0000
1000
01001100
0010
1010 0110
1110
0001
1001
0101
1101 0011
1011
0111
1111
0 1
2
3
4
5
6
789
10
11
12
13
14
15
AdditionSubtraction
23 
The  number  wheel  (4-­‐bit  2’s  complement)  
0000
1000
01001100
0010
1010 0110
1110
0001
1001
0101
1101 0011
1011
0111
1111
0 1
2
3
4
5
6
7
AdditionSubtraction
