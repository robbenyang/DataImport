Announcements
MP3, EC grading runs 9/27-10/1 with EC due 10/1, all due 
10/08, 11:59p.
MP 3.1 will be on Exam 1.
Exam 1: 10/1, 7-10p, in rooms tba. 75min exam, given  3hr.
Class cancelled 9/30.
Review session – 9/30, 12-2p, Siebel 1404.
Review session – 9/30, 2-3p, Siebel 0216.
MP2 solution party: Sun, 9/29, 4-6pm, Room 0216.
Code Challenge #1: 10/2, 9pm
lots of magic:
#include <list>
#include <iostream>
#include <string>
using namespace std;
struct animal {
   string name;
   string food;
   bool big;
   animal(string n="blob", string f="you”, bool b=true):name(n),food(f),big(b) {}
};
int main() {
   animal g("giraffe","leaves"), p("penguin","fish”,false), b("bear"); 
   list<animal> zoo;
   zoo.push_back(g); zoo.push_back(p); zoo.push_back(b); //STL list insertAtEnd
   for(list<animal>::iterator it = zoo.begin(); it != zoo.end(); it++)
      cout << (*it).name << "  " << (*it).food << endl;
return 0;
}
Suppose these familiar structures were encapsulated.
Iterators give client the access it needs to traverse them anyway!
Objects of type “iterator” promise to 
have at least the following defined:
operator++
operator*
operator!=
operator==
operator=
“Container classes” typically have a 
variety of iterators defined within:
Forward
Reverse
Bidirectional
Iterator class:
pm ++ *
linked 
list
array
hypercube
http://www.sgi.com/tech/stl/
class human {
public:
   
private:
};
Generic programming: (more magic)
#include <list>
#include <iostream>
#include <string>
using namespace std;
struct animal {
   string name;
   string food;
   bool big;
   animal(string n="blob", string f="you”, bool b=true):name(n),food(f),big(b) {}
};
int main() {
   animal g("giraffe","leaves"), p("penguin","fish”,false), b("bear"); 
   list<animal> zoo;
   zoo.push_back(g); zoo.push_back(p); zoo.push_back(b); //STL list insertAtEnd
   for(list<animal>::iterator it = zoo.begin(); it != zoo.end(); it++)
      cout << (*it).name << "  " << (*it).food << endl;
return 0;
}
emplate<class Iter, class Formatter>
void print(Iter first, Iter second, Formatter printer) {
   while (!(first==second)) {
      printer(*first);
      first++;
   }
}
Generic programming: (more magic)
#include <list>
#include <iostream>
#include <string>
using namespace std;
struct animal {
   string name;
   string food;
   bool big;
   animal(string n="blob", string f="you”, bool b=true):name(n),food(f),big(b) {}
};
int main() {
   animal g("giraffe","leaves"), p("penguin","fish”,false), b("bear"); 
   list<animal> zoo;
   zoo.push_back(g); zoo.push_back(p); zoo.push_back(b); //STL list insertAtEnd
   for(list<animal>::iterator it = zoo.begin(); it != zoo.end(); it++)
      cout << (*it).name << "  " << (*it).food << endl;
return 0;
}
emplate<class Iter, class Formatter>
void print(Iter first, Iter second, Formatter printer) {
   while (!(first==second)) {
      printer(*first);
      first++;
   }
}
class printIfBig {
public:
   void operator()(animal a) {
      if (a.big) cout << a.name << endl;
   }
};
Generic programming: (more magic)
#include <list>
#include <iostream>
#include <string>
using namespace std;
struct animal {
   string name;
   string food;
   bool big;
   animal(string n="blob", string f="you”, bool b=true):name(n),food(f),big(b) {}
};
int main() {
   animal g("giraffe","leaves"), p("penguin","fish”,false), b("bear"); 
   list<animal> zoo;
   zoo.push_back(g); zoo.push_back(p); zoo.push_back(b); //STL list insertAtEnd
   for(list<animal>::iterator it = zoo.begin(); it != zoo.end(); it++)
      cout << (*it).name << "  " << (*it).food << endl;
return 0;
}
emplate<class Iter, class Formatter>
void print(Iter first, Iter second, Formatter printer) {
   while (!(first==second)) {
      printer(*first);
      first++;
   }
}
class printIfBig {
public:
   void operator()(animal a) {
      if (a.big) cout << a.name << endl;
   }
};
printIfBig myFun;
print<list<animal>::iterator,printIfBig>(zoo.begin(),zoo.end(),myFun);
