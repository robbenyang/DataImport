MP7 available, due 12/10, 11:59p. 
This Is It deadlines 
Today’s announcements: 
Algorithm BFS(G) 
     Input: graph G 
     Output:  labeling of the edges of G 
as discovery edges and back edges 
 
For all u in G.vertices() 
   setLabel(u, UNEXPLORED) 
For all e in G.edges() 
   setLabel(e, UNEXPLORED) 
For all v in G.vertices() 
   if getLabel(v) = UNEXPLORED 
      BFS(G,v) 
Algorithm BFS(G,v) 
     Input: graph G and start vertex v 
     Output:  labeling of the edges of G in the connected 
component of v as discovery edges and cross edges 
queue q; 
setLabel(v, VISITED) 
q.enqueue(v); 
While !(q.isEmpty) 
   q.dequeue(v) 
   For all w in G.adjacentVertices(v) 
        if getLabel(w) = UNEXPLORED 
              setLabel((v,w),DISCOVERY) 
              setLabel(w, VISITED) 
              q.enqueue(w) 
        else if getLabel((v,w)) = UNEXPLORED 
              setLabel((v,w),CROSS) 
Graphs: Traversal - DFS 
http://www.cs.duke.edu/csed/jawaa2/examples/DFS.html 
http://www.student.seas.gwu.edu/~idsv/idsv.html 
http://www.youtube.com/watch?v=8qrZ1clEp-Y  
A 
B 
C 
D E 
DFS:   “visits” each vertex 
classifies each edge as either “discovery” or “back” 
Algorithm DFS(G) 
     Input: graph G 
     Output:  labeling of the edges 
of G as discovery edges and back 
edges 
 
For all u in G.vertices() 
   setLabel(u, UNEXPLORED) 
For all e in G.edges() 
   setLabel(e, UNEXPLORED) 
For all v in G.vertices() 
   if getLabel(v) = UNEXPLORED 
      DFS(G,v) 
Algorithm DFS(G,v) 
     Input: graph G and start vertex v 
     Output:  labeling of the edges of G in the 
connected component of v as discovery edges 
and back edges 
 
setLabel(v, VISITED) 
For all w in G.adjacentVertices(v) 
      if getLabel(w) = UNEXPLORED 
         setLabel((v,w),DISCOVERY) 
         DFS(G,w) 
      else if getLabel((v,w)) = UNEXPLORED 
         setLabel(e,BACK) 
Graphs: DFS example 
A B  C  D  E 
B A  C 
C B  A  D  E 
D A  C 
E A  C 
A 
B 
C 
D E 
Graphs: DFS Analysis 
setting/getting labels 
every vertex labeled twice 
 
every edge is labeled twice 
 
querying vertices 
each vertex 
total over algorithm 
querying edges 
 
TOTAL RUNNING TIME: 
A 
B 
C 
D E 
A 
B 
C 
D E 
DFS:  How can we count the number of connected components in the graph? 
 
How can we determine if a graph has a cycle? 
Algorithm DFS(G) 
     Input: graph G 
     Output:  labeling of the edges 
of G as discovery edges and back 
edges 
 
For all u in G.vertices() 
   setLabel(u, UNEXPLORED) 
For all e in G.edges() 
   setLabel(e, UNEXPLORED) 
For all v in G.vertices() 
   if getLabel(v) = UNEXPLORED 
      DFS(G,v) 
Algorithm DFS(G,v) 
     Input: graph G and start vertex v 
     Output:  labeling of the edges of G in the 
connected component of v as discovery edges 
and back edges 
 
setLabel(v, VISITED) 
For all w in G.adjacentVertices(v) 
      if getLabel(w) = UNEXPLORED 
         setLabel((v,w),DISCOVERY) 
         DFS(G,w) 
      else if getLabel((v,w)) = UNEXPLORED 
         setLabel(e,BACK) 
