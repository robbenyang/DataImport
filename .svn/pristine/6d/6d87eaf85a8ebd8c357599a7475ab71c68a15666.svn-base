1 Closure Properties
1.1 Decidable Languages
Boolean Operators
Proposition 1. Decidable languages are closed under union, intersection, and complementation.
Proof. Given TMs M1, M2 that decide languages L1, and L2
â€¢ A TM that decides L1 âˆª L2: on input x, run M1 and M2 on x, and accept iff either accepts.
(Similarly for intersection.)
â€¢ A TM that decides L1: On input x, run M1 on x, and accept if M1 rejects, and reject if M1
accepts.
Regular Operators
Proposition 2. Decidable languages are closed under concatenation and Kleene Closure.
Proof. Given TMs M1 and M2 that decide languages L1 and L2.
â€¢ A TM to decide L1L2: On input x, for each of the |x|+ 1 ways to divide x as yz: run M1 on
y and M2 on z, and accept if both accept. Else reject.
â€¢ A TM to decide Lâˆ—1: On input x, if x =  accept. Else, for each of the 2|x|âˆ’1 ways to divide x
as w1 . . . wk (wi 6= ): run M1 on each wi and accept if M1 accepts all. Else reject.
Inverse Homomorphisms
Proposition 3. Decidable languages are closed under inverse homomorphisms.
Proof. Given TM M1 that decides L1, a TM to decide h
âˆ’1(L1) is: On input x, compute h(x) and
run M1 on h(x); accept iff M1 accepts.
Homomorphisms
Proposition 4. Decidable languages are not closed under homomorphism
Proof. We will show a decidable language L and a homomorphism h such that h(L) is undecidable
â€¢ Let L = {xy | x âˆˆ {0, 1}âˆ—, y âˆˆ {a, b}âˆ—, x = ã€ˆM,wã€‰, and y encodes an integer n such that the
TM M on input w will halt in n steps }
â€¢ L is decidable: can simply simulate M on input w for n steps
â€¢ Consider homomorphism h: h(0) = 0, h(1) = 1, h(a) = h(b) = .
â€¢ h(L) = HALT which is undecidable.
1
1.2 Recursively Enumerable Languages
Boolean Operators
Proposition 5. R.E. languages are closed under union, and intersection.
Proof. Given TMs M1, M2 that recognize languages L1, L2
â€¢ A TM that recognizes L1 âˆª L2: on input x, run M1 and M2 on x in parallel, and accept iff
either accepts. (Similarly for intersection; but no need for parallel simulation)
Complementation
Proposition 6. R.E. languages are not closed under complementation.
Proof. Atm is r.e. but Atm is not.
Regular Operations
Proposition 7. R.E languages are closed under concatenation and Kleene closure.
Proof. Given TMs M1 and M2 recognizing L1 and L2
â€¢ A TM to recognize L1L2: On input x, do in parallel, for each of the |x|+ 1 ways to divide x
as yz: run M1 on y and M2 on z, and accept if both accept. Else reject.
â€¢ A TM to recognize Lâˆ—1: On input x, if x =  accept. Else, do in parallel, for each of the 2|x|âˆ’1
ways to divide x as w1 . . . wk (wi 6= ): run M1 on each wi and accept if M1 accepts all. Else
reject.
Homomorphisms
Proposition 8. R.E. languages are closed under both inverse homomorphisms and homomor-
phisms.
Proof. Let TM M1 recognize L1.
â€¢ A TM to recognize hâˆ’1(L1):On input x, compute h(x) and run M1 on h(x); accept iff M1
accepts.
â€¢ A TM to recognize h(L1): On input x, start going through all strings w, and if h(w) = x,
start executing M1 on w, using dovetailing to interleave with other executions of M1. Accept
if any of the executions accepts.
2
