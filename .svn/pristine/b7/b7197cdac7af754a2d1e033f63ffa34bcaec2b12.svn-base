CS411 – Indexing  
Kevin C. Chang
Indexing
Database Systems
 
General Idea and Definition 
·Database indexing is a kind of data structure which 
can be used to improve the speed of data retrieval and 
search on relations. 
·Creating indexing at the cost of additional writes and 
the use of more space to store the extra copy of data.  
·Indexes are used to quickly locate data without 
having to search every row in a table.  
·Indexes can be created using one or more columns of 
a relation. 
• Index– what is?
• Clustered/unclustered indexes.
• Dense/sparse indexes.
• Primary/secondary indexes.
• B+ trees
• Search, insertion, deletion on B+ trees.
• Hash tables 
• Extensible hash tables
• Search, insertion, deletion
• Linear hash tables
• Search, insertion, deletion
Concepts You Will Learn
Indexing (1 of 66)Default Section (1 of 2)
 
The Most Important Things You Should Know 
·Three kinds of categories of Indexing. 
·Besides sequential indexing, we have some more 
effective indexing: B+ Tree and Hash Tables. 
The Big Picture: Where We Are
Indexing (2 of 66)
Default Section (2 of 2)
Query Executor
Buffer Manager
Storage Manager
Tables, Indexes
Query Optimizer
Query Parser/Rewriter
Access Manager
Web/Mobile/Console Applications
SQ
L
R
el
a
ti
o
n
a
l 
A
lg
eb
ra
B
+T
re
e
H
a
sh
ER
Transaction
Manager
Concurrency 
Control
Logging/
Recovery
Relational NonRelational
Information Extraction
XML 
Databases
Map Reduce
NoSQL 
Databases
Structured SemiStructured
 
Some Key Points in This Diagram 
·Query Optimizer: We may have many methods to do the 
query, and optimizer chooses from different ways and pick 
up the best/most efficient one.  
· Access Manager: It uses index to get access to tables. 
·NoSQL: A fast DBMS for large and complex data 
(see lecture notes “NoSQLDatabase.pdf” for more 
details). 
·Information Extraction: Information is at everywhere 
(web, etc.) and we need to extract and put in in our tables. 
·We need to deal with data not only in main memory but 
also in disks, and we rely on index to deal with data on 
disks. 
CS411 – Indexing  
Why Do We Learn This?
Indexing (3 of 66)Why Do We Learn This? (0 of 0)
 
Why? 
Let me give you a simple example; if we want to take a 
look at professor Kevin’s profile, we do not need to 
remember and type its URL on address bar; instead we 
just google it.   
This means that we get access to data by “values”, and 
without index it cannot happen. i.e. index help us move 
from values to where it is. 
Index: What, Why, and How?
Indexing (4 of 66)Index: What, Why, and How? (0 of 14)
 
Additional Links 
1. Introduction to database index 
http://www.interspire.com/content/2006/02/15/introduction-to-
database-indexes/ 
2. What is database indexing? 
http://stackoverflow.com/questions/15232403/what-is-a-
database-index 
3. How does database indexing works? 
http://stackoverflow.com/questions/1108/how-does-database-
indexing-work 
4. Video tutorial on SQL Indexing 
http://www.youtube.com/watch?v=7ZgG7ttJTSc 
 
CS411 – Indexing  
• To build an index.
• But what is an index? 
• Examples in the real world?
Q: What is “indexing”? 
Indexing (5 of 66)Index: What, Why, and How? (1 of 14)
 
What is database indexing? 
http://en.wikipedia.org/wiki/Database_index 
Examples in real world: 
·When you are looking for food and you see 
“McDonald’s Exit 151”. Here “McDonald’s” is value 
and “Exit 151” is a pointer. 
·In our best-selling textbook “Database Systems”, 
there are two indexes: Table of Contents and Concept 
Index. 
What is “indexing”? 
Indexing (6 of 66)Index: What, Why, and How? (2 of 14)
 
 
•An index on a file speeds up selections on the search key 
field(s) 
•Search key = any subset of the fields of a relation
• Search key is not the same as key (minimal set of fields that 
uniquely identify a record in a relation).
•Entries in an index: (k, r), where:
• k = the key
• r = the record OR record id OR record ids
Indexes
Indexing (7 of 66)Index: What, Why, and How? (3 of 14)
 
·Main function: speed up selection. 
·Search key (any field subset of a relation) !=  key 
(min field set):  
 
CS411 – Indexing  
•Clustered/unclustered
• Clustered = records sorted in the key order
• Unclustered = no
•Dense/sparse
• Dense = each record has an entry in the index
• Sparse = only some records have
•Primary/secondary
• Primary = on the primary key
• Secondary = on any key
• Some textbooks interpret these differently
•B+ tree / Hash table / …
Types of Indexes
Indexing (8 of 66)Index: What, Why, and How? (4 of 14)
 
1. More definition on Clustered/Unclustered index 
http://stackoverflow.com/questions/1251636/what-do-clustered-
and-non-clustered-index-actually-mean 
2. More definition on Dense/Sparse index 
http://www.cs.sfu.ca/CourseCentral/354/zaiane/material/notes/C
hapter11/node5.html 
3. More definition on Primary/Secondary index 
http://wiki.answers.com/Q/Difference_between_primary_index_
and_secondary_index 
 
 
• Clustered: File is sorted on the index attribute
• Dense: sequence of (key,pointer) pairs
Ex: Clustered, Dense Index
Indexing (9 of 66)
10
20
30
40
50
60
70
80
10
20
30
40
50
60
70
80
Index: What, Why, and How? (5 of 14)
 
Clustered-Dense Index 
·Clustered = record is sorted on index attribute. 
·Dense = every key presents in index. 
·Suppose numbers in file is Age. “Age” is the sorted 
index attribute and every age appears in index. 
·Before the invention of B tree, people use sequential 
search. 
·This is a sequential index on a sequential file. 
·We can hold index in main memory, and we can hold 
data in disks. 
·If we want to search age = 20, we search down 
through the index and find 20; 
·If we want to search age = 25, we pass by 20 and 
down to 30 directly. We can conclude there is no 25 
in the file because this is a dense index and every age 
should and will appear in index.   
·If we want to search age between 20 and 40, we go 
from 20 down to 30 and then reach 40. And that’s all 
we need to search. We don’t need to jump back and 
forth because it is clustered and everything is sorted. 
 
CS411 – Indexing  
• Sparse index: one key per data block
Clustered, Sparse Index
Indexing (10 of 66)
10
30
50
70
90
110
130
150
10
20
30
40
50
60
70
80
Index: What, Why, and How? (6 of 14)
 
Clustered-Sparse Index 
·Sparse = not all keys are in the index. Specifically, 
one key per data block (disk page). 
·Why sparse: we may not want to show every key in 
the index, or we want to keep our index as small as 
possible. 
·If We want to search age = 20, we pass by 10 and 
reach 30 directly without finding 20 in the index. But 
we cannot conclude that 20 doesn’t exist, because not 
all keys are in the index. We then move down from 
10 in the file and could find 20. 
·Index will be smaller and may be able to fit in main 
memory. 
 
How if duplicate keys?
Indexing (11 of 66)Index: What, Why, and How? (7 of 14)
 
 
CS411 – Indexing  
• Dense index: point to the first record with that key
Clustered Index with Duplicate Keys
Indexing (12 of 66)
10
20
30
40
50
60
70
80
10
10
10
20
20
20
30
40
Index: What, Why, and How? (8 of 14)
 
Duplication in Clustered-Dense Index 
·Still maintains Clustered and Dense characters. 
·We may have many “10” and many “20”, the index 
points to the first “10” and the first “20” in the file. 
·The searching is the same as what we do in 
Clustered-Dense Index. 
• Sparse index: pointer to lowest search key in each block:
• OK? 
Try search for 20
Clustered Index with Duplicate Keys
Indexing (13 of 66)
10
10
20
30
10
10
10
20
20
20
30
40
Index: What, Why, and How? (9 of 14)
 
Duplication in Clustered-Sparse Index (1) 
·In each disk block (disk page), there is a pointer 
pointing to the lowest search key. 
·In the first disk block, we have 10 and 10, so the lowest 
search key is just 10. We have a pointer to 10. In the 
second disk block, we have 10 and 20, so the lowest search 
key is still 10 and we have a pointer to 10… 
·If we want to search age = 20, we go down the index and 
find 20, but there may be many “20”. If we want to pick up 
all “age = 20”, we could search up and down in the file 
from the first “20” we get. 
·We may notice: There are two “10” in the index – 
redundancy is bad! 
• Better: pointer to lowest new search key in each block:
• Search for 20
Clustered Index with Duplicate Keys
Indexing (14 of 66)
10
20
30
40
50
60
70
80
10
10
10
20
30
30
40
50
Index: What, Why, and How? (10 of 14)
 
Duplication in Clustered-Sparse Index (2) 
·In each disk block (disk page), there is a pointer pointing 
to the new lowest search key. 
·In the first disk block, we have 10 and 10, so the lowest 
search key is just 10. We have a pointer to 10. In the 
second disk block, we have 10 and 20, but we have already 
had a pointer to 10, so the new lowest should be 20. 
 
CS411 – Indexing  
• Often for indexing other attributes than primary key
• Always dense (why ?)
Unclustered Indexes
Indexing (15 of 66)
10
10
20
20
20
30
30
30
20
30
30
20
10
20
10
30
Index: What, Why, and How? (11 of 14)
 
Unclustered Index 
·The index attribute (age) is not sorted. 
·Unclustered index must be dense because we rely on 
index to get access to every single data in the file. 
This means all keys has to be shown in the index. 
Otherwise we have no way to locate where the data is 
and thus  have to jump back and forth to find it (that’s 
not what we want). 
·We could search age = 20 and will get three results 
(every occurrence). And we may also want to search 
age = 25 but we cannot find it in index, then we can 
conclude that there is no age = 25 in the file. 
 
Summary Clustered vs. Unclustered Index
Indexing (16 of 66)
Data entries
(Index File)
(Data file)
Data Records
Data entries
Data Records
CLUSTERED UNCLUSTERED
Index: What, Why, and How? (12 of 14)
 
·Clustered index: 
- looks neat and tidy 
- not all data records need to be pointed to by index 
·Unclustered index: 
        - looks messy (but this doesn’t mean it is not good 
or inefficient) 
        - all data records has to be pointed by index (must 
be dense) 
Composite Search Keys
• Composite Search Keys: Search 
on a combination of fields.
• Equality query: Every field 
value is equal to a constant 
value. E.g. wrt <sal,age> index:
• age=20 and sal =75
• Range query: Some field value 
is not a constant. E.g.:
• age =20; or age=20 and sal > 10
Indexing (17 of 66)
sue 13 75
bob
cal
joe 12
10
20
8011
12
name age sal
<sal, age>
<age, sal> <age>
<sal>
12,20
12,10
11,80
13,75
20,12
10,12
75,13
80,11
11
12
12
13
10
20
75
80
Data records
sorted by name
Data entries in index
sorted by <sal,age>
Data entries
sorted by <sal>
Examples of composite key
indexes using lexicographic order.
Index: What, Why, and How? (13 of 14)
 
·We may need to search something rely on many 
fields, and we need composite search key. 
·Two types:  
- Equality Query: usually indicated by “=”. 
- Range Query: <, >, <=, >=, etc. 
 
CS411 – Indexing  
• How many indexes? Where?
• What are keys? What are records?
• Clustered?
• Dense?
• Primary?
Q: Our textbook as example: Indexes? 
Indexing (18 of 66)Index: What, Why, and How? (14 of 14)
 
As we said, we have two indexes in our test book. 
                         Table of Contents          Concept Index 
Key:                 Chapter/section No.             keywords 
Pointer:                 page number                 page number 
Clustered:                    Yes [1]                            No [2] 
Dense:                           Yes [3]                            Yes [4] 
Explanation: 
[1] The book is sorted by chapter/section numbers, 
namely by the key. So Table of Contents is clustered. 
[2] The book is not sorted by keywords. A certain 
keyword may appear many times in the book at different 
place. So Concept Index is not clustered. 
[3] Every chapter/section numbers (key) can be found in 
the Table of Contents, so it is dense. 
[4] Every keyword (key) can be found in the Concept 
Index, so it is dense. 
 
B+ Trees
Indexing (19 of 66)B+ Trees (0 of 26)
 
Extra Recourses: 
·B-Tree: http://en.wikipedia.org/wiki/B-tree 
·B+ Tree: http://en.wikipedia.org/wiki/B%2B_tree 
CS411 – Indexing  
Kevin C. Chang
B+ Trees
Indexing (20 of 66)
What’s wrong with sequential index?
B+ Trees (1 of 26)
 
Drawback of Sequential Index 
·Sequential index is too static, there is little dynamic 
characters of a sequential index. 
·If we want to insert/delete something in the middle of 
an index, we have to change the position/address of 
many other keys to create the updated index. 
·If the storage of data is static and hard to maintain, it 
will become useless. 
 
B-Trees/B+Trees: B_ ?_ _? _ _ Trees
• Intuition:
• Give up on sequentiality of index
• Try to get “balance” by dynamic reorganization
• B+trees:
• Textbook refers to B+trees (a popular variant) as B-trees (as most people do)
• Distinction will be clear later (ok to confuse now)
Indexing (21 of 66)B+ Trees (2 of 26)
 
·B here doesn’t mean “Binary”. It means “Balance”. 
There may be many children extended from a parent 
node, so it has no binary character. 
Behind the Scene: 
UIUC (Alumni) Contribution!
Prof. Rudolf Bayer
Rudolf Bayer studied Mathematics in Munich and at the University of Illinois, 
where he received his Ph.D. in 1966. After working at Boeing Research Labs he 
became an Associate Professor at Purdue University. He is a Professor of 
Informatics at the Technische Universität München since 1972 and … …
The 2001 SIGMOD Innovations Award goes to Prof. Rudolf Bayer of the Technical 
University of Munich, for his invention of the B-Tree (with Edward M. 
McCreight), of B-Tree prefix compression, and of lock coupling (a.k.a. crabbing) 
for concurrent access to B-Trees (with Mario Schkolnick). All of these techniques 
are widely used in commercial database products. ……
The Original Publication
Rudolf Bayer, Edward M. McCreight: Organization and Maintenance of 
Large Ordered Indices. Acta Informatica 1: 173-189(1972)
Indexing (22 of 66)B+ Trees (3 of 26)
 
 
CS411 – Indexing  
Behind the Scene: And he said Hello!
Indexing (23 of 66)B+ Trees (4 of 26)
 
 
• Parameter d = the degree
• Each node has [d, 2d] keys (except root)
• Internal node:
• Leaf:
B+ Trees Basics
Indexing (24 of 66)
30 120 240
[X , 30) [30, 120) [120, 240) [240, Y)
40 50 60
40 50 60
next leaf
B+ Trees (5 of 26)
 
·Degree (d): How bid an index node is. This means 
how many values you can have in a node. 
·After defining the degree, we could have [degree, 
2*degree] values in an index node (the root node may 
not obey this rule).  
·The number of pointer is always one more than the 
number of values in that node (this rule apply for the 
root). 
B+ Tree Example
Indexing (25 of 66)
80
20 60 100 120 140
10 15 18 20 30 40 50 60 65 80 85 90
10 15 18 20 30 40 50 60 65 80 85 90
d = 2
B+ Trees (6 of 26)
 
B+ Tree Example 
·In this example, the root has only one value (two 
pointers), and the second node in the third level (the 
root is the first level) is “full”. 
·Usually the first several levels can fit in main memory, and 
the bottom level is in the disk. 
CS411 – Indexing  
• How large d ?
• Example:
• Key size = 4 bytes
• Pointer size = 8 bytes
• Block size = 4096 byes
• 2d x 4  + (2d+1) x 8  <=  4096
• d = 170
B+ Tree Design
Indexing (26 of 66)B+ Trees (7 of 26)
 
Calculate d 
·One node on each data block (disk page). 
·The total size of a node should be: 
2d * key_size + (2d+1) * pointer_size 
·In this example, d is at most 170. 
• Exact key values:
• Start at the root
• Proceed down, to the leaf
• Range queries:
• As above
• Then sequential traversal
Searching a B+ Tree
Indexing (27 of 66)
Select name
From people
Where age = 25
Select name
From people
Where 20 <= age
and  age <= 30
B+ Trees (8 of 26)
 
 
•Typical order: 100.  Typical fill-factor: 67%.
• average fanout = 133
•Typical capacities:
• Height 4: 1334 = 312,900,700 records
• Height 3: 1333 =     2,352,637 records
•Can often hold top levels in buffer pool:
• Level 1 =           1 page  =     8 Kbytes
• Level 2 =      133 pages =     1 Mbyte
• Level 3 = 17,689 pages = 133 MBytes       
B+ Trees in Practice
Indexing (28 of 66)B+ Trees (9 of 26)
 
 
CS411 – Indexing  
Insert (K, P)
• Find leaf where K belongs, insert
• If no overflow (2d keys or less), halt
• If overflow (2d+1 keys), split node, insert in parent:
• If leaf, keep K3 too in right node
• When root splits, new root has 1 key only 
• that’s why root is special for degree satisfaction
Insertion in a B+ Tree
Indexing (29 of 66)
K1 K2 K3 K4 K5
P0 P1 P2 P3 P4 p5
K1 K2
P0 P1 P2
K4 K5
P3 P4 p5
(K3,    ) to parent
B+ Trees (10 of 26)
 
 
Insertion in a B+ Tree
Indexing (30 of 66)
80
20 60 100 120 140
10 15 18 20 30 40 50 60 65 80 85 90
10 15 18 20 30 40 50 60 65 80 85 90
Insert K=19
B+ Trees (11 of 26)
 
 
Insertion in a B+ Tree
Indexing (31 of 66)
80
20 60 100 120 140
10 15 18 19 20 30 40 50 60 65 80 85 90
10 15 18 20 30 40 50 60 65 80 85 9019
After insertion
B+ Trees (12 of 26)
 
 
CS411 – Indexing  
Insertion in a B+ Tree
Indexing (32 of 66)
80
20 60 100 120 140
10 15 18 19 20 30 40 50 60 65 80 85 90
10 15 18 20 30 40 50 60 65 80 85 9019
Now insert 25
B+ Trees (13 of 26)
 
 
Insertion in a B+ Tree
Indexing (33 of 66)
80
20 60 100 120 140
10 15 18 19 20 25 30 40 50 60 65 80 85 90
10 15 18 20 25 30 40 60 65 80 85 9019
After insertion
50
B+ Trees (14 of 26)
 
 
Insertion in a B+ Tree
Indexing (34 of 66)
80
20 60 100 120 140
10 15 18 19 20 25 30 40 50 60 65 80 85 90
10 15 18 20 25 30 40 60 65 80 85 9019
But now have to split !
50
B+ Trees (15 of 26)
 
 
CS411 – Indexing  
Insertion in a B+ Tree
Indexing (35 of 66)
80
20 30 60 100 120 140
10 15 18 19 20 25 60 65 80 85 90
10 15 18 20 25 30 40 60 65 80 85 9019
After the split
50
30 40 50
B+ Trees (16 of 26)
 
 
Deletion from a B+ Tree
Indexing (36 of 66)
80
20 30 60 100 120 140
10 15 18 19 20 25 60 65 80 85 90
10 15 18 20 25 30 40 60 65 80 85 9019
Delete 30
50
30 40 50
B+ Trees (17 of 26)
 
 
Deletion from a B+ Tree
Indexing (37 of 66)
80
20 30 60 100 120 140
10 15 18 19 20 25 60 65 80 85 90
10 15 18 20 25 40 60 65 80 85 9019
After deleting 30
50
40 50
May change to 
40, or not
B+ Trees (18 of 26)
 
 
CS411 – Indexing  
Deletion from a B+ Tree
Indexing (38 of 66)
80
20 30 60 100 120 140
10 15 18 19 20 25 60 65 80 85 90
10 15 18 20 25 40 60 65 80 85 9019
Now delete 25
50
40 50
B+ Trees (19 of 26)
 
 
Deletion from a B+ Tree
Indexing (39 of 66)
80
20 30 60 100 120 140
10 15 18 19 20 60 65 80 85 90
10 15 18 20 40 60 65 80 85 9019
After deleting 25
Need to rebalance
Rotate
50
40 50
B+ Trees (20 of 26)
 
 
Deletion from a B+ Tree
Indexing (40 of 66)
80
19 30 60 100 120 140
10 15 18 19 20 60 65 80 85 90
10 15 18 20 40 60 65 80 85 9019
Now delete 40
50
40 50
B+ Trees (21 of 26)
 
 
CS411 – Indexing  
Deletion from a B+ Tree
Indexing (41 of 66)
80
19 30 60 100 120 140
10 15 18 19 20 60 65 80 85 90
10 15 18 20 60 65 80 85 9019
After deleting 40
Rotation not possible
Need to merge nodes
50
50
B+ Trees (22 of 26)
 
 
Deletion from a B+ Tree
Indexing (42 of 66)
80
19 60 100 120 140
10 15 18 19 20 50 60 65 80 85 90
10 15 18 20 60 65 80 85 9019
Final tree
50
B+ Trees (23 of 26)
 
 
• Idea:
• Avoid duplicate keys
• Have record pointers in non-leaf nodes
•Note: Textbook’s B-Tree means B+-tree!
Variation on B+tree: B-tree (no +)
Indexing (43 of 66)B+ Trees (24 of 26)
 
 
CS411 – Indexing  
to record to record to record
with K1 with K2 with K3
to keys to keys to keys to keys
< K1 K1<x<K2 K2<x<k3 >k3
Indexing (44 of 66)
K1 P1 K2 P2 K3 P3
B+ Trees (25 of 26)
 
 
B-tree example n=2
Indexing (45 of 66)
6
5
1
2
5
1
4
5
1
6
5
8
5
1
0
5
2
5
4
5
1
0
2
0
3
0
4
0
1
1
0
1
2
0
9
0
1
0
0
7
0
8
0
1
7
0
1
8
0
5
0
6
0
1
3
0
1
4
0
1
5
0
1
6
0
• Sequence pointers not useful now! 
B+ Trees (26 of 26)
 
- Seq. ptrs not useful any more, since keys are not all in 
the leaves 
 
 
Hash Tables
Indexing (46 of 66)Hash Tables (0 of 20)
 
 
CS411 – Indexing  
• Secondary storage hash tables are much like main memory ones
• Recall basics:
• There are n buckets
• A hash function f(k) maps a key k to {0, 1, …, n-1}
• Store in bucket f(k) a pointer to record with key k
• Secondary storage: bucket = block, use overflow blocks when needed
Hash Tables
Indexing (47 of 66)Hash Tables (1 of 20)
 
 
• Assume 1 bucket (block) stores 2 keys + pointers
• h(e)=0
• h(b)=h(f)=1
• h(g)=2
• h(a)=h(c)=3
Hash Table Example
Indexing (48 of 66)
e
b
f
g
a
c
0
1
2
3
Hash Tables (2 of 20)
 
 
• Search for a:
• Compute h(a)=3
• Read bucket 3
• 1 disk access
Searching in a Hash Table
Indexing (49 of 66)
e
b
f
g
a
c
0
1
2
3
Hash Tables (3 of 20)
 
 
CS411 – Indexing  
• Place in right bucket, if space
• E.g. h(d)=2
Insertion in Hash Table
Indexing (50 of 66)
e
b
f
g
d
a
c
0
1
2
3
Hash Tables (4 of 20)
 
 
• Create overflow block, if no space
• E.g. h(k)=1
• More over-
flow blocks
may be needed
Insertion in Hash Table
Indexing (51 of 66)
e
b
f
g
d
a
c
0
1
2
3
k
Hash Tables (5 of 20)
 
 
• Excellent, if no overflow blocks
• Degrades considerably when number of keys exceeds the number of 
buckets (I.e. many overflow blocks).
Hash Table Performance
Indexing (52 of 66)Hash Tables (6 of 20)
 
 
CS411 – Indexing  
• Allows hash table to grow, to avoid performance degradation
• Assume a hash function h that returns numbers in {0, …, 2k – 1}
• Start with n = 2i << 2k , only look at first i most significant bits
Extensible Hash Table
Indexing (53 of 66)Hash Tables (7 of 20)
 
 
• E.g. i=1, n=2, k=4
• Note: we only look at the first bit (0 or 1)
Extensible Hash Table
Indexing (54 of 66)
0(010)
1(011)
i=1 1
1
0
1
Hash Tables (8 of 20)
 
 
• Insert 1110
Insertion in Extensible Hash Table
Indexing (55 of 66)
0(010)
1(011)
1(110)
i=1 1
1
0
1
Hash Tables (9 of 20)
 
 
CS411 – Indexing  
• Now insert 1010
• Need to extend table, split blocks
• i becomes 2
Insertion in Extensible Hash Table
Indexing (56 of 66)
0(010)
1(011)
1(110), 1(010)
i=1 1
1
0
1
Hash Tables (10 of 20)
 
 
• Now insert 1010 (cont.)
Insertion in Extensible Hash Table
Indexing (57 of 66)
0(010)
10(11)
10(10)
i=2 1
2
00
01
10
11
11(10) 2
Hash Tables (11 of 20)
 
 
• Now insert 0000, then 0101
• Need to split block
Insertion in Extensible Hash Table
Indexing (58 of 66)
0(010)
0(000), 0(101)
10(11)
10(10)
i=2 1
2
00
01
10
11
11(10) 2
Hash Tables (12 of 20)
 
 
CS411 – Indexing  
• After splitting the block
Insertion in Extensible Hash Table
Indexing (59 of 66)
00(10)
00(00)
10(11)
10(10)
i=2
2
2
00
01
10
11
11(10) 2
01(01) 2
Hash Tables (13 of 20)
 
 
• No overflow blocks: access always one read
• BUT:
• Extensions can be costly and disruptive
• After an extension table may no longer fit in memory
Performance Extensible Hash Table
Indexing (60 of 66)Hash Tables (14 of 20)
 
 
• Idea: extend only one entry at a time
• Problem: n= no longer a power of 2
• Let i be #bits necessary to address n buckets.
• 2i-1 < n <= 2i
• After computing h(k), use last i bits:
• If last i bits represent a number >= n, change msb from 1 to 0 (get a number 
< n)
Linear Hash Table
Indexing (61 of 66)Hash Tables (15 of 20)
 
 
CS411 – Indexing  
• N=3
Linear Hash Table Example
Indexing (62 of 66)
(01)00
(11)00
(10)10
i=2
00
01
10
(01)11 BIT FLIP
Hash Tables (16 of 20)
 
 
• Insert 1000: overflow blocks…
Linear Hash Table Example
Indexing (63 of 66)
(01)00
(11)00
(10)10
i=2
00
01
10
(01)11
(10)00
Hash Tables (17 of 20)
 
 
• Extension: independent on overflow blocks
• Extend n:=n+1 when average number of records per block exceeds 
(say) 80%
Linear Hash Tables
Indexing (64 of 66)Hash Tables (18 of 20)
 
 
CS411 – Indexing  
•From n=3 to n=4
•Only need to touch
one block (which one ?)
Linear Hash Table Extension
Indexing (65 of 66)
(01)00
(11)00
(10)10
i=2
00
01
10
(01)11
(01)11
(01)11
i=2
00
01
10
(10)10
(01)00
(11)00
11
Hash Tables (19 of 20)
 
 
• From n=3 to n=4 finished
• Extension from n=4
to n=5 (new bit)
• Need to touch every
single block (why ?)
Linear Hash Table Extension
Indexing (66 of 66)
(01)11
i=2
00
01
10
(10)10
(01)00
(11)00
11
Hash Tables (20 of 20)
 
 
 
