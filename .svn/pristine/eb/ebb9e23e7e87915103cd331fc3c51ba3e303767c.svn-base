10/17/13 1 
Programming Languages and 
Compilers (CS 421) 
Elsa L Gunter 
2112 SC, UIUC 
http://courses.engr.illinois.edu/cs421 
Based in part on slides by Mattox Beckman, as updated 
by Vikram Adve and Gul Agha 
10/17/13 2 
Background for Unification 
n  Terms made from constructors and variables (for 
the simple first order case) 
n  Constructors may be applied to arguments (other 
terms) to make new terms 
n  Variables and constructors with no arguments are 
base cases 
n  Constructors applied to different number of 
arguments (arity) considered different 
n  Substitution of terms for variables 
10/17/13 3 
Simple Implementation Background 
type term = Variable of string 
                    | Const of (string * term list) 
 
let rec subst var_name residue term = 
    match term with Variable name -> 
          if var_name = name then residue else term 
       | Const (c, tys) ->  
          Const (c, List.map (subst var_name residue)  
                                     tys);; 
10/17/13 4 
Unification Problem 
Given a set of pairs of terms (“equations”) 
{(s1, t1), (s2, t2), …, (sn, tn)}  
(the unification problem) does there exist  
a substitution σ (the unification solution) 
of terms for variables such that 
σ(si) = σ(ti),  
for all i = 1, …, n? 
10/17/13 5 
Uses for Unification 
n  Type Inference and type checking 
n  Pattern matching as in OCAML 
n  Can use a simplified version of algorithm 
n  Logic Programming - Prolog 
n  Simple parsing 
10/17/13 6 
Unification Algorithm 
n  Let S = {(s1, t1), (s2, t2), …, (sn, tn)}  be a 
unification problem. 
n  Case S = { }: Unif(S) = Identity function 
(i.e., no substitution) 
n  Case S = {(s, t)} ∪ S’: Four main steps 
10/17/13 7 
Unification Algorithm 
n  Delete: if s = t (they are the same term) 
then Unif(S) = Unif(S’) 
n  Decompose: if s = f(q1, … , qm) and        t 
=f(r1, … , rm) (same f, same m!), then 
   Unif(S) = Unif({(q1, r1), …, (qm, rm)} ∪ S’) 
n  Orient: if t = x is a variable, and s is not a 
variable, Unif(S) = Unif ({(x,s)} ∪ S’) 
10/17/13 8 
Unification Algorithm 
n  Eliminate: if s = x is a variable, and 
x does not occur in t (the occurs 
check), then 
n  Let ϕ = x |→ t 
n  Let ψ = Unif(ϕ(S’)) 
n  Unif(S) = {x |→ ψ(t)} o ψ 
n  Note: {x |→ a} o {y |→ b} =              
{y |→ ({x |→ a}(b))} o {x |→ a} if y 
not in a 
10/17/13 9 
Tricks for Efficient Unification 
n  Don’t return substitution, rather do it 
incrementally 
n  Make substitution be constant time 
n  Requires implementation of terms to use 
mutable structures (or possibly lazy 
structures) 
n  We won’t discuss these 
10/17/13 10 
Example 
n  x,y,z variables, f,g constructors 
n  S = {(f(x), f(g(y,z))), (g(y,f(y)), x)} 
 
10/17/13 11 
Example 
n  x,y,z variables, f,g constructors 
n  S is nonempty 
n  S = {(f(x), f(g(y,z))), (g(y,f(y)), x)} 
 
10/17/13 12 
Example 
n  x,y,z variables, f,g constructors 
n  Pick a pair: (g(y,f(y)), x) 
n  S = {(f(x), f(g(y,z))), (g(y,f(y)), x)} 
 
10/17/13 13 
Example 
n  x,y,z variables, f,g constructors 
n  Pick a pair: (g(y,f(y))), x) 
n  Orient: (x, g(y,f(y))) 
n  S = {(f(x), f(g(y,z))), (g(y,f(y)), x)} 
n  -> {(f(x), f(g(y,z))), (x, g(y,f(y)))} 
 
10/17/13 14 
Example 
n  x,y,z variables, f,g constructors 
n  S -> {(f(x), f(g(y,z))), (x, g(y,f(y)))} 
 
10/17/13 15 
Example 
n  x,y,z variables, f,g constructors 
n  Pick a pair: (f(x), f(g(y,z))) 
n  S -> {(f(x), f(g(y,z))), (x, g(y,f(y)))} 
 
10/17/13 16 
Example 
n  x,y,z variables, f,g constructors 
n  Pick a pair: (f(x), f(g(y,z))) 
n  Decompose: (x, g(y,z)) 
n  S -> {(f(x), f(g(y,z))), (x, g(y,f(y)))} 
n  -> {(x, g(y,z)), (x, g(y,f(y)))} 
 
10/17/13 17 
Example 
n  x,y,z variables, f,g constructors 
n  Pick a pair: (x, g(y,f(y))) 
n  Substitute: {x |-> g(y,f(y))} 
n  S -> {(x, g(y,z)), (x, g(y,f(y)))} 
n  -> {(g(y,f(y)), g(y,z))} 
n  With {x |-> g(y,f(y))} 
10/17/13 18 
Example 
n  x,y,z variables, f,g constructors 
n  Pick a pair: (g(y,f(y)), g(y,z)) 
n  S -> {(g(y,f(y)), g(y,z))} 
 
 
With {x |→ g(y,f(y))} 
10/17/13 19 
Example 
n  x,y,z variables, f,g constructors 
n  Pick a pair: (g(y,f(y)), g(y,z)) 
n  Decompose: (y, y) and (f(y), z) 
n  S -> {(g(y,f(y)), g(y,z))} 
n  -> {(y, y), (f(y), z)} 
 
With {x |→ g(y,f(y))} 
10/17/13 20 
Example 
n  x,y,z variables, f,g constructors 
n  Pick a pair: (y, y) 
n  S -> {(y, y), (f(y), z)} 
 
 
With {x |→ g(y,f(y))} 
10/17/13 21 
Example 
n  x,y,z variables, f,g constructors 
n  Pick a pair: (y, y) 
n  Delete 
n  S -> {(y, y), (f(y), z)} 
n  -> {(f(y), z)} 
 
With {x |→ g(y,f(y))} 
10/17/13 22 
Example 
n  x,y,z variables, f,g constructors 
n  Pick a pair: (f(y), z) 
n  S -> {(f(y), z)} 
 
 
With {x |→ g(y,f(y))} 
10/17/13 23 
Example 
n  x,y,z variables, f,g constructors 
n  Pick a pair: (f(y), z) 
n  Orient: (z, f(y)) 
n  S -> {(f(y), z)} 
n  -> {(z, f(y))} 
 
 
With {x |→ g(y,f(y))} 
10/17/13 24 
Example 
n  x,y,z variables, f,g constructors 
n  Pick a pair: (z, f(y)) 
n  S -> {(z, f(y))} 
 
 
With {x |→ g(y,f(y))} 
10/17/13 25 
Example 
n  x,y,z variables, f,g constructors 
n  Pick a pair: (z, f(y)) 
n  Eliminate: {z|-> f(y)} 
n  S -> {(z, f(y))} 
n  -> { } 
With {x |→ {z |→ f(y)} (g(y,f(y))) }   
       o {z |→ f(y)} 
10/17/13 26 
Example 
n  x,y,z variables, f,g constructors 
n  Pick a pair: (z, f(y)) 
n  Eliminate: {z|-> f(y)} 
n  S -> {(z, f(y))} 
n  -> { } 
With {x |→ g(y,f(y))} o {(z |→ f(y))} 
 
10/17/13 27 
Example 
S = {(f(x), f(g(y,z))), (g(y,f(y)),x)} 
Solved by {x |→ g(y,f(y))} o {(z |→ f(y))} 
f(g(y,f(y))) = f(g(y,f(y))) 
                         x                   z 
and 
 g(y,f(y)) = g(y,f(y)) 
                                         x 
10/17/13 28 
Example of Failure: Decompose 
n  S = {(f(x,g(y)), f(h(y),x))} 
n  Decompose: (f(x,g(y)), f(h(y),x)) 
n  S -> {(x,h(y)), (g(y),x)} 
n  Orient: (g(y),x) 
n  S -> {(x,h(y)), (x,g(y))} 
n  Eliminate: (x,h(y)) 
n  S -> {(h(y), g(y))} with {x |→ h(y)} 
n  No rule to apply! Decompose fails! 
10/17/13 29 
Example of Failure: Occurs Check 
n  S = {(f(x,g(x)), f(h(x),x))} 
n  Decompose: (f(x,g(x)), f(h(x),x)) 
n  S -> {(x,h(x)), (g(x),x)} 
n  Orient: (g(y),x) 
n  S -> {(x,h(x)), (x,g(x))} 
n  No rules apply.  
Major Phases of a Compiler 
Source Program 
Lex 
Tokens 
Parse 
Abstract Syntax 
Semantic 
Analysis 
Symbol Table 
Translate 
Intermediate 
Representation 
Modified from “Modern Compiler Implementation in ML”, by Andrew Appel 
Instruction 
Selection 
Optimized Machine-Specific 
Assembly Language 
Optimize 
Unoptimized Machine-
Specific Assembly Language 
Emit code 
Assembler 
Relocatable 
 Object Code 
Assembly Language 
Linker 
Machine 
Code 
Optimize 
Optimized IR 
10/17/13 31 
Meta-discourse 
n  Language Syntax and Semantics 
n  Syntax 
      - Regular Expressions, DFSAs and NDFSAs 
      - Grammars    
n  Semantics 
      - Natural Semantics 
      - Transition Semantics 
10/17/13 32 
Language Syntax 
n  Syntax is the description of which strings of 
symbols are meaningful expressions in a 
language 
n  It takes more than syntax to understand a 
language; need meaning (semantics) too 
n  Syntax is the entry point 
10/17/13 33 
Syntax of English Language 
n  Pattern 1 
n  Pattern 2 
10/17/13 34 
Elements of Syntax 
n  Character set – previously always ASCII, 
now often 64 character sets 
n  Keywords – usually reserved 
n  Special constants – cannot be assigned to 
n  Identifiers – can be assigned to 
n  Operator symbols 
n  Delimiters (parenthesis, braces, brackets) 
n  Blanks (aka white space) 
10/17/13 35 
Elements of Syntax 
n  Expressions 
           if ... then begin ... ; ... end else begin ... ; ... end 
n  Type expressions 
            typexpr1 ->  typexpr2        
n  Declarations (in functional languages) 
            let pattern1 =  expr1 in  expr     
n  Statements (in imperative languages) 
           a = b + c   
n  Subprograms 
             let pattern1 =  let rec inner = … in  expr 
10/17/13 36 
Elements of Syntax 
n  Modules 
n  Interfaces 
n  Classes (for object-oriented languages) 
10/17/13 37 
Lexing and Parsing 
n  Converting strings to abstract syntax trees 
done in two phases 
n  Lexing: Converting string (or streams of 
characters) into lists (or streams) of 
tokens (the “words” of the language) 
n  Specification Technique: Regular Expressions 
n  Parsing: Convert a list of tokens into an 
abstract syntax tree 
n  Specification Technique: BNF Grammars 
10/17/13 38 
Formal Language Descriptions 
n  Regular expressions, regular grammars, 
finite state automata 
n  Context-free grammars, BNF grammars, 
syntax diagrams 
n  Whole family more of grammars and 
automata – covered in automata theory 
10/17/13 39 
Grammars 
n  Grammars are formal descriptions of which 
strings over a given character set are in a 
particular language 
n  Language designers write grammar 
n  Language implementers use grammar to 
know what programs to accept 
n  Language users use grammar to know how 
to write legitimate programs 
