1 
Building  an  ALU  (Part  1):  
	  
2 
Today’s  lecture  
  We  start  building  our  computer!  
  We’ll	  start	  with	  the	  arithme.c/logic	  unit	  (ALU)	  
  Adding  single  bits  
  Half	  Adders	  and	  Full	  Adder	  
  MulA-­‐bit  ArithmeAc  
  Hierarchical	  design	  
  Subtrac.on	  
  Building  a  Logic  Unit  
  Mul.plexors	  
3 
ArithmeAc  Logic  Units  (ALUs)  
  The  computaAon  in  a  computer  processor  takes  place  in  the  
arithmeAc  logic  unit.    This  unit  performs:  
  Arithme.c	  opera.ons	  
  e.g.,	  addi.on	  and	  subtrac.on	  
  Bit-­‐wise	  logical	  opera.ons	  
  e.g.,	  AND,	  OR,	  NOT,	  XOR	  
  Typically  these  operaAons  are  performed  on  mulA-­‐bit  words  
  The	  MIPS-­‐subset	  processor	  we	  will	  build	  uses	  32-­‐bit	  words	  
In Lab 3 you will build a 32-bit ALU with the above operations 
4 
Binary  AddiAon  Review  
 1  1  1  0   Carries 
  1  0  1  1  Augend 
+   1  1  1  0  Addend 
 1  1  0  0  1  Sum 
5 
First  Bit  PosiAon  
 1  1  1  0   Carries 
  1  0  1  1  Augend 
+   1  1  1  0  Addend 
 1  1  0  0  1  Sum 
Two input bits;  
We’ll call them x, y 
c = carry out 
(from first column) 
s = Sum Two  output  bits:  
6 
First  Bit  PosiAon’s  Truth  Table  
 1  1  1  0   Carries 
  1  0  1  1  Augend 
+   1  1  1  0  Addend 
 1  1  0  0  1  Sum 
Two input bits;  
We’ll call them x, y 
c = carry out 
(from first column) 
s = Sum 
X" Y" C" S"
0" 0" " "
0" 1" " "
1" 0" " "
1" 1" " "
 
 
7 
Half  Adder  
  Adds  two  input  bits  to  produce  a  sum  and  carry  out.  
  carry  out  is  worth  twice  as  much  as  the  sum  bit  
X" Y" C" S"
0" 0" 0" 0"
0" 1" 0" 1"
1" 0" 0" 1"
1" 1" 1" 0"
 
 
C   =  XY  
S   =  X’Y  +  XY’  
  =  X  ⊕  Y  
XOR  
8 
Second  Bit  PosiAon  
  (and  every  subsequent  posiAon)  
 1  1  1  0   Carries 
  1  0  1  1  Augend 
+   1  1  1  0  Addend 
 1  1  0  0  1  Sum 
Three input bits;  
x, y, carry_in 
c = carry out 
(from first column) 
s = Sum 
SAll  two  output  bits:  
9 
Second  Bit  PosiAon’s  Truth  Table  
  Adding  3  bits  together  to  get  a  two  bit  number  
!
X! Y! Cin! Cout! S!
0! 0! 0! ! !
0! 0! 1! ! !
0! 1! 0! ! !
0! 1! 1! ! !
1! 0! 0! ! !
1! 0! 1! ! !
1! 1! 0! ! !
1! 1! 1! ! !
!
0   +  0   +  0   =  00  
0   +  0   +  1   =  01  
0   +  1   +  0   =  01  
0   +  1   +  1   =  10  
1   +  0   +  0   =  01  
1   +  0   +  1   =  10  
1   +  1   +  0   =  10  
1   +  1   +  1   =  11  
10 
Full  Adder  
  Adds  three  input  bits  to  produce  a  sum  and  carry  out.  
	  
!
X! Y! Cin! Cout! S!
0! 0! 0! 0! 0!
0! 0! 1! 0! 1!
0! 1! 0! 0! 1!
0! 1! 1! 1! 0!
1! 0! 0! 0! 1!
1! 0! 1! 1! 0!
1! 1! 0! 1! 0!
1! 1! 1! 1! 1!
!
S     =  X  ⊕  Y  ⊕  Cin  
Cout   =  XY  +  (X  ⊕  Y)Cin    
11 
Full  Adder  Circuit  
  A  Full  Adder  can  be  built  with  two  half  adders  
	  
S     =  X  ⊕  Y  ⊕  Cin  
Cout   =  XY  +  (X  ⊕  Y)Cin    
Half  Adder  EquaAons  
C   =  XY  
S   =  X  ⊕  Y  
12 
Building  mulA-­‐bit  adders  
  Recall  our  discussion  about  hierarchical  design  
  (The  stop  lights  to  prevent  train  collisions…)  
  We’re  going  to  build  mulA-­‐bit  adders  by  chaining  full  adders  
  Example:    4-­‐bit  adder  
 CO C3  C2  C1   Carries 
  A3  A2  A1  A0  Augend 
+   B3  B2  B1  B0  Addend 
  S3  S2  S1  S0  Sum 
13 
An  example  of  4-­‐bit  addiAon  
  Let’s  try  our  iniAal  example:  A=1011  (eleven),  B=1110  (fourteen).  
1  1  1  0  1  1  0  1 
0 
14 
An  example  of  4-­‐bit  addiAon  
  Let’s  try  our  iniAal  example:  A=1011  (eleven),  B=1110  (fourteen).  
1  1  1  0  1  1  0  1 
0 
1.      Fill  in  all  the  inputs,  including  CI=0  
1  1 
5.     Use  C3  to  compute  CO  and  S3  (1  +  1  +  1  =  11)  
0 
2.     The  circuit  produces  C1  and  S0  (1  +  0  +  0  =  01)  
1 
1 
3.     Use  C1  to  find  C2  and  S1  (1  +  1  +  0  =  10)  
0 
1 
4.     Use  C2  to  compute  C3  and  S2  (0  +  1  +  1  =  10)  
0 
Woohoo!  The  final  answer  is  11001  (twenty-­‐five)  if  we  consider  it  a  5-­‐bit  output.  
15 
ImplemenAng  SubtracAon  
  We  said  last  Ame  that  we  implement  subtracAon  
  By	  nega.ng	  the	  second	  input	  and	  then	  adding	  
A  -­‐  B  =  A  +  (-­‐B)  
  NegaAng  in  2’s  complement  is  
  Inver.ng	  the	  bits	  and	  adding	  one	  
-­‐B  =  ~B  +  1  
  
  SubsAtuAng  in:  
A  -­‐  B  =  A  +  (-­‐B)  =                        .	  
16 
ImplemenAng  SubtracAon,  cont.  
17 
AddiAon  +  SubtracAon  in  one  circuit  
  XOR  gates  let  us  selecAvely  complement  the  B  input.  
     X  ⊕  0  =  X   X  ⊕  1  =  X’  
  When  Sub  =  0,  Y  =  B  and  Cin  =  0.    Result  =  A  +  B  +  0  =  A  +  B.  
  When  Sub  =  1,  Y  =  ~B  and  Cin  =  1.    Result  =  A  +  ~B  +  1  =  A  –  B.  
18 
Data  vs.  Control  
  We’ll  delineate  two  groups  of  signals  in  the  hardware  
  Datapath  
  These  generally  carry  the  numbers  we’re  crunching  
  E.g.,  the  X  and  Y  inputs  and  the  output  S  
  Control  
  These  generally  control  how  data  flows  and  what  
operaBons  are  performed  
  E.g.,  the  SUB  signal.  
19 
Logical  OperaAons  
  In  addiAon  to  ADD  and  SUBTRACT,  we  want  our  ALU  to  
perform  bit-­‐wise  AND,  OR,  NOT,  and  XOR.  
  This  should  be  straight  forward.  
  We	  have	  gates	  that	  perform	  each	  of	  these	  opera.ons.	  
X    
Y  
20 
SelecAng  the  desired  logical  operaAon  
  We  need  a  control  signal  to  specify  the  desired  operaAon:  
  We’ll	  call	  that	  sign	  R	  
  4	  opera.ons	  means	  R	  is	  2	  bits	  
  We  need  a  circuit  to  perform  the  selecAon:  
R1 R0 Output 
0 0 Gi = XiYi 
0 1 Gi = Xi + Yi 
1 0 Gi = Xi’  
1 1 Gi = Xi ⊕ Yi 
 
 
AND
OR
NOT
XOR
X
Y G
R1
R0
21 
MulAplexors  
  A  mulAplexor  is  a  circuit  that  (logically)  selects  one  of  its  
inputs  to  connect  to  its  output  
  Consider  a  2-­‐to-­‐1  mulAplexor.    It  has:  
  2	  data	  inputs	  (I0,I1)	  
  a	  1-­‐bit	  control	  input	  (S)	  
  1	  data	  output	  (Y)	  
  The  control  input  selects  which  data  input  is  output:  
Y = S’I0 + SI1!
0
1
I0
I1
Y
S
S Y 
0 I0 
1 I1 
 
22 
MulAplexors,  cont.  
  In  general,  a  mulAplexor  (mux)  has:  
  2N	  data	  inputs	  (I -I  )	  
  an	  N-­‐bit	  control	  input	  (S)	  
  1	  data	  output	  (Y)	  
  If  S = K then  Y = IK!
  Examples:  
  4-­‐to-­‐1	  mux:	   	  4	  data	  inputs,	  2-­‐bit	  control	  input	  
  Y = S0’S1’I0 + S0S1’I1 + S0’S1I2 + S0S1I3!
  16-­‐to-­‐1	  mux:	  	  	  	  16	  data	  inputs,	  4-­‐bit	  control	  input	  
2N-1!0!
23 
Complete  1-­‐bit  Logic  Unit  
AND
OR
NOT
XOR
X
Y
I0
S1
G
S0
I1
I2
I3
Y
R1
R0
R1 R0 Output 
0 0 Gi = XiYi 
0 1 Gi = Xi + Yi 
1 0 Gi = Xi’  
1 1 Gi = Xi ⊕ Yi 
 
 
