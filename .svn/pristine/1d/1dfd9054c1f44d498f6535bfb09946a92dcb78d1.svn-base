1 
MIPS	  assembly	  programming:	  
2 
Today’s	  lecture	  
  Exam	  Structure	  
  Review	  the	  Datapath	  
  Trace	  a	  couple	  of	  instruc0ons	  
  Assembly	  programming	  
  Register	  names	  
  How	  is	  it	  implemented?	  
  Branches	  
  Loops	  
  If/then/else	  
  How	  implemented?	  
3 
Exam	  Structure	  
  3	  main	  capabiliDes	  that	  you	  need	  to	  demonstrate:	  
1.  Combina0onal	  Design	  	  	   	   	  (e.g.,	  steering	  circuit)	  
2.  Sequen0al	  Design	  	  	  	  	  	  	  	  	  	   	   	  (e.g.,	  character	  
	   	   	   	   	  	  	  	  	  	  	  	  	  	  	  recognizer)	  
3.  Processor	  Datapath	  and	  Control	  	  	   	  (e.g.,	  Lab	  6)	  
(all	  of	  these	  will	  be	  available	  for	  the	  2nd	  chance	  exam)	  
  In	  addiDon	  there	  will	  be	  a	  number	  of	  short	  answer	  quesDons	  
  Covering	  topics	  selected	  from	  all	  of	  the	  lectures	  
  (e.g.,	  mul0ple	  choice,	  true/false,	  short	  answer)	  
  The	  web	  problems	  are	  good	  examples	  of	  these	  ques0ons.	  
4 
2 (Add)
32
alu_op[2:0]
write_enable
itype
except
opcode[5:0]
funct[5:0]
MIPS decoder
A[31:0]
alu_op[2:0]
out
[31:0]
B[31:0]
ALU
rsDatarsNum
reset
rdNum
rtDatartNum
rdWriteEnable
rdData
Register File
reset
clk
wr_enable
Rdest
Rt
Rs
zero
negative
overflow
0
1
wr_enable
itype
itype
alu_op[2:0]
reset
enable
Q[31:0]
D[31:0]
PC Register
Sign 
Extender
out[31:0]
in[15:0]
data[31:0]
addr[29:0]
Instruction
Memory
4
inst[31:0]
PC[31:0]
ALU
1
nextPC[31:0]
0
1
itype
inst[25:21]
inst[20:16]
inst[15:11]
inst[20:16]
inst[5:0]
inst[15:0]
inst[31:26]
except
PC
[3
1:
2]
Rt
Rd
imm16
imm32
32
30
32
3
5
5
5
16
32
6
6
32
32
32
32
32
3
3
out[1:0]
0123
control_type
0 1 2 3
2 (Add)
ALU
3
Shift Left 2
out[31:0]
in[29:0]30 32
inst[25:0]
00 (for LSBs)
PC[31:28] (for MSBs)
branch
offset
branch
offset
32
control_type control_type
0 1
slt
01lui
16
16'b0
data_out[31:0]
addr[31:0]
Data
Memory
31'b0
zero
0
1
mem_read
da
ta
_o
ut
[3
1:
24
]
da
ta
_o
ut
[2
3:
16
]
da
ta
_o
ut
[1
5:
8]
da
ta
_o
ut
[7
:0
]
24'b00
1
byte_load
8
lui lui
slt slt
byte_load byte_load
32
26
word_we word_we
byte_we byte_we
word_we
byte_we
data_in[31:0]
word_we
byte_we
reset
32
32
mem_read mem_read
lw 	  	  $5,	  1024($2)	  
M I P S Reference Data
BASIC INSTRUCTION FORMATS
REGISTER NAME, NUMBER, USE, CALL CONVENTION
CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION (in Verilog)
/ FUNCT
(Hex)
Add add R R[rd] = R[rs] + R[rt] (1) 0 / 20hex
Add Immediate addi I R[rt] = R[rs] + SignExtImm (1,2) 8hex
Add Imm. Unsigned addiu I R[rt] = R[rs] + SignExtImm  (2) 9hex
Add Unsigned addu R R[rd] = R[rs] + R[rt] 0 / 21hex
And and R R[rd] = R[rs] & R[rt] 0 / 24hex
And Immediate andi I R[rt] = R[rs] & ZeroExtImm (3) chex
Branch On Equal beq I if(R[rs]==R[rt])  PC=PC+4+BranchAddr (4)
4hex
Branch On Not Equalbne I if(R[rs]!=R[rt])  PC=PC+4+BranchAddr (4)
5hex
Jump j J PC=JumpAddr (5) 2hex
Jump And Link jal J R[31]=PC+8;PC=JumpAddr (5) 3hex
Jump Register jr R PC=R[rs] 0 / 08hex
Load Byte Unsigned lbu I R[rt]={24’b0,M[R[rs]            +SignExtImm](7:0)} (2)
24hex
Load Halfword 
Unsigned lhu I
R[rt]={16’b0,M[R[rs]
            +SignExtImm](15:0)} (2)
25hex
Load Linked ll I R[rt] = M[R[rs]+SignExtImm] (2,7) 30hex
Load Upper Imm. lui I R[rt] = {imm, 16’b0} fhex
Load Word lw I R[rt] = M[R[rs]+SignExtImm] (2) 23hex
Nor nor R R[rd] = ~ (R[rs] | R[rt]) 0 / 27hex
Or or R R[rd] = R[rs] | R[rt] 0 / 25hex
Or Immediate ori I R[rt] = R[rs] | ZeroExtImm (3) dhex
Set Less Than slt R R[rd] = (R[rs] < R[rt]) ? 1 : 0 0 / 2ahex
Set Less Than Imm. slti I R[rt] = (R[rs] < SignExtImm)? 1 : 0 (2) ahex
Set Less Than Imm. 
Unsigned sltiu I
R[rt] = (R[rs] < SignExtImm) 
                    ? 1 : 0  (2,6)
bhex
Set Less Than Unsig. sltu R R[rd] = (R[rs] < R[rt]) ? 1 : 0  (6) 0 / 2bhex
Shift Left Logical sll R R[rd] = R[rt] << shamt 0 / 00hex
Shift Right Logical srl R R[rd] = R[rt] >> shamt 0 / 02hex
Store Byte sb I M[R[rs]+SignExtImm](7:0) =                             R[rt](7:0) (2)
28hex
Store Conditional sc I M[R[rs]+SignExtImm] = R[rt];               R[rt] = (atomic) ? 1 : 0 (2,7)
38hex
Store Halfword sh I M[R[rs]+SignExtImm](15:0) =                                  R[rt](15:0) (2)
29hex
Store Word sw I M[R[rs]+SignExtImm] = R[rt] (2) 2bhex
Subtract sub R R[rd] = R[rs] - R[rt] (1) 0 / 22hex
Subtract Unsigned subu R R[rd] = R[rs] - R[rt] 0 / 23hex
(1) May cause overflow exception
(2) SignExtImm = { 16{immediate[15]}, immediate }
(3) ZeroExtImm = { 16{1b’0}, immediate }
(5) JumpAddr =    { PC+4[31:28], address, 2’b0 }
(7) Atomic test&set pair; R[rt] = 1 if pair atomic, 0 if not atomic
R opcode rs rt rd shamt funct
31 26 25 21 20 16 15 11 10 6 5 0
I opcode rs rt immediate
31 26 25 21 20 16 15 0
J opcode address
31 26 25 0
ARITHMETIC CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION 
/ FMT /FT
/ FUNCT
(Hex)
Branch On FP True bc1t FI if(FPcond)PC=PC+4+BranchAddr (4) 11/8/1/--
Branch On FP False bc1f FI if(!FPcond)PC=PC+4+BranchAddr(4) 11/8/0/--
Divide div R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] 0/--/--/1a
Divide Unsigned divu R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] (6) 0/--/--/1b
FP Add Single add.s FR F[fd ]= F[fs] + F[ft] 11/10/--/0
FP Add 
Double add.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} + 
                               {F[ft],F[ft+1]}
11/11/--/0
FP Compare Single c.x.s* FR FPcond = (F[fs] op F[ft]) ? 1 : 0 11/10/--/y
FP Compare 
Double c.x.d* FR
FPcond = ({F[fs],F[fs+1]} op
                   {F[ft],F[ft+1]}) ? 1 : 0
11/11/--/y
* (x is eq, lt, or le)  (op is ==, <, or <=) ( y is 32, 3c, or 3e)
FP Divide Single div.s FR F[fd] = F[fs] / F[ft] 11/10/--/3
FP Divide 
Double div.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} / 
                               {F[ft],F[ft+1]}
11/11/--/3
FP Multiply Single mul.s FR F[fd] = F[fs] * F[ft] 11/10/--/2
FP Multiply 
Double mul.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} * 
                               {F[ft],F[ft+1]}
11/11/--/2
FP Subtract Single sub.s FR F[fd]=F[fs] - F[ft] 11/10/--/1
FP Subtract 
Double sub.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} - 
                               {F[ft],F[ft+1]}
11/11/--/1
Load FP Single lwc1 I F[rt]=M[R[rs]+SignExtImm] (2) 31/--/--/--
Load FP 
Double ldc1 I
F[rt]=M[R[rs]+SignExtImm]; (2)
F[rt+1]=M[R[rs]+SignExtImm+4]
35/--/--/--
Move From Hi mfhi R R[rd] = Hi 0 /--/--/10
Move From Lo mflo R R[rd] = Lo 0 /--/--/12
Move From Control mfc0 R R[rd] = CR[rs] 10 /0/--/0
Multiply mult R {Hi,Lo} = R[rs] *  R[rt] 0/--/--/18
Multiply Unsigned multu R {Hi,Lo} = R[rs] *  R[rt] (6) 0/--/--/19
Shift Right Arith. sra R R[rd] = R[rt] >>> shamt 0/--/--/3
Store FP Single swc1 I M[R[rs]+SignExtImm] = F[rt] (2) 39/--/--/--
Store FP 
Double sdc1 I
M[R[rs]+SignExtImm] = F[rt]; (2) 
M[R[rs]+SignExtImm+4] = F[rt+1]
3d/--/--/--
FR opcode fmt ft fs fd funct
31 26 25 21 20 16 15 11 10 6 5 0
FI opcode fmt ft immediate
31 26 25 21 20 16 15 0
NAME MNEMONIC OPERATION
Branch Less Than blt if(R[rs]<R[rt]) PC = Label
Branch Greater Than bgt if(R[rs]>R[rt]) PC = Label
Branch Less Than or Equal ble if(R[rs]<=R[rt]) PC = Label
Branch Greater Than or Equal bge if(R[rs]>=R[rt]) PC = Label
Load Immediate li R[rd] = immediate
Move move R[rd] = R[rs]
NAME NUMBER USE PRESERVED ACROSS A CALL?
$zero 0 The Constant Value 0 N.A.
$at 1 Assembler Temporary No
$v0-$v1 2-3 Values for Function Results and Expression Evaluation No
$a0-$a3 4-7 Arguments No
$t0-$t7 8-15 Temporaries No
$s0-$s7 16-23 Saved Temporaries Yes
$t8-$t9 24-25 Temporaries No
$k0-$k1 26-27 Reserved for OS Kernel No
$gp 28 Global Pointer Yes
$sp 29 Stack Pointer Yes
$fp 30 Frame Pointer Yes
$ra 31 Return Address Yes
1 2
M
IP
S 
 R
ef
er
en
ce
 D
at
a 
C
ar
d 
(“G
re
en
 C
ar
d”
)
1.
 P
ul
l a
lo
ng
 p
er
fo
ra
tio
n 
to
 s
ep
ar
at
e 
ca
rd
2.
 F
ol
d 
bo
tto
m
 s
id
e 
(c
ol
um
ns
 3
 a
nd
 4
) 
to
ge
th
er
FLOATING-POINT INSTRUCTION FORMATS
PSEUDOINSTRUCTION SET
Copyright 2009 by Elsevier, Inc., All rights reserved. From Patterson and Hennessy, Computer Organization and Design, 4th ed.
(4) BranchAddr = { 14{immediate[15]}, immediate, 2’b0 }
’(6) Operands considered unsigned numbers (vs. 2 s comp.)
M I P S Refe ence Data
BASIC INSTRUCTION FORMATS
REGISTER NAME, NUMBER, USE, CALL CONVENTION
CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION (in Verilog)
/ FUNCT
(Hex)
Add add R R[rd] = R[rs] + R[rt] (1) 0 / 20hex
Add Immediate addi I R[rt] = R[rs] + SignExtImm (1,2) 8hex
Add Imm. Unsigned addiu I R[rt] = R[rs] + SignExtImm  (2) 9hex
Add Unsigned addu R R[rd] = [rs] + R[rt] 0 / 21hex
And and R R[rd] = s] & [rt] 0 / 24hex
And Immediate andi I R[rt] = R[rs] & ZeroExtImm (3) chex
Branch On Equal beq I if(R[rs]==R[rt])  PC=PC+4+BranchAddr (4)
4hex
Branch On Not Equalbne I if(R[rs]!=R[rt])  PC=PC+4+BranchAddr (4)
5hex
Jump j J PC=JumpAddr (5) 2hex
Jump And Link jal J R[31]=PC+8;PC=JumpAddr (5) 3hex
Jump Register jr R PC=R[rs] 0 / 08hex
Load Byte Unsigned lbu I R[rt]={24’b0,M[R[rs]            +SignExtImm](7:0)} (2)
24hex
Load Halfword 
Unsigned lhu I
R[rt]={16’b0,M[R[rs]
            +SignExtImm](15:0)} (2)
25hex
Load Linked ll I R[rt] = M[R[rs]+SignExtImm] (2,7) 30hex
Load Upper Imm. lui I R[rt] = {imm, 16’b0} fhex
Load Word lw I R[rt] = M[R[rs]+SignExtImm] (2) 23hex
Nor nor R R[rd] = ~ (R[rs] | R[rt]) 0 / 27hex
Or or R R[rd] = [rs] | R[rt] 0 / 25hex
Or Immediate ori I R[rt] = R[rs] | ZeroExtImm (3) dhex
Set Less Than slt R R[rd] = (R[rs] < [rt]) ? 1 : 0 0 / 2ahex
Set Less Than Imm. slti I R[rt] = (R[rs] < SignExtImm)? 1 : 0 (2) ahex
Set Less Than Imm. 
Unsigned sltiu I
R[rt] = (R[rs] < SignExtImm) 
                    ? 1 : 0  (2,6)
bhex
Set Less Than Unsig. sltu R R[rd] = (R[rs] < [rt]) ? 1 : 0  (6 0 / 2bhex
Shift Left ogical sll R R[rd] = t] << shamt 0 / 00hex
Shift Right Logical srl R R[rd] = R[rt] >> shamt 0 / 02hex
Store Byte sb I M[R[rs]+SignExtImm (7:0) =                             R[rt](7:0) (2)
28hex
Store Conditional sc I M[R[rs]+SignExtImm] = R[rt];               R[rt]  (atomic) ? 1 : 0 (2,7)
38hex
Store Halfword sh I M[R[rs]+SignExtImm](15:0) =                                  R[rt](15:0) (2)
29hex
Store Word sw I M[R[rs]+SignExtImm] = R[rt] (2) 2bhex
Subtract sub R R[rd] = R[rs] - R[rt] ( ) 0 / 22hex
Subtract Unsigned subu R R[rd] = R[rs] - R[rt] 0 / 23hex
(1) May cause overflow exception
(2) SignExtImm = { 16{immediate[15]}, immediate }
(3) ZeroExtImm = { 16{1b’0}, immediate }
(5) JumpAddr =    { PC+4[31:28], address, 2’b0 }
(7) Atomic test&set pair; R[rt] = 1 if pair atomic, 0 if not atomic
R opcode rs rt rd shamt funct
31 26 25 21 20 16 15 11 10 6 5 0
I opcode rs rt immediate
31 26 25 21 20 16 15 0
J opcode address
31 26 25 0
ARITHMETIC CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION 
/ FMT /FT
/ FUNCT
(Hex)
Branch On FP True bc1t FI if(FPcond)PC=PC+4+BranchAddr (4) 11/8/1/--
Branch On FP False bc1f FI if(!FPcond)PC=PC+4+BranchAddr(4) 11/8/0/--
Divide div R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] 0/--/--/1a
Divide Unsigned divu R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] (6) 0/--/--/1b
FP Add Single add.s FR F[fd ]= F[fs] + F[ft] 11/10/--/0
FP Add 
Double add.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} + 
                               {F[ft],F[ft+1]}
11/11/--/0
FP Compare Single c.x.s* FR FPcond = (F[fs] op F[ft]) ? 1 : 0 11/10/--/y
FP Compare 
Double c.x.d* FR
FPcond = ({F[fs],F[fs+1]} op
                   {F[ft],F[ft+1]}) ? 1 : 0
11/11/--/y
* (x is eq, lt, or le)  (op is ==, <, or <=) ( y is 32, 3c, or 3e)
FP Divide Single div.s FR F[fd] = F[fs] / F[ft] 11/10/--/3
FP Divide 
Double div.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} / 
                               {F[ft],F[ft+1]}
11/11/--/3
FP Multiply Single mul.s FR F[fd] = F[fs] * F[ft] 11/10/--/2
FP Multiply 
Double mul.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} * 
                               { [ft],F[ft+1]}
11/11/--/2
FP Subtract Single sub.s FR F[fd]=F[fs] - F[ft] 11/10/--/1
FP Subtract 
Double sub.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} - 
                               {F[ft],F[ft+1]}
11/11/--/1
Load FP Single lwc1 I F[rt]=M[R[rs]+SignExtImm] (2) 31/--/--/--
Load FP 
Double ldc1 I
F[rt]=M[R[rs]+SignExtImm]; (2)
F[rt+1]=M[R[rs]+SignExtImm+4]
35/--/--/--
Move From Hi mfhi R R[rd] = Hi 0 /--/--/10
Move From Lo mflo R R[rd] = Lo 0 /--/--/12
Move From C ntrol mfc0 R R[rd] = C [rs] 10 /0/--/0
Multiply mult R {Hi,Lo} = R[rs] *  R[rt] 0/--/--/18
Multiply Unsigned multu R {Hi,Lo} = R[rs] *  R[rt] (6) 0/--/--/19
Shift Right Arith. sra R R[rd] = R[rt] >>> shamt 0/--/--/3
Store FP Single swc1 I M[R[rs]+SignExtImm] = F[rt] (2) 39/--/--/--
Stor  FP 
Double sdc1 I
M[R[rs]+SignExtImm] = F[rt]; (2) 
M[R[rs]+SignExtImm+4] = F[rt+1]
3d/--/--/--
FR opcod fmt ft fs fd funct
31 26 25 21 20 16 15 11 10 6 5 0
FI opcode fmt ft immediate
31 26 25 21 20 16 15 0
NAME MNEMONIC OPERATION
Branch Less Than blt if(R[rs]<R[rt]) PC = Label
Branch Greater Than bgt if(R[rs]>R[rt]) PC = Label
Branch Less Than or Equal ble if(R[rs]<=R[rt]) PC = Label
Branch Greater Than or Equal bge if(R[rs]>=R[rt]) PC = Label
Load Immediate li R[rd] = immediate
Move move R[rd] = R[rs]
NAME NUMBER USE PRESERVED ACROSS A CALL?
$zero 0 The Constant Value 0 N.A.
$at 1 Assembler Temporary No
$v0-$v1 2-3 Values for Function Results and Expression Evaluation No
$a0-$a3 4-7 Arguments No
$t0-$t7 8-15 Temporaries No
$s0-$s7 16-23 Saved Temporaries Yes
$t8-$t9 24-25 Temporaries No
$k0-$k1 26-27 Reserved for OS Kernel No
$gp 28 Global Pointer Yes
$sp 29 Stack Pointer Yes
$fp 30 Frame Pointer Yes
$ra 31 Return Address Yes
1 2
M
IP
S 
 R
ef
er
en
ce
 D
at
a 
Ca
rd
 (“
Gr
ee
n
 C
ar
d”
)
1.
 P
ul
l a
lo
ng
 p
er
fo
ra
tio
n 
to
 s
ep
ar
at
e 
ca
rd
2.
 F
ol
d 
bo
tto
m
 s
id
e 
(c
ol
um
ns
 3
 a
nd
 4
) t
og
et
he
r
FLOATING-POINT INSTRUCTION FORMATS
PSEUDOINSTRUCTION SET
Copyright 2009 by Elsevier, Inc., All rights reserved. From Patterson and Hennessy, Computer Organization and Design, 4th ed.
(4) BranchAddr = { 14{immediate[15]}, immediate, 2’b0 }
’(6) Operands considered unsigned numbers (vs. 2 s comp.)
M I P S Reference Data
BASIC INSTRUCTION FORMATS
REGISTER NAME, NUMBER, USE, CALL CONVENTION
CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION (in Verilog)
/ FUNCT
(Hex)
Add add R R[rd] = R[rs] + R[rt] (1) 0 / 20hex
Add Immediate addi I R[rt] = R[rs] + SignExtImm (1,2) 8hex
Add Imm. Unsigned addiu I R[rt] = R[rs] + SignExtImm  (2) 9hex
Add Unsigned addu R R[rd] = R[rs] + R[rt] 0 / 21hex
And and R R[rd] = R[rs] & R[rt] 0 / 24hex
And Immediate andi I R[rt] = R[rs] & ZeroExtImm (3) chex
Branch On Equal beq I if(R[rs]==R[rt])  PC=PC+4+BranchAddr (4)
4hex
Branch On Not Equalbne I if(R[rs]!=R[rt])  PC=PC+4+BranchAddr (4)
5hex
Jump j J PC=JumpAddr (5) 2hex
Jump And Link jal J R[31]=PC+8;PC=JumpAddr (5) 3hex
Jump Register jr R PC=R[rs] 0 / 08hex
Load Byte Unsigned lbu I R[rt]={24’b0,M[R[rs]            +SignExtImm](7:0)} (2)
24hex
Load Halfword 
Unsigned lhu I
R[rt]={16’b0,M[R[rs]
            +SignExtImm](15:0)} (2)
25hex
Load Linked ll I R[rt] = M[R[rs]+SignExtImm] (2,7) 30hex
Load Upper Imm. lui I R[rt] = {imm, 16’b0} fhex
Load Word lw I R[rt] = M[R[rs]+SignExtImm] (2) 23hex
Nor nor R R[rd]  ~ (R[rs] | R[rt]) 0 / 27hex
Or or R R[rd] = R[rs] | R[rt] 0 / 25hex
Or Immediate ori I R[rt] = R[rs] | ZeroExtImm (3) dhex
Set Less Than slt R R[rd] = (R[rs] < R[rt]) ? 1 : 0 0 / 2ahex
Set Less Than Imm. slti I R[rt] = (R[rs] < SignExtImm)? 1 : 0 (2) ahex
Set Less Than Imm. 
Unsigned sltiu I
R[rt] = (R[rs] < SignExtImm) 
                    ? 1 : 0  (2,6)
bhex
Set Less Than Unsig. sltu R R[rd] = (R[rs] < R[rt]) ? 1 : 0  (6) 0 / 2bhex
Shift Left Logical sll R R[rd] = R[rt] << shamt 0 / 00
Shift Right Logical srl R R[rd] = R[rt] >> shamt 0 / 02hex
Store Byte sb I M[R[rs]+SignExtImm](7:0) =                             R[rt](7:0) (2)
28hex
Store Conditional sc I M[R[rs]+SignExtImm] = R[rt];               R[rt] = (atomic) ? 1 : 0 (2,7)
38hex
Store Halfword sh I M[R[rs]+SignExtImm](15:0) =                                  R[rt](15:0) (2)
29hex
Store Word sw I [ [rs]+Sign xtI ] = R[rt] (2) 2bhex
Subtract sub R R[rd] = R[rs] - R[rt] (1) 0 / 22hex
Subtract Unsigned subu R R[rd] = R[rs] - R[rt] 0 / 23hex
(1) May cause overflow exception
(2) SignExtImm = { 16{immediate[15]}, i mediate }
(3) ZeroExtImm = { 16{1b’0}, immediate }
(5) JumpAddr =    { PC+4[31:28], address, 2’b0 }
(7) Atomic test&set pair; R[rt] = 1 if pair atomic, 0 if not atomic
R opcode rs rt rd shamt funct
31 26 25 21 20 16 15 11 10 6 5 0
I opcode rs rt immediate
31 26 25 21 20 16 15 0
J opcode address
31 26 25 0
ARITHMETIC CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION 
/ FMT /FT
/ FUNCT
(Hex)
Branch On FP True bc1t FI if(FPcond)PC=PC+4+BranchAddr (4) 11/8/1/--
Branch On FP False bc1f FI if(!FPcond)PC=PC+4+BranchAddr(4) 11/8/0/--
Divide div R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] 0/--/--/1a
Divide Unsigned divu R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] (6) 0/--/--/1b
FP Add Single add.s FR F[fd ]= F[fs] + F[ft] 11/10/--/0
FP Add 
Double add.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} + 
                               {F[ft],F[ft+1]}
11/11/--/0
FP Compare Single c.x.s* FR FPcond = (F[fs] op F[ft]) ? 1 : 0 11/10/--/y
FP Compare 
Double c.x.d* FR
FPcond = ({F[fs],F[fs+1]} op
                   {F[ft],F[ft+1]}) ? 1 : 0
11/11/--/y
* (x is eq, lt, or le)  (op is ==, <, or <=) ( y is 32, 3c, or 3e)
FP Divide Single div.s FR F[fd] = F[fs] / F[ft] 11/10/--/3
FP Divide 
Double div.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} / 
                               {F[ft],F[ft+1]}
11/11/--/3
FP Multiply Single mul.s FR F[fd] = F[fs] * F[ft] 11/10/--/2
FP Multiply 
Double mul.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} * 
                               {F[ft],F[ft+1]}
11/11/--/2
FP Subtract Single sub.s FR F[fd]=F[fs] - F[ft] 11/10/--/1
FP Subtract 
Double sub.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} - 
                               {F[ft],F[ft+1]}
11/11/--/1
Load FP Single lwc1 I F[rt]=M[R[rs]+SignExtImm] (2) 31/--/--/--
Load FP 
Double ldc1 I
F[rt]=M[R[rs]+SignExtImm]; (2)
F[rt+1]=M[R[rs]+SignExtImm+4]
35/--/--/--
Move From Hi mfhi R R[rd] = Hi 0 /--/--/10
Move From Lo mflo R R[rd] = Lo 0 /--/--/12
Move From Control mfc0 R R[rd] = CR[rs] 10 /0/--/0
Multiply mult R {Hi,Lo} = R[rs] *  R[rt] 0/--/--/18
Multiply Unsigned multu R {Hi,Lo} = R[rs] *  R[rt] (6) 0/--/--/19
Shift Right Arith. sra R R[rd] = R[rt] >>> shamt 0/--/--/3
Store FP Single swc1 I M[R[rs]+SignExtImm] = F[rt] (2) 39/--/--/--
Store FP 
Double sdc1 I
M[R[rs]+SignExtImm] = F[rt]; (2) 
M[R[rs]+SignExtImm+4] = F[rt+1]
3d/--/--/--
FR opcode mt ft fs fd funct
31 26 25 21 20 16 15 11 10 6 5 0
FI opcode fmt ft immediate
31 26 25 21 20 16 15 0
NAME MNEMONIC OPERATION
Branch Less Than blt if(R rs]<R[rt]) PC = Label
Branch Greater Than bgt if(R[rs >R[rt]) PC = Label
Branch Less Than or Equal ble if(R[rs]<=R[rt]) PC = Label
Branch Greater Than or Equal bge if(R[rs]>=R[rt]) PC = Label
Load Immediate li R[rd] = immediate
Move move R[rd] = R[rs]
NAME NUMBER USE PRESERVED ACROSS A CALL?
$zero 0 The Constant Value 0 N.A.
$at 1 Assembler Te porary No
$v0-$v1 2-3 Values for Function Results and Expression Evaluation No
$a0-$a3 4-7 Arguments No
$t0-$t7 8-15 Temporaries No
$s0-$s7 16-23 Saved Temporaries Yes
$t8-$t9 24-25 Temporaries No
$k0-$k1 26-27 Reserved for OS Kernel No
$gp 28 Global Pointer Yes
$sp 29 Stack Pointer Yes
$fp 30 Frame Pointer Yes
$ra 31 Return Address Yes
1 2
M
IP
S 
 R
ef
er
en
ce
 D
at
a 
Ca
rd
 (“
Gr
ee
n
 C
ar
d”
)
1.
 P
ul
l a
lo
ng
 p
er
fo
ra
tio
n 
to
 s
ep
ar
at
e 
ca
rd
2.
 F
ol
d 
bo
tto
m
 s
id
e 
(c
ol
um
ns
 3
 a
nd
 4
) t
og
et
he
r
FLOATING-POINT INSTRUCTION FORMATS
PSEUDOINSTRUCTION SET
Copyright 2009 by Elsevier, Inc., All rights reserved. From Patterson and Hennessy, Computer Organization and Design, 4th ed.
(4) BranchAddr = { 14{immediate[15]}, immediate, 2’b0 }
’(6) Operands con idered unsigned numbers (vs. 2 s comp.)
A 0 
B 1 
C 2 
D 3 
imm_val	  	  
imm_val	  	  
imm_val	  	  
5 
2 (Add)
32
alu_op[2:0]
write_enable
itype
except
opcode[5:0]
funct[5:0]
MIPS decoder
A[31:0]
alu_op[2:0]
out
[31:0]
B[31:0]
ALU
rsDatarsNum
reset
rdNum
rtDatartNum
rdWriteEnable
rdData
Register File
reset
clk
wr_enable
Rdest
Rt
Rs
zero
negative
overflow
0
1
wr_enable
itype
itype
alu_op[2:0]
reset
enable
Q[31:0]
D[31:0]
PC Register
Sign 
Extender
out[31:0]
in[15:0]
data[31:0]
addr[29:0]
Instruction
Memory
4
inst[31:0]
PC[31:0]
ALU
1
nextPC[31:0]
0
1
itype
inst[25:21]
inst[20:16]
inst[15:11]
inst[20:16]
inst[5:0]
inst[15:0]
inst[31:26]
except
PC
[3
1:
2]
Rt
Rd
imm16
imm32
32
30
32
3
5
5
5
16
32
6
6
32
32
32
32
32
3
3
out[1:0]
0123
control_type
0 1 2 3
2 (Add)
ALU
3
Shift Left 2
out[31:0]
in[29:0]30 32
inst[25:0]
00 (for LSBs)
PC[31:28] (for MSBs)
branch
offset
branch
offset
32
control_type control_type
0 1
slt
01lui
16
16'b0
data_out[31:0]
addr[31:0]
Data
Memory
31'b0
zero
0
1
mem_read
da
ta
_o
ut
[3
1:
24
]
da
ta
_o
ut
[2
3:
16
]
da
ta
_o
ut
[1
5:
8]
da
ta
_o
ut
[7
:0
]
24'b00
1
byte_load
8
lui lui
slt slt
byte_load byte_load
32
26
word_we word_we
byte_we byte_we
word_we
byte_we
data_in[31:0]
word_we
byte_we
reset
32
32
mem_read mem_read
lui	  $19,	  0x1001	  
M I P S Reference Data
BASIC INSTRUCTION FORMATS
REGISTER NAME, NUMBER, USE, CALL CONVENTION
CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION (in Verilog)
/ FUNCT
(Hex)
Add add R R[rd] = R[rs] + R[rt] (1) 0 / 20hex
Add Immediate addi I R[rt] = R[rs] + SignExtImm (1,2) 8hex
Add Imm. Unsigned addiu I R[rt] = R[rs] + SignExtImm  (2) 9hex
Add Unsigned addu R R[rd] = R[rs] + R[rt] 0 / 21hex
And and R R[rd] = R[rs] & R[rt] 0 / 24hex
And Immediate andi I R[rt] = R[rs] & ZeroExtImm (3) chex
Branch O  Equal beq I if(R[rs]==R[rt])  PC=PC+4+BranchAddr (4)
4hex
Branch On Not Equalbne I if(R[rs]!=R[rt])  PC=PC+4+BranchAddr (4)
5hex
Jump j J PC=JumpAddr (5) 2hex
Jump And Link jal J R[31]=PC+8;PC=JumpAddr (5) 3hex
Jump Register jr R PC=R[rs] 0 / 08hex
Load Byte Unsigned lbu I R[rt]={24’b0,M[R[rs]            +SignExtImm](7:0)} (2)
24hex
Load Halfword 
Unsigned lhu I
R[rt]={16’b0,M[R[rs]
            +SignExtImm](15:0)} (2)
25hex
Load Linked ll I R[rt] = M[R[rs]+SignExtImm] (2,7) 30hex
Load Upper Imm. lui I R[rt] = {imm, 16’b0} fhex
Load Word lw I R[rt] = M[R[rs]+SignExtImm] (2) 23hex
Nor nor R R[rd] = ~ (R[rs] | R[rt]) 0 / 27hex
Or or R R[rd] = R[rs] | R[rt] 0 / 25hex
Or Immediate ori I R[rt] = R[rs] | ZeroExtImm (3) dhex
Set Less Than slt R R[rd] = (R[rs] < R[rt]) ? 1 : 0 0 / 2ahex
Set Less Than Imm. slti I R[rt] = (R[rs] < SignExtImm)? 1 : 0 (2) ahex
Set Less Than Imm. 
Unsigned sltiu I
R[rt] = (R[rs] < SignExtImm) 
                    ? 1 : 0  (2,6)
bhex
Set Less Than Unsig. sltu R R[rd] = (R[rs] < R[rt]) ? 1 : 0  (6) 0 / 2bhex
Shift Left Logical sll R R[rd] = R[rt] << shamt 0 / 00hex
Shift Right Logical srl R R[rd] = R[rt] >> shamt 0 / 02hex
Store Byte sb I M[R[rs]+SignExtImm](7:0) =                             R[rt](7:0) (2)
28hex
Store Conditional sc I M[R[rs]+SignExtImm] = R[rt];               R[rt] = (atomic) ? 1 : 0 (2,7)
38hex
Store Halfword sh I M[R[rs]+SignExtImm](15:0) =                                  R[rt](15:0) (2)
29hex
Store Word sw I M[R[rs]+SignExtImm] = R[rt] (2) 2bhex
Subtract sub R R[rd] = R[rs] - R[rt] (1) 0 / 22hex
Subtract Unsigned subu R R[rd] = R[rs] - R[rt] 0 / 23hex
(1) May cause overflow exception
(2) SignExtImm = { 16{immediate[15]}, immediate }
(3) ZeroExtImm = { 16{1b’0}, immediate }
(5) JumpAddr =    { PC+4[31:28], address, 2’b0 }
(7) Atomic test&set pair; R[rt] = 1 if pair atomic, 0 if not atomic
R opcode rs rt rd shamt funct
31 26 25 21 20 16 15 11 10 6 5 0
I opcode rs rt immediate
31 26 25 21 20 16 15 0
J opcode address
31 26 25 0
ARITHMETIC CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION 
/ FMT /FT
/ FUNCT
(Hex)
Branch On FP True bc1t FI if(FPcond)PC=PC+4+BranchAddr (4) 11/8/1/--
Branch On FP False bc1f FI if(!FPcond)PC=PC+4+BranchAddr(4) 11/8/0/--
Divide div R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] 0/--/--/1a
Divide Unsigned divu R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] (6) 0/--/--/1b
FP Add Single add.s FR F[fd ]= F[fs] + F[ft] 11/10/--/0
FP Add 
Double add.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} + 
                               {F[ft],F[ft+1]}
11/11/--/0
FP Compare Single c.x.s* FR FPcond = (F[fs] op F[ft]) ? 1 : 0 11/10/--/y
FP Compare 
Double c.x.d* FR
FPcond = ({F[fs],F[fs+1]} op
                   {F[ft],F[ft+1]}) ? 1 : 0
11/11/--/y
* (x is eq, lt, or le)  (op is ==, <, or <=) ( y is 32, 3c, or 3e)
FP Divide Single div.s FR F[fd] = F[fs] / F[ft] 11/10/--/3
FP Divide 
Double div.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} / 
                               {F[ft],F[ft+1]}
11/11/--/3
FP Multiply Single mul.s FR F[fd] = F[fs] * F[ft] 11/10/--/2
FP Multiply 
Double mul.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} * 
                               {F[ft],F[ft+1]}
11/11/--/2
FP Subtract Single sub.s FR F[fd]=F[fs] - F[ft] 11/10/--/1
FP Subtract 
Double sub.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} - 
                               {F[ft],F[ft+1]}
11/11/--/1
Load FP Single lwc1 I F[rt]=M[R[rs]+SignExtImm] (2) 31/--/--/--
Load FP 
Double ldc1 I
F[rt]=M[R[rs]+SignExtImm]; (2)
F[rt+1]=M[R[rs]+SignExtImm+4]
35/--/--/--
Move From Hi mfhi R R[rd] = Hi 0 /--/--/10
Move From Lo mflo R R[rd] = Lo 0 /--/--/12
Move From Control mfc0 R R[rd] = CR[rs] 10 /0/--/0
Multiply mult R {Hi,Lo} = R[rs] *  R[rt] 0/--/--/18
Multiply Unsigned multu R {Hi,Lo} = R[rs] *  R[rt] (6) 0/--/--/19
Shift Right Arith. sra R R[rd] = R[rt] >>> shamt 0/--/--/3
Store FP Single swc1 I M[R[rs]+SignExtImm] = F[rt] (2) 39/--/--/--
Store FP 
Double sdc1 I
M[R[rs]+SignExtImm] = F[rt]; (2) 
M[R[rs]+SignExtImm+4] = F[rt+1]
3d/--/--/--
FR opcode fmt ft fs fd funct
31 26 25 21 20 16 15 11 10 6 5 0
FI opcode fmt ft immediate
31 26 25 21 20 16 15 0
NAME MNEMONIC OPERATION
Branch Less Than blt if(R[rs]<R[rt]) PC = Label
Branch Greater Than bgt if(R[rs]>R[rt]) PC = Label
Branch Less Than or Equal ble if(R[rs]<=R[rt]) PC = Label
Branch Greater Than or Equal bge if(R[rs]>=R[rt]) PC = Label
Load Immediate li R[rd] = immediate
Move move R[rd] = R[rs]
NAME NUMBER USE PRESERVED ACROSS A CALL?
$zero 0 The Constant Value 0 N.A.
$at 1 Assembler Temporary No
$v0-$v1 2-3 Values for Function Results and Expression Evaluation No
$a0-$a3 4-7 Arguments No
$t0-$t7 8-15 Temporaries No
$s0-$s7 16-23 Saved Temporaries Yes
$t8-$t9 24-25 Temporaries No
$k0-$k1 26-27 Reserved for OS Kernel No
$gp 28 Global Pointer Yes
$sp 29 Stack Pointer Yes
$fp 30 Frame Pointer Yes
$ra 31 Return Address Yes
1 2
M
IP
S 
 R
ef
er
en
ce
 D
at
a 
C
ar
d 
(“G
re
en
 C
ar
d”
)
1.
 P
ul
l a
lo
ng
 p
er
fo
ra
tio
n 
to
 s
ep
ar
at
e 
ca
rd
2.
 F
ol
d 
bo
tto
m
 s
id
e 
(c
ol
um
ns
 3
 a
nd
 4
) 
to
ge
th
er
FLOATING-POINT INSTRUCTION FORMATS
PSEUDOINSTRUCTION SET
Copyright 2009 by Elsevier, Inc., All rights reserved. From Patterson and Hennessy, Computer Organization and Design, 4th ed.
(4) BranchAddr = { 14{immediate[15]}, immediate, 2’b0 }
’(6) Operands considered unsigned numbers (vs. 2 s comp.)
M I P S Reference Data
BASIC INSTRUCTION FORMATS
REGISTER NAME, NUMBER, USE, CALL CONVENTION
CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION (in Verilog)
/ FUNCT
(H x)
Add add R [rd] = R[rs] + R[rt] (1) 0 / 20hex
Add Immediate addi [rt]  R rs] + SignExtImm (1,2) 8hex
Add Imm. Unsigned addiu I [rt R[rs] + SignExtImm  (2) 9hex
Add Unsigned addu [r ]  [rs] + R[rt] 0 / 21hex
And and R [rd] = R[rs] & R[rt] 0 / 24hex
And Immediate andi I [rt R[rs] & Ze oExtImm (3) chex
Branch On Equal beq I if(R[rs]==R[rt])  PC=PC+4+BranchAddr (4)
4hex
Branch On Not Equalbne I if(R[rs]!=R[rt])  PC=PC+4+BranchAddr (4)
5hex
Jump j J PC=JumpAddr (5) 2hex
Jump And Link jal J R[31]=PC+8;PC=JumpAddr (5) 3hex
Jump Register jr R PC=R[rs] 0 / 08hex
Load Byte Unsigned lbu I R[rt]={24’b0,M[ [rs            i tI ](7:0)} (2)
24hex
Load Halfword 
Unsigned lhu I
R[rt]={16’b0,M[R[rs]
            i tI ]( : )} (2)
25hex
Load Linked ll I R[rt] = M[R[rs]+SignExtImm] (2,7) 30hex
Load Upper Imm. lui I R[rt] = {imm, 16’b0} fhex
Load Word lw I R[rt] = M[R[rs]+SignExtImm] (2) 23hex
Nor nor R R[rd] = ~ (R[rs] | R[rt]) 0 / 27hex
Or or R R[rd] = R[rs] | R[rt] 0 / 25hex
Or Immediate ori I R[rt] = R[rs] | ZeroExtImm (3) dhex
Set Less Than slt R R[rd] = (R[rs] < R[rt]) ? 1 : 0 0 / 2ahex
Set Less Than Imm. slti I R[rt] = (R[rs] < SignExtImm)? 1 : 0 (2) ahex
Set Less Than Imm. 
Unsigned sltiu I
R[rt] = (R[rs] < SignExtImm) 
                    ? 1 : 0  (2,6)
bhex
Set Less Than Unsig. sltu R R[rd] = (R[rs] < R[rt]) ? 1 : 0  (6) 0 / 2bhex
Shift Left Logical sll R R[rd] = R[rt] << shamt 0 / 00hex
Shift Right L gical srl R R[rd] = R[rt] >> shamt 0 / 02hex
Store Byte sb I M[R[rs]+SignExtImm](7:0) =                             R[rt](7:0) (2)
28hex
Store Conditional sc I M[R[rs]+SignExtImm] = R[rt];               R[rt] = (atomic) ? 1 : 0 (2,7)
38hex
Store Halfword sh I M[R[rs]+SignExtImm](15:0) =                                  R[rt](15:0) (2)
29hex
Store Word sw I M[R[rs]+SignExtImm] = R[rt] (2) 2bhex
Subtract sub R R[rd] = R[rs] - R[rt] (1) 0 / 22hex
Subtract Unsigned subu R R[rd] = R[rs] - R[rt] 0 / 23hex
(1) May cause overflow exception
(2) SignExtImm = { 16{immediate[15]}, immediate }
(3) ZeroExtImm = { 16{1b’0}, immediate }
(5) JumpAddr =    { PC+4[31:28], address, 2’b0 }
(7) Atomic test&set pair; R[rt] = 1 if pair atomic, 0 if not atomic
R opcode rs rt rd shamt funct
31 26 25 21 20 16 15 11 10 6 5 0
I opcode rs rt immediate
31 26 25 21 20 16 15 0
J opcode address
31 26 25 0
ARITHMETIC CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION 
/ FMT /FT
/ FUNCT
(Hex)
Branch On FP True bc1t FI if(FPcond)PC=PC+4+BranchAddr (4) 11/8/1/--
Branch On FP False bc1f FI if(!FPcond)PC=PC+4+BranchAddr(4) 11/8/0/--
Divide div R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] 0/--/--/1a
Divide Unsigned divu R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] (6) 0/--/--/1b
FP Add Single add.s FR F[fd ]= F[fs] + F[ft] 11/10/--/0
FP Add 
Double add.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} + 
                               {F[ft],F[ft+1]}
11/1 /--/0
FP Compare Single c.x.s* FR FPcond = (F[fs] op F[ft]) ? 1 : 0 11/10/--/y
FP Compare 
Double c.x.d* FR
FPcond = ({F[fs],F[fs+1]} op
                   {F[ft],F[ft+1]}) ? 1 : 0
11/11/--/y
* (x is eq, lt, or le)  (op is ==, <, or <=) ( y is 32, 3c, or 3e)
FP Divide Single div.s FR F[fd] = F[fs] / F[ft] 11/10/--/3
FP Divide 
Double div.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} / 
                               {F[ft],F[ft+1]}
11/11/--/3
FP Multiply Single mul.s FR F[fd] = F[fs] * F[ft] 11/10/--/2
FP Multiply 
Double mul.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} * 
                               {F[ft],F[ft+1]}
11/11/--/2
FP Subtract Single sub.s FR F[fd]=F[fs] - F[ft] 11/10/--/1
FP Subtract 
Double sub.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} - 
                               {F[ft],F[ft+1]}
11/11/--/1
Load FP Single lwc1 I F[rt]=M[R[rs]+SignExtImm] (2) 31/--/--/--
Load FP 
Double ldc1 I
F[rt]=M[R[rs]+SignExtImm]; (2)
F[rt+1]=M[R[rs]+SignExtImm+4]
35/--/--/--
Move From Hi mfhi R R[rd] = Hi 0 /--/--/10
Move From Lo mflo R R[rd] = Lo 0 /--/--/12
Move From Control mfc0 R R[rd] = CR[rs] 10 /0/--/0
Multiply mult R {Hi,Lo} = R[rs] *  R[rt] 0/--/--/18
Multiply Unsigned multu R {Hi,Lo} = R[rs] *  R[rt] (6) 0/--/--/19
Shift Right Arith. sra R R[rd] = R[rt] >>> shamt 0/--/--/3
Store FP Single swc1 I M[R[rs]+SignExtImm] = F[rt] (2) 39/--/--/--
Store FP 
Double sdc1 I
M[R[rs]+SignExtImm] = F[rt]; (2) 
M[R[rs]+SignExtImm+4] = F[rt+1]
3d/--/--/--
FR opcode fmt ft fs fd funct
31 26 25 21 20 16 15 11 10 6 5 0
FI opcode fmt ft immediate
31 26 25 21 20 16 15 0
NAME MNEMONIC OPERATION
Branch Less Than blt if(R[rs]<R[rt]) PC = Label
Branch Greater Than bgt if(R[rs]>R[rt]) PC = Label
B anch Less Than or Equal ble if(R[rs]<=R[rt]) PC = Label
Branch Greater Than or Equal bge if(R[rs]>=R[rt]) PC = Label
Load Immediate li R[rd] = immediate
Move move R[rd] = R[rs]
NAME NUMBER USE PRESERVED ACROSS A CALL?
$zero 0 The Constant Value 0 N.A.
$at 1 Assembler Temporary No
$v0-$v1 2-3 Values for Function Results and Expression Evaluation No
$a0-$a3 4-7 Arguments No
$t0-$t7 8-15 Temporaries No
$s0-$s7 16-23 Saved Temporaries Yes
$t8-$t9 24-25 Temporaries No
$k0-$k1 26-27 Reserved for OS Kernel No
$gp 28 Global Pointer Yes
$sp 29 Stack Pointer Yes
$fp 30 Frame Pointer Yes
$ra 31 Return Address Yes
1 2
M
IP
S 
 R
ef
er
en
ce
 D
at
a 
C
ar
d 
(“G
re
en
 C
ar
d”
)
1.
 P
ul
l a
lo
ng
 p
er
fo
ra
tio
n 
to
 s
ep
ar
at
e 
ca
rd
2.
 F
ol
d 
bo
tto
m
 s
id
e 
(c
ol
um
ns
 3
 a
nd
 4
) 
to
ge
th
er
FLOATING-POINT INSTRUCTION FORMATS
PSEUDOINSTRUCTION SET
Copyright 2009 by Elsevier, Inc., All rights reserved. From Patterson and Hennessy, Computer Organization and Design, 4th ed.
(4) BranchAddr = { 14{immediate[15]}, immediate, 2’b0 }
’(6) Operands considered unsigned numbers (vs. 2 s comp.)
M I P S Refe ence Data
BASIC INSTRUCTION FORMATS
REGISTER NAME, NUMBER, USE, CALL CONVENTION
CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION (in Verilog)
/ FUNCT
(Hex)
Add add R R[rd] = R[rs] + R[rt] (1) 0 / 20hex
Add Immediate addi I R[rt] = R[rs] + SignExtImm (1,2) 8hex
Add Imm. Unsigned addiu I R[rt] = R[rs] + SignExtImm  (2) 9hex
Add Unsigned addu R R[rd] = [rs] + [rt] 0 / 21hex
And and R R[rd] = s] & [rt] 0 / 24hex
And Immediate andi I R[rt] = [rs] & ZeroExtImm (3) chex
Branch On Equal beq I if(R[rs]==R[rt])  PC=PC+4+BranchAddr (4)
4hex
Branch On Not Equalbne I if(R[rs]!=R[rt])  PC=PC+4+BranchAddr (4)
5hex
Jump j J PC=JumpAddr (5) 2hex
Jump And Link j J R[31]=PC+8;PC=JumpAddr (5) 3hex
Jump Register jr R PC=R[rs] 0 / 08hex
Load Byte Unsigned lbu I R[rt]={24’b0,M[R[rs]            +SignExtImm](7:0)} (2)
24hex
Load Halfword 
Unsigned lhu I
R[rt]={16’b0,M[R[rs]
            +SignExtImm](15:0)} (2)
25hex
Load Linked ll I R[rt] = M[R[rs]+SignExtImm] (2,7) 30hex
Load Upper Imm. lui I R[rt] = {imm, 16’b0} fhex
Load Word lw I R[rt] = M[R[rs]+SignExtImm] (2) 23hex
Nor nor R R[rd] = ~ (R[rs] | R[rt]) 0 / 27hex
Or or R R[rd] = [rs] | R[rt] 0 / 25hex
Or Immediate ori I R[rt] = R[rs] | ZeroExtImm (3) dhex
Set Less Than slt R R[rd] = (R[rs] < [rt]) ? 1 : 0 0 / 2ahex
Set Less Than Imm. slti I R[rt] = (R[rs] < SignExtImm)? 1 : 0 (2) ahex
Set Less Than Imm. 
Unsigned sltiu I
R[rt] = (R[rs] < SignExtImm) 
                    ? 1 : 0  (2,6)
bhex
Set Less Than Unsig. sltu R R[rd] = (R[rs] < [rt]) ? 1 : 0  (6 0 / 2bhex
Shift Left ogical sll R R[rd] = t] << shamt 0 / 0 hex
Shift Right Logical srl R R[rd] = R[rt] >> shamt 0 / 02hex
Store Byte sb I M[R[rs]+SignExtImm (7:0) =                             R[rt](7:0) (2)
28hex
Store Conditional sc I M[R[rs]+SignExtImm] = R[rt];               R[rt]  (atomic) ? 1 : 0 (2,7)
38hex
Store Halfword sh I M[R[rs]+SignExtImm](15:0) =                                  R[rt](15:0) (2)
29hex
Store Word sw I M[R[rs]+SignExtImm] = R[rt] (2) 2bhex
Subtract sub R R[rd] = R[rs] - R[rt] ( ) 0 / 22hex
Subtract Unsigned subu R R[rd] = R[rs] - R[rt] 0 / 23hex
(1) May cause overflow exception
(2) SignExtImm = { 16{immediate[15]}, immediate }
(3) ZeroExtImm = { 16{1b’0}, immediate }
(5) JumpAddr =    { PC+4[31:28], address, 2’b0 }
(7) Atomic test&set pair; R[rt] = 1 if pair atomic, 0 if not atomic
R opcode rs rt rd shamt funct
31 26 25 21 20 16 15 11 10 6 5 0
I opcode rs rt immediate
31 26 25 21 20 16 15 0
J opcode address
31 26 25 0
ARITHMETIC CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION 
/ FMT /FT
/ FUNCT
(Hex)
Branch On FP True bc1t FI if(FPcond)PC=PC+4+BranchAddr (4) 11/8/1/--
Branch On FP False bc1f FI if(!FPcond)PC=PC+4+BranchAddr(4) 11/8/0/--
Divide div R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] 0/--/--/1a
Divide Unsign d divu R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] (6) 0/--/--/1b
FP Add Single add.s FR F[fd ]= F[fs] + F[ft] 11/10/--/0
FP Add 
Double add.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} + 
                               {F[ft],F[ft+1]}
11/11/--/0
FP Compare Single c.x.s* FR FPcond = (F[fs] op F[ft]) ? 1 : 0 11/10/--/y
FP Compare 
Double c.x.d* FR
FPcond = ({F[fs],F[fs+1]} op
                   {F[ft],F[ft+1]}) ? 1 : 0
11/11/--/y
* (x is eq, lt, or le)  (op is ==, <, or <=) ( y is 32, 3c, or 3e)
FP Divide Single div.s FR F[fd] = F[fs] / F[ft] 11/10/--/3
FP Divide 
Double div.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} / 
                               {F[ft],F[ft+1]}
11/11/--/3
FP Multiply Single mul.s FR F[fd] = F[fs] * F[ft] 11/10/--/2
FP Multiply 
Double mul.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} * 
                               { [ft],F[ft+1]}
11/11/--/2
FP Subtract Single sub.s FR F[fd]=F[fs] - F[ft] 11/10/--/1
FP Subtract 
Double sub.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} - 
                               {F[ft],F[ft+1]}
11/11/--/1
Load FP Single lwc1 I F[rt]=M[R[rs]+SignExtImm] (2) 31/--/--/--
Load FP 
Double ldc1 I
F[rt]=M[R[rs]+SignExtImm]; (2)
F[rt+1]=M[R[rs]+SignExtImm+4]
35/--/--/--
Move From Hi mfhi R R[rd] = Hi 0 /--/--/10
Move From Lo mflo R R[rd] = Lo 0 /--/--/12
Move From C ntrol fc0 R R[rd] = C [rs] 10 /0/--/0
Multiply mult R {Hi,Lo} = R[rs] *  R[rt] 0/--/--/18
Multiply Unsigned multu R {Hi,Lo} = R[rs] *  R[rt] (6) 0/--/--/19
Shift Right Arith. sra R R[rd] = R[rt] >>> shamt 0/--/--/3
Store FP Single swc1 I M[R[rs]+SignExtImm] = F[rt] (2) 39/--/--/--
Stor  FP 
Double sdc1 I
M[R[rs]+SignExtImm] = F[rt]; (2) 
M[R[rs]+SignExtImm+4] = F[rt+1]
3d/--/--/--
FR opcod fmt ft fs fd funct
31 26 25 21 20 16 15 11 10 6 5 0
FI opcode fmt ft immediate
31 26 25 21 20 16 15 0
NAME MNEMONIC OPERATION
Branch Less Than blt if(R[rs]<R[rt]) PC = Label
Branch Greater Than bgt if(R[rs]>R[rt]) PC = Label
Branch Less Than or Equal ble if(R[rs]<=R[rt]) PC = Label
Branch Greater Than or Equal bge if(R[rs]>=R[rt]) PC = Label
Load Immediate li R[rd] = immediate
Move move R[rd] = R[rs]
NAME NUMBER USE PRESERVED ACROSS A CALL?
$zero 0 The Constant Value 0 N.A.
$at 1 Assembler Temporary No
$v0-$v1 2-3 Values for Function Results and Expression Evaluation No
$a0-$a3 4-7 Arguments No
$t0-$t7 8-15 Temporaries No
$s0-$s7 16-23 Saved Temporaries Yes
$t8-$t9 24-25 Temporaries No
$k0-$k1 26-27 Reserved for OS Kernel No
$gp 28 Global Pointer Yes
$sp 29 Stack Pointer Yes
$fp 30 Frame Pointer Yes
$ra 31 Return Address Yes
1 2
M
IP
S 
 R
ef
er
en
ce
 D
at
a 
Ca
rd
 (“
Gr
ee
n
 C
ar
d”
)
1.
 P
ul
l a
lo
ng
 p
er
fo
ra
tio
n 
to
 s
ep
ar
at
e 
ca
rd
2.
 F
ol
d 
bo
tto
m
 s
id
e 
(c
ol
um
ns
 3
 a
nd
 4
) t
og
et
he
r
FLOATING-POINT INSTRUCTION FORMATS
PSEUDOINSTRUCTION SET
Copyright 2009 by Elsevier, Inc., All rights reserved. From Patterson and Hennessy, Computer Organization and Design, 4th ed.
(4) BranchAddr = { 14{immediate[15]}, immediate, 2’b0 }
’(6) Operands considered unsigned numbers (vs. 2 s comp.)
A 0 
B 1 
C 2 
D 3 
imm_val	  
imm_val	  	  
imm_val	  	  
6 
2 (Add)
32
alu_op[2:0]
write_enable
itype
except
opcode[5:0]
funct[5:0]
MIPS decoder
A[31:0]
alu_op[2:0]
out
[31:0]
B[31:0]
ALU
rsDatarsNum
reset
rdNum
rtDatartNum
rdWriteEnable
rdData
Register File
reset
clk
wr_enable
Rdest
Rt
Rs
zero
negative
overflow
0
1
wr_enable
itype
itype
alu_op[2:0]
reset
enable
Q[31:0]
D[31:0]
PC Register
Sign 
Extender
out[31:0]
in[15:0]
data[31:0]
addr[29:0]
Instruction
Memory
4
inst[31:0]
PC[31:0]
ALU
1
nextPC[31:0]
0
1
itype
inst[25:21]
inst[20:16]
inst[15:11]
inst[20:16]
inst[5:0]
inst[15:0]
inst[31:26]
except
PC
[3
1:
2]
Rt
Rd
imm16
imm32
32
30
32
3
5
5
5
16
32
6
6
32
32
32
32
32
3
3
out[1:0]
0123
control_type
0 1 2 3
2 (Add)
ALU
3
Shift Left 2
out[31:0]
in[29:0]30 32
inst[25:0]
00 (for LSBs)
PC[31:28] (for MSBs)
branch
offset
branch
offset
32
control_type control_type
0 1
slt
01lui
16
16'b0
data_out[31:0]
addr[31:0]
Data
Memory
31'b0
zero
0
1
mem_read
da
ta
_o
ut
[3
1:
24
]
da
ta
_o
ut
[2
3:
16
]
da
ta
_o
ut
[1
5:
8]
da
ta
_o
ut
[7
:0
]
24'b00
1
byte_load
8
lui lui
slt slt
byte_load byte_load
32
26
word_we word_we
byte_we byte_we
word_we
byte_we
data_in[31:0]
word_we
byte_we
reset
32
32
mem_read mem_read
add	  	  $4,	  $15,	  $20	  
M I P S Reference Data
BASIC INSTRUCTION FORMATS
REGISTER NAME, NUMBER, USE, CALL CONVENTION
CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION (in Verilog)
/ FUNCT
(Hex)
Add add R R[rd] = R[rs] + R[rt] (1) 0 / 20hex
Add Immediate addi I R[rt] = R[rs] + SignExtImm (1,2) 8hex
Add Imm. Unsigned addiu I R[rt] = R[rs] + SignExtImm  (2) 9hex
Add Unsigned addu R R[rd] = R[rs] + R[rt] 0 / 21hex
And and R R[rd] = R[rs] & R[rt] 0 / 24hex
And Immediate andi I R[rt] = R[rs] & ZeroExtImm (3) chex
Branch On Equal beq I if(R[rs]==R[rt])  PC=PC+4+BranchAddr (4)
4hex
Branch On Not Equalbne I if(R[rs]!=R[rt])  PC=PC+4+BranchAddr (4)
5hex
Jump j J PC=JumpAddr (5) 2hex
Jump And Link jal J R[31]=PC+8;PC=JumpAddr (5) 3hex
Jump Register jr R PC=R[rs] 0 / 08hex
Load Byte Unsigned lbu I R[rt]={24’b0,M[R[rs]            +SignExtImm](7:0)} (2)
24hex
Load Halfword 
Unsigned lhu I
R[rt]={16’b0,M[R[rs]
            +SignExtImm](15:0)} (2)
25hex
Load Linked ll I R[rt] = M[R[rs]+SignExtImm] (2,7) 30hex
Load Upper Imm. lui I R[rt] = {imm, 16’b0} fhex
Load Word lw I R[rt] = M[R[rs]+SignExtImm] (2) 23hex
Nor nor R R[rd] = ~ (R[rs] | R[rt]) 0 / 27hex
Or or R R[rd] = R[rs] | R[rt] 0 / 25hex
Or Immediate ori I R[rt] = R[rs] | ZeroExtImm (3) dhex
Set Less Than slt R R[rd] = (R[rs] < R[rt]) ? 1 : 0 0 / 2ahex
Set Less Than Imm. slti I R[rt] = (R[rs] < SignExtImm)? 1 : 0 (2) ahex
Set Less Than Imm. 
Unsigned sltiu I
R[rt] = (R[rs] < SignExtImm) 
                    ? 1 : 0  (2,6)
bhex
Set Less Than Unsig. sltu R R[rd] = (R[rs] < R[rt]) ? 1 : 0  (6) 0 / 2bhex
Shift Left Logical sll R R[rd] = R[rt] << shamt 0 / 00hex
Shift Right Logical srl R R[rd] = R[rt] >> shamt 0 / 02hex
Store Byte sb I M[R[rs]+SignExtImm](7:0) =                             R[rt](7:0) (2)
28hex
Store Conditional sc I M[R[rs]+SignExtImm] = R[rt];               R[rt] = (atomic) ? 1 : 0 (2,7)
38hex
Store Halfword sh I M[R[rs]+SignExtImm](15:0) =                                  R[rt](15:0) (2)
29hex
Store Word sw I M[R[rs]+SignExtImm] = R[rt] (2) 2bhex
Subtract sub R R[rd] = R[rs] - R[rt] (1) 0 / 22hex
Subtract Unsigned subu R R[rd] = R[rs] - R[rt] 0 / 23hex
(1) May cause overflow exception
(2) SignExtImm = { 16{immediate[15]}, immediate }
(3) ZeroExtImm = { 16{1b’0}, immediate }
(5) JumpAddr =    { PC+4[31:28], address, 2’b0 }
(7) Atomic test&set pair; R[rt] = 1 if pair atomic, 0 if not atomic
R opcode rs rt rd shamt funct
31 26 25 21 20 16 15 11 10 6 5 0
I opcode rs rt immediate
31 26 25 21 20 16 15 0
J opcode address
31 26 25 0
ARITHMETIC CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION 
/ FMT /FT
/ FUNCT
(Hex)
Branch On FP True bc1t FI if(FPcond)PC=PC+4+BranchAddr (4) 11/8/1/--
Branch On FP False bc1f FI if(!FPcond)PC=PC+4+BranchAddr(4) 11/8/0/--
Divide div R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] 0/--/--/1a
Divide Unsigned divu R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] (6) 0/--/--/1b
FP Add Single add.s FR F[fd ]= F[fs] + F[ft] 11/10/--/0
FP Add 
Double add.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} + 
                               {F[ft],F[ft+1]}
11/11/--/0
FP Compare Single c.x.s* FR FPcond = (F[fs] op F[ft]) ? 1 : 0 11/10/--/y
FP Compare 
Double c.x.d* FR
FPcond = ({F[fs],F[fs+1]} op
                   {F[ft],F[ft+1]}) ? 1 : 0
11/11/--/y
* (x is eq, lt, or le)  (op is ==, <, or <=) ( y is 32, 3c, or 3e)
FP Divide Single div.s FR F[fd] = F[fs] / F[ft] 11/10/--/3
FP Divide 
Double div.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} / 
                               {F[ft],F[ft+1]}
11/11/--/3
FP Multiply Single mul.s FR F[fd] = F[fs] * F[ft] 11/10/--/2
FP Multiply 
Double mul.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} * 
                               {F[ft],F[ft+1]}
11/11/--/2
FP Subtract Single sub.s FR F[fd]=F[fs] - F[ft] 11/10/--/1
FP Subtract 
Double sub.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} - 
                               {F[ft],F[ft+1]}
11/11/--/1
Load FP Single lwc1 I F[rt]=M[R[rs]+SignExtImm] (2) 31/--/--/--
Load FP 
Double ldc1 I
F[rt]=M[R[rs]+SignExtImm]; (2)
F[rt+1]=M[R[rs]+SignExtImm+4]
35/--/--/--
Move From Hi mfhi R R[rd] = Hi 0 /--/--/10
Move From Lo mflo R R[rd] = Lo 0 /--/--/12
Move From Control mfc0 R R[rd] = CR[rs] 10 /0/--/0
Multiply mult R {Hi,Lo} = R[rs] *  R[rt] 0/--/--/18
Multiply Unsigned multu R {Hi,Lo} = R[rs] *  R[rt] (6) 0/--/--/19
Shift Right Arith. sra R R[rd] = R[rt] >>> shamt 0/--/--/3
Store FP Single swc1 I M[R[rs]+SignExtImm] = F[rt] (2) 39/--/--/--
Store FP 
Double sdc1 I
M[R[rs]+SignExtImm] = F[rt]; (2) 
M[R[rs]+SignExtImm+4] = F[rt+1]
3d/--/--/--
FR opcode fmt ft fs fd funct
31 26 25 21 20 16 15 11 10 6 5 0
FI opcode fmt ft immediate
31 26 25 21 20 16 15 0
NAME MNEMONIC OPERATION
Branch Less Than blt if(R[rs]<R[rt]) PC = Label
Branch Greater Than bgt if(R[rs]>R[rt]) PC = Label
Branch Less Than or Equal ble if(R[rs]<=R[rt]) PC = Label
Branch Greater Than or Equal bge if(R[rs]>=R[rt]) PC = Label
Load Immediate li R[rd] = immediate
Move move R[rd] = R[rs]
NAME NUMBER USE PRESERVED ACROSS A CALL?
$zero 0 The Constant Value 0 N.A.
$at 1 Assembler Temporary No
$v0-$v1 2-3 Values for Function Results and Expression Evaluation No
$a0-$a3 4-7 Arguments No
$t0-$t7 8-15 Temporaries No
$s0-$s7 16-23 Saved Temporaries Yes
$t8-$t9 24-25 Temporaries No
$k0-$k1 26-27 Reserved for OS Kernel No
$gp 28 Global Pointer Yes
$sp 29 Stack Pointer Yes
$fp 30 Frame Pointer Yes
$ra 31 Return Address Yes
1 2
M
IP
S 
 R
ef
er
en
ce
 D
at
a 
C
ar
d 
(“G
re
en
 C
ar
d”
)
1.
 P
ul
l a
lo
ng
 p
er
fo
ra
tio
n 
to
 s
ep
ar
at
e 
ca
rd
2.
 F
ol
d 
bo
tto
m
 s
id
e 
(c
ol
um
ns
 3
 a
nd
 4
) 
to
ge
th
er
FLOATING-POINT INSTRUCTION FORMATS
PSEUDOINSTRUCTION SET
Copyright 2009 by Elsevier, Inc., All rights reserved. From Patterson and Hennessy, Computer Organization and Design, 4th ed.
(4) BranchAddr = { 14{immediate[15]}, immediate, 2’b0 }
’(6) Operands considered unsigned numbers (vs. 2 s comp.)
M I P S Refe ence Data
BASIC INSTRUCTION FORMATS
REGISTER NAME, NUMBER, USE, CALL CONVENTION
CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION (in Verilog)
/ FUNCT
(Hex)
Add add R R[rd] = R[rs] + R[rt] (1) 0 / 20hex
Add Immediate addi I R[rt] = R[rs] + SignExtImm (1,2) 8hex
Add Imm. Unsigned addiu I R[rt] = R[rs] + SignExtImm  (2) 9hex
Add Unsigned addu R R[rd] = [rs] + R[rt] 0 / 21hex
And and R R[rd] = s] & [rt] 0 / 24hex
And Immediate andi I R[rt] = R[rs] & ZeroExtImm (3) chex
Branch On Equal beq I if(R[rs]==R[rt])  PC=PC+4+BranchAddr (4)
4hex
Branch On Not Equalbne I if(R[rs]!=R[rt])  PC=PC+4+BranchAddr (4)
5hex
Jump j J PC=JumpAddr (5) 2hex
Jump And Link jal J R[31]=PC+8;PC=JumpAddr (5) 3hex
Jump Register jr R PC=R[rs] 0 / 08hex
Load Byte Unsigned lbu I R[rt]={24’b0,M[R[rs]            +SignExtImm](7:0)} (2)
24hex
Load Halfword 
Unsigned lhu I
R[rt]={16’b0,M[R[rs]
            +SignExtImm](15:0)} (2)
25hex
Load Linked ll I R[rt] = M[R[rs]+SignExtImm] (2,7) 30hex
Load Upper Imm. lui I R[rt] = {imm, 16’b0} fhex
Load Word lw I R[rt] = M[R[rs]+SignExtImm] (2) 23hex
Nor nor R R[rd] = ~ (R[rs] | R[rt]) 0 / 27hex
Or or R R[rd] = [rs] | R[rt] 0 / 25hex
Or Immediate ori I R[rt] = R[rs] | ZeroExtImm (3) dhex
Set Less Than slt R R[rd] = (R[rs] < [rt]) ? 1 : 0 0 / 2ahex
Set Less Than Imm. slti I R[rt] = (R[rs] < SignExtImm)? 1 : 0 (2) ahex
Set Less Than Imm. 
Unsigned sltiu I
R[rt] = (R[rs] < SignExtImm) 
                    ? 1 : 0  (2,6)
bhex
Set Less Than Unsig. sltu R R[rd] = (R[rs] < [rt]) ? 1 : 0  (6 0 / 2bhex
Shift Left ogical sll R R[rd] = t] << shamt 0 / 00hex
Shift Right Logical srl R R[rd] = R[rt] >> shamt 0 / 02hex
Store Byte sb I M[R[rs]+SignExtImm (7:0) =                             R[rt](7:0) (2)
28hex
Store Conditional sc I M[R[rs]+SignExtImm] = R[rt];               R[rt]  (atomic) ? 1 : 0 (2,7)
38hex
Store Halfword sh I M[R[rs]+SignExtImm](15:0) =                                  R[rt](15:0) (2)
29hex
Store Word sw I M[R[rs]+SignExtImm] = R[rt] (2) 2bhex
Subtract sub R R[rd] = R[rs] - R[rt] ( ) 0 / 22hex
Subtract Unsigned subu R R[rd] = R[rs] - R[rt] 0 / 23hex
(1) May cause overflow exception
(2) SignExtImm = { 16{immediate[15]}, immediate }
(3) ZeroExtImm = { 16{1b’0}, immediate }
(5) JumpAddr =    { PC+4[31:28], address, 2’b0 }
(7) Atomic test&set pair; R[rt] = 1 if pair atomic, 0 if not atomic
R opcode rs rt rd shamt funct
31 26 25 21 20 16 15 11 10 6 5 0
I opcode rs rt immediate
31 26 25 21 20 16 15 0
J opcode address
31 26 25 0
ARITHMETIC CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION 
/ FMT /FT
/ FUNCT
(Hex)
Branch On FP True bc1t FI if(FPcond)PC=PC+4+BranchAddr (4) 11/8/1/--
Branch On FP False bc1f FI if(!FPcond)PC=PC+4+BranchAddr(4) 11/8/0/--
Divide div R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] 0/--/--/1a
Divide Unsigned divu R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] (6) 0/--/--/1b
FP Add Single add.s FR F[fd ]= F[fs] + F[ft] 11/10/--/0
FP Add 
Double add.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} + 
                               {F[ft],F[ft+1]}
11/11/--/0
FP Compare Single c.x.s* FR FPcond = (F[fs] op F[ft]) ? 1 : 0 11/10/--/y
FP Compare 
Double c.x.d* FR
FPcond = ({F[fs],F[fs+1]} op
                   {F[ft],F[ft+1]}) ? 1 : 0
11/11/--/y
* (x is eq, lt, or le)  (op is ==, <, or <=) ( y is 32, 3c, or 3e)
FP Divide Single div.s FR F[fd] = F[fs] / F[ft] 11/10/--/3
FP Divide 
Double div.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} / 
                               {F[ft],F[ft+1]}
11/11/--/3
FP Multiply Single mul.s FR F[fd] = F[fs] * F[ft] 11/10/--/2
FP Multiply 
Double mul.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} * 
                               { [ft],F[ft+1]}
11/11/--/2
FP Subtract Single sub.s FR F[fd]=F[fs] - F[ft] 11/10/--/1
FP Subtract 
Double sub.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} - 
                               {F[ft],F[ft+1]}
11/11/--/1
Load FP Single lwc1 I F[rt]=M[R[rs]+SignExtImm] (2) 31/--/--/--
Load FP 
Double ldc1 I
F[rt]=M[R[rs]+SignExtImm]; (2)
F[rt+1]=M[R[rs]+SignExtImm+4]
35/--/--/--
Move From Hi mfhi R R[rd] = Hi 0 /--/--/10
Move From Lo mflo R R[rd] = Lo 0 /--/--/12
Move From C ntrol mfc0 R R[rd] = C [rs] 10 /0/--/0
Multiply mult R {Hi,Lo} = R[rs] *  R[rt] 0/--/--/18
Multiply Unsigned multu R {Hi,Lo} = R[rs] *  R[rt] (6) 0/--/--/19
Shift Right Arith. sra R R[rd] = R[rt] >>> shamt 0/--/--/3
Store FP Single swc1 I M[R[rs]+SignExtImm] = F[rt] (2) 39/--/--/--
Stor  FP 
Double sdc1 I
M[R[rs]+SignExtImm] = F[rt]; (2) 
M[R[rs]+SignExtImm+4] = F[rt+1]
3d/--/--/--
FR opcod fmt ft fs fd funct
31 26 25 21 20 16 15 11 10 6 5 0
FI opcode fmt ft immediate
31 26 25 21 20 16 15 0
NAME MNEMONIC OPERATION
Branch Less Than blt if(R[rs]<R[rt]) PC = Label
Branch Greater Than bgt if(R[rs]>R[rt]) PC = Label
Branch Less Than or Equal ble if(R[rs]<=R[rt]) PC = Label
Branch Greater Than or Equal bge if(R[rs]>=R[rt]) PC = Label
Load Immediate li R[rd] = immediate
Move move R[rd] = R[rs]
NAME NUMBER USE PRESERVED ACROSS A CALL?
$zero 0 The Constant Value 0 N.A.
$at 1 Assembler Temporary No
$v0-$v1 2-3 Values for Function Results and Expression Evaluation No
$a0-$a3 4-7 Arguments No
$t0-$t7 8-15 Temporaries No
$s0-$s7 16-23 Saved Temporaries Yes
$t8-$t9 24-25 Temporaries No
$k0-$k1 26-27 Reserved for OS Kernel No
$gp 28 Global Pointer Yes
$sp 29 Stack Pointer Yes
$fp 30 Frame Pointer Yes
$ra 31 Return Address Yes
1 2
M
IP
S 
 R
ef
er
en
ce
 D
at
a 
Ca
rd
 (“
Gr
ee
n
 C
ar
d”
)
1.
 P
ul
l a
lo
ng
 p
er
fo
ra
tio
n 
to
 s
ep
ar
at
e 
ca
rd
2.
 F
ol
d 
bo
tto
m
 s
id
e 
(c
ol
um
ns
 3
 a
nd
 4
) t
og
et
he
r
FLOATING-POINT INSTRUCTION FORMATS
PSEUDOINSTRUCTION SET
Copyright 2009 by Elsevier, Inc., All rights reserved. From Patterson and Hennessy, Computer Organization and Design, 4th ed.
(4) BranchAddr = { 14{immediate[15]}, immediate, 2’b0 }
’(6) Operands considered unsigned numbers (vs. 2 s comp.)
M I P S Reference Data
BASIC INSTRUCTION FORMATS
REGISTER NAME, NUMBER, USE, CALL CONVENTION
CORE INSTRUCTION SET P E
NAME, MNEMONIC
FOR-
MAT OPERATION (in Verilog)
/ 
Add add R R[rd] = R[rs] + R[rt] 
Add Immediate addi I R[rt] = R[rs] + SignExtImm ( ,
Add Imm. Unsigned addiu I R[rt] = R[rs] + SignExtImm  (2) 9hex
Add Unsigned addu R R[rd] = R[rs] + R[rt] 0 / 21hex
And and R R[rd] = R[rs] & R[rt] 0 / 24hex
And Immediate andi I R[rt] = R[rs] & ZeroExtImm (3) chex
Branch On Equal beq I if(R[rs]==R[rt])  PC=PC+4+BranchAddr (4)
4hex
Branch On Not Equalbne I if(R[rs]!=R[rt])  PC=PC+4+BranchAddr (4)
5hex
Jump j J PC=JumpAddr (5) 2hex
Jump And Link jal J R[31]=PC+8;PC=JumpAddr (5) 3hex
Jump Register jr R PC=R[rs] 0 / 08hex
Load Byte Unsigned lbu I R[rt]={24’b0,M[R[rs]            +SignExtImm](7:0)} (2)
24hex
Load Halfword 
Unsigned lhu I
R[rt]={16’b0,M[R[rs]
            +SignExtImm](15:0)} (2)
25hex
Load Li ked ll I R[rt] = M[R[rs]+SignExtImm] (2,7) 30hex
Load Upper Imm. lui I R[rt] = {imm, 16’b0} fhex
Load Word lw I R[rt] = M[R[rs]+SignExtImm] (2) 23hex
Nor nor R R[rd] = ~ (R[rs] | R[rt]) 0 / 27hex
Or or R R[rd] = R[rs] | R[rt]  / 5hex
Or Immediate ori I R[rt] = R[rs] | ZeroExtImm (3) dhex
Set Less Than slt R R[rd] = (R[rs] < R[rt]) ? 1 : 0 0 / 2ahex
Set Less Than Imm. slti I R[rt] = (R[rs] < SignExtImm)? 1 : 0 (2) ahex
Set Less Than Imm. 
Unsigned sltiu I
R[rt] = (R[rs] < SignExtImm) 
                    ? 1 : 0  (2,6)
b
Set Less Than Unsig. sltu R R[rd] = (R[rs] < R[rt]) ? 1 : 0  (6) 0 / 2bhex
Shift Left Logical sll R R[rd] = R[rt] << shamt 0 / 00hex
Shift Right Logical srl R R[rd] = R[rt] >> shamt 0 / 02hex
Store Byte sb I M[R[rs]+SignExtImm](7:0) =                         R[rt](7:0) (2)
28hex
Store Conditional sc I M[R[rs]+SignExtImm] = R[rt];               R[rt] = (atomic) ? 1 : 0 (2,7
3
Store Halfword sh I M[R[rs]+SignExtImm](15:0) =                                  R[rt](15:0) (2)
29hex
Store Word sw I M[R[rs]+SignExtImm] = R[rt] (2) 2bhex
Subtract sub R R[rd] = R[rs] - R[rt] 1 0 / 22hex
Subtract Unsigned subu R R[rd] = R[rs] - R[rt] 0 / 23hex
(1) May cause overflow exception
(2) SignExtImm = { 16{imm diate[15]}, immediate }
(3) ZeroExtImm = { 16{1b’0}, immediate }
(5) JumpAddr =    { PC+4[31:28], address, 2’b0 }
(7) Atomic test&set pair; R[rt] = 1 if pair atomic, 0 if not atomic
R opcode rs rt rd shamt funct
31 26 25 21 20 16 15 11 10 6 5 0
I opcode rs rt immediate
31 26 25 21 20 16 15 0
J opcode address
31 26 25 0
ARITHMETIC CORE INSTRUCTION SET OPCODE
NA E, MNEMONIC
FOR-
MAT OPERATION 
/ FMT /FT
/ FUNCT
(Hex)
Branch n FP True bc1t FI if(FPcond)PC=PC+4+BranchAddr (4) 11/8/1/--
ranch On FP False bc1f FI if(!FPcond)PC=PC+4 BranchAddr(4) 11/8/0/--
ivide div R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] 0/--/- /1a
ivide Unsigned divu R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] (6) 0/--/- /1b
P dd Single ad .s FR F[fd ]= F[fs] + F[ft] 11/ 0 --/0
P dd 
ouble ad .d R
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} + 
                               {F[ft],F[ft+ ]}
11/ /--/0
FP Compare Single c.x.s* FR FPcond = (F[fs] op F[ft]) ? 1 : 0 11/10/--/y
FP Compare 
Double c.x.d* FR
FPcond = ({F[fs],F[fs+1]} op
                   {F[ft],F[ft+1]}) ? 1 : 0
11/11/--/y
* (x is eq, lt, or le)  (op is ==, <, or <=) ( y is 32, 3c, or 3e)
FP Divide Single div.s FR F[fd] = F[fs] / F[ft] 11/10/--/3
FP Divide 
Double div.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} / 
                   {F[ft],F[ft+1]}
11/11/--/3
FP Multiply Single mul.s FR F[fd] = F[fs] * F[ft] 11/10/--/2
FP Multiply 
Double mul.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} * 
                               {F[ft],F[ft+1]}
11/11/--/2
FP Subtract Single sub.s FR F[fd]=F[fs] - F[ft] 11/10/--/1
FP Subtract 
Double sub.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+ ]}  
                               {F[ft],F[ft+1]}
11/11/--/1
Load FP Single lwc1 I F[rt]=M[R[rs]+SignExtImm] (2) 31/--/--/--
oad FP 
D uble ldc1 I
F[rt]=M[R[rs]+SignExtImm]; (2)
F[rt+1]= [ [rs] i +4]
35/--/--/--
M ve From Hi mfhi R R[rd] = Hi 0 /--/--/10
ove Fro  Lo mflo R R[rd] = Lo 0 /--/--/12
ove Fro  Control mfc0 R R[rd] = CR[rs] 10 /0/--/0
ultiply mult R {Hi,Lo} = R[rs] *  R[rt] 0/--/--/18
Multiply Unsigned multu {Hi,Lo} = R[rs] *  R[rt] (6) 0/--/--/19
Shift Right Arith. sra R R[rd] = R[rt] >>> shamt 0/--/--/3
Store FP Single swc1 I M[R[rs]+SignExtImm] = F[rt] (2) 39/--/--/--
Store FP 
Double sdc1 I
M[R[rs]+SignExtImm] = F[rt]; (2) 
M[R[rs]+SignExtImm+4] = F[rt+1]
3d/--/- /--
FR opcode fmt ft fs fd funct
31 26 25 21 20 16 15 11 10 6 5 0
FI opcode fmt ft immediate
31 26 25 21 20 16 15 0
NAME MNEMONIC OPERATION
Branch Less Than blt if(R[rs]<R[rt]) PC = Label
Branch Greater Than bgt if(R[rs]>R[rt]) PC = Label
Branch Less Than or Equal ble if(R[rs]<=R[rt]) PC = Label
Branch Greater Than or Equal bge if(R[rs]>=R[rt]) PC = Label
Load Immediate li R[rd] = immediate
Move move R[rd] = R[rs]
NAME NUMBER USE P ESERVED ACROSS A CALL?
$zero 0 The Constant Value 0 N.A.
$at 1 Assembler Temporary No
$v0-$v1 2-3 Values for Function Results and Expression Evaluation No
$a0-$a3 4-7 Arguments No
$t0-$t7 8-15 Temporari s No
$s0-$s7 16-23 Saved Temporaries Yes
$t8-$t9 24-25 Temporaries No
$k0-$k1 26-27 Reserved for OS Kernel No
$gp 28 Global Pointer Yes
$sp 29 Stack P inter Yes
$fp 30 Fram  Pointer Yes
$ra 31 Return Address Yes
1 2
M
IP
S 
 R
ef
er
en
ce
 D
at
a 
C
ar
d 
(“G
re
en
 C
ar
d”
)
1.
 P
ul
l a
lo
ng
 p
er
fo
ra
tio
n 
to
 s
ep
ar
at
e 
ca
rd
2.
 F
ol
d 
bo
tto
m
 s
id
e 
(c
ol
um
ns
 3
 a
nd
 4
) t
og
et
he
r
FLOATING-POINT INSTRUCTION FORMATS
PSEUDOINSTRUCTION SET
Copyright 2009 by Elsevier, Inc., All rights reserved. From Patterson and Hennessy, Computer Organization and Design, 4th ed.
(4) BranchAddr = { 14{immediate[15]}, immediate, 2’b0 }
’(6) Operands considered unsigned numb rs (vs. 2 s comp.)
A 0 
B 1 
C 2 
D 3 
imm_val	  
imm_val	  	  
imm_val	  	  
7 
2 (Add)
32
alu_op[2:0]
write_enable
itype
except
opcode[5:0]
funct[5:0]
MIPS decoder
A[31:0]
alu_op[2:0]
out
[31:0]
B[31:0]
ALU
rsDatarsNum
reset
rdNum
rtDatartNum
rdWriteEnable
rdData
Register File
reset
clk
wr_enable
Rdest
Rt
Rs
zero
negative
overflow
0
1
wr_enable
itype
itype
alu_op[2:0]
reset
enable
Q[31:0]
D[31:0]
PC Register
Sign 
Extender
out[31:0]
in[15:0]
data[31:0]
addr[29:0]
Instruction
Memory
4
inst[31:0]
PC[31:0]
ALU
1
nextPC[31:0]
0
1
itype
inst[25:21]
inst[20:16]
inst[15:11]
inst[20:16]
inst[5:0]
inst[15:0]
inst[31:26]
except
PC
[3
1:
2]
Rt
Rd
imm16
imm32
32
30
32
3
5
5
5
16
32
6
6
32
32
32
32
32
3
3
out[1:0]
0123
control_type
0 1 2 3
2 (Add)
ALU
3
Shift Left 2
out[31:0]
in[29:0]30 32
inst[25:0]
00 (for LSBs)
PC[31:28] (for MSBs)
branch
offset
branch
offset
32
control_type control_type
0 1
slt
01lui
16
16'b0
data_out[31:0]
addr[31:0]
Data
Memory
31'b0
zero
0
1
mem_read
da
ta
_o
ut
[3
1:
24
]
da
ta
_o
ut
[2
3:
16
]
da
ta
_o
ut
[1
5:
8]
da
ta
_o
ut
[7
:0
]
24'b00
1
byte_load
8
lui lui
slt slt
byte_load byte_load
32
26
word_we word_we
byte_we byte_we
word_we
byte_we
data_in[31:0]
word_we
byte_we
reset
32
32
mem_read mem_read
sw 	  	  $4,	  8($4)	  
M I P S Reference Data
BASIC INSTRUCTION FORMATS
REGISTER NAME, NUMBER, USE, CALL CONVENTION
CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION (in Verilog)
/ FUNCT
(Hex)
Add add R R[rd] = R[rs] + R[rt] (1) 0 / 20hex
Add Immediate addi I R[rt] = R[rs] + SignExtImm (1,2) 8hex
Add Imm. Unsigned addiu I R[rt] = R[rs] + SignExtImm  (2) 9hex
Add Unsigned addu R R[rd] = R[rs] + R[rt] 0 / 21hex
And and R R[rd] = R[rs] & R[rt] 0 / 24hex
And Immediate andi I R[rt] = R[rs] & ZeroExtImm (3) chex
Branch On Equal beq I if(R[rs]==R[rt])  PC=PC+4+BranchAddr (4)
4hex
Branch On Not Equalbne I if(R[rs]!=R[rt])  PC=PC+4+BranchAddr (4)
5hex
Jump j J PC=JumpAddr (5) 2hex
Jump And Link jal J R[31]=PC+8;PC=JumpAddr (5) 3hex
Jump Register jr R PC=R[rs] 0 / 08hex
Load Byte Unsigned lbu I R[rt]={24’b0,M[R[rs]            +SignExtImm](7:0)} (2)
24hex
Load Halfword 
Unsigned lhu I
R[rt]={16’b0,M[R[rs]
            +SignExtImm](15:0)} (2)
25hex
Load Linked ll I R[rt] = M[R[rs]+SignExtImm] (2,7) 30hex
Load Upper Imm. lui I R[rt] = {imm, 16’b0} fhex
Load Word lw I R[rt] = M[R[rs]+SignExtImm] (2) 23hex
Nor nor R R[rd] = ~ (R[rs] | R[rt]) 0 / 27hex
Or or R R[rd] = R[rs] | R[rt] 0 / 25hex
Or Immediate ori I R[rt] = R[rs] | ZeroExtImm (3) dhex
Set Less Than slt R R[rd] = (R[rs] < R[rt]) ? 1 : 0 0 / 2ahex
Set Less Than Imm. slti I R[rt] = (R[rs] < SignExtImm)? 1 : 0 (2) ahex
Set Less Than Imm. 
Unsigned sltiu I
R[rt] = (R[rs] < SignExtImm) 
                    ? 1 : 0  (2,6)
bhex
Set Less Than Unsig. sltu R R[rd] = (R[rs] < R[rt]) ? 1 : 0  (6) 0 / 2bhex
Shift Left Logical sll R R[rd] = R[rt] << shamt 0 / 00hex
Shift Right Logical srl R R[rd] = R[rt] >> shamt 0 / 02hex
Store Byte sb I M[R[rs]+SignExtImm](7:0) =                             R[rt](7:0) (2)
28hex
Store Conditional sc I M[R[rs]+SignExtImm] = R[rt];               R[rt] = (atomic) ? 1 : 0 (2,7)
38hex
Store Halfword sh I M[R[rs]+SignExtImm](15:0) =                                  R[rt](15:0) (2)
29hex
Store Word sw I M[R[rs]+SignExtImm] = R[rt] (2) 2bhex
Subtract sub R R[rd] = R[rs] - R[rt] (1) 0 / 22hex
Subtract Unsigned subu R R[rd] = R[rs] - R[rt] 0 / 23hex
(1) May cause overflow exception
(2) SignExtImm = { 16{immediate[15]}, immediate }
(3) ZeroExtImm = { 16{1b’0}, immediate }
(5) JumpAddr =    { PC+4[31:28], address, 2’b0 }
(7) Atomic test&set pair; R[rt] = 1 if pair atomic, 0 if not atomic
R opcode rs rt rd shamt funct
31 26 25 21 20 16 15 11 10 6 5 0
I opcode rs rt immediate
31 26 25 21 20 16 15 0
J opcode address
31 26 25 0
ARITHMETIC CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION 
/ FMT /FT
/ FUNCT
(Hex)
Branch On FP True bc1t FI if(FPcond)PC=PC+4+BranchAddr (4) 11/8/1/--
Branch On FP False bc1f FI if(!FPcond)PC=PC+4+BranchAddr(4) 11/8/0/--
Divide div R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] 0/--/--/1a
Divide Unsigned divu R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] (6) 0/--/--/1b
FP Add Single add.s FR F[fd ]= F[fs] + F[ft] 11/10/--/0
FP Add 
Double add.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} + 
                               {F[ft],F[ft+1]}
11/11/--/0
FP Compare Single c.x.s* FR FPcond = (F[fs] op F[ft]) ? 1 : 0 11/10/--/y
FP Compare 
Double c.x.d* FR
FPcond = ({F[fs],F[fs+1]} op
                   {F[ft],F[ft+1]}) ? 1 : 0
11/11/--/y
* (x is eq, lt, or le)  (op is ==, <, or <=) ( y is 32, 3c, or 3e)
FP Divide Single div.s FR F[fd] = F[fs] / F[ft] 11/10/--/3
FP Divide 
Double div.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} / 
                               {F[ft],F[ft+1]}
11/11/--/3
FP Multiply Single mul.s FR F[fd] = F[fs] * F[ft] 11/10/--/2
FP Multiply 
Double mul.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} * 
                               {F[ft],F[ft+1]}
11/11/--/2
FP Subtract Single sub.s FR F[fd]=F[fs] - F[ft] 11/10/--/1
FP Subtract 
Double sub.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} - 
                               {F[ft],F[ft+1]}
11/11/--/1
Load FP Single lwc1 I F[rt]=M[R[rs]+SignExtImm] (2) 31/--/--/--
Load FP 
Double ldc1 I
F[rt]=M[R[rs]+SignExtImm]; (2)
F[rt+1]=M[R[rs]+SignExtImm+4]
35/--/--/--
Move From Hi mfhi R R[rd] = Hi 0 /--/--/10
Move From Lo mflo R R[rd] = Lo 0 /--/--/12
Move From Control mfc0 R R[rd] = CR[rs] 10 /0/--/0
Multiply mult R {Hi,Lo} = R[rs] *  R[rt] 0/--/--/18
Multiply Unsigned multu R {Hi,Lo} = R[rs] *  R[rt] (6) 0/--/--/19
Shift Right Arith. sra R R[rd] = R[rt] >>> shamt 0/--/--/3
Store FP Single swc1 I M[R[rs]+SignExtImm] = F[rt] (2) 39/--/--/--
Store FP 
Double sdc1 I
M[R[rs]+SignExtImm] = F[rt]; (2) 
M[R[rs]+SignExtImm+4] = F[rt+1]
3d/--/--/--
FR opcode fmt ft fs fd funct
31 26 25 21 20 16 15 11 10 6 5 0
FI opcode fmt ft immediate
31 26 25 21 20 16 15 0
NAME MNEMONIC OPERATION
Branch Less Than blt if(R[rs]<R[rt]) PC = Label
Branch Greater Than bgt if(R[rs]>R[rt]) PC = Label
Branch Less Than or Equal ble if(R[rs]<=R[rt]) PC = Label
Branch Greater Than or Equal bge if(R[rs]>=R[rt]) PC = Label
Load Immediate li R[rd] = immediate
Move move R[rd] = R[rs]
NAME NUMBER USE PRESERVED ACROSS A CALL?
$zero 0 The Constant Value 0 N.A.
$at 1 Assembler Temporary No
$v0-$v1 2-3 Values for Function Results and Expression Evaluation No
$a0-$a3 4-7 Arguments No
$t0-$t7 8-15 Temporaries No
$s0-$s7 16-23 Saved Temporaries Yes
$t8-$t9 24-25 Temporaries No
$k0-$k1 26-27 Reserved for OS Kernel No
$gp 28 Global Pointer Yes
$sp 29 Stack Pointer Yes
$fp 30 Frame Pointer Yes
$ra 31 Return Address Yes
1 2
M
IP
S 
 R
ef
er
en
ce
 D
at
a 
C
ar
d 
(“G
re
en
 C
ar
d”
)
1.
 P
ul
l a
lo
ng
 p
er
fo
ra
tio
n 
to
 s
ep
ar
at
e 
ca
rd
2.
 F
ol
d 
bo
tto
m
 s
id
e 
(c
ol
um
ns
 3
 a
nd
 4
) 
to
ge
th
er
FLOATING-POINT INSTRUCTION FORMATS
PSEUDOINSTRUCTION SET
Copyright 2009 by Elsevier, Inc., All rights reserved. From Patterson and Hennessy, Computer Organization and Design, 4th ed.
(4) BranchAddr = { 14{immediate[15]}, immediate, 2’b0 }
’(6) Operands considered unsigned numbers (vs. 2 s comp.)
M I P S Refe ence Data
BASIC INSTRUCTION FORMATS
REGISTER NAME, NUMBER, USE, CALL CONVENTION
CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION (in Verilog)
/ FUNCT
(Hex)
Add add R R[rd] = R[rs] + R[rt] (1) 0 / 20hex
Add Immediate addi I R[rt] = R[rs] + SignExtImm (1,2) 8hex
Add Imm. Unsigned addiu I R[rt] = R[rs] + SignExtImm  (2) 9hex
Add Unsigned addu R R[rd] = [rs] + R[rt] 0 / 21hex
And and R R[rd] = s] & [rt] 0 / 24hex
And Immediate andi I R[rt] = R[rs] & ZeroExtImm (3) chex
Branch On Equal beq I if(R[rs]==R[rt])  PC=PC+4+BranchAddr (4)
4hex
Branch On Not Equalbne I if(R[rs]!=R[rt])  PC=PC+4+BranchAddr (4)
5hex
Jump j J PC=JumpAddr (5) 2hex
Jump And Link jal J R[31]=PC+8;PC=JumpAddr (5) 3hex
Jump Register jr R PC=R[rs] 0 / 08hex
Load Byte Unsigned lbu I R[rt]={24’b0,M[R[rs]            +SignExtImm](7:0)} (2)
24hex
Load Halfword 
Unsigned lhu I
R[rt]={16’b0,M[R[rs]
            +SignExtImm](15:0)} (2)
25hex
Load Linked ll I R[rt] = M[R[rs]+SignExtImm] (2,7) 30hex
Load Upper Imm. lui I R[rt] = {imm, 16’b0} fhex
Load Word lw I R[rt] = M[R[rs]+SignExtImm] (2) 23hex
Nor nor R R[rd] = ~ (R[rs] | R[rt]) 0 / 27hex
Or or R R[rd] = [rs] | R[rt] 0 / 25hex
Or Immediate ori I R[rt] = R[rs] | ZeroExtImm (3) dhex
Set Less Than slt R R[rd] = (R[rs] < [rt]) ? 1 : 0 0 / 2ahex
Set Less Than Imm. slti I R[rt] = (R[rs] < SignExtImm)? 1 : 0 (2) ahex
Set Less Than Imm. 
Unsigned sltiu I
R[rt] = (R[rs] < SignExtImm) 
                    ? 1 : 0  (2,6)
bhex
Set Less Than Unsig. sltu R R[rd] = (R[rs] < [rt]) ? 1 : 0  (6 0 / 2bhex
Shift Left ogical sll R R[rd] = t] << shamt 0 / 00hex
Shift Right Logical srl R R[rd] = R[rt] >> shamt 0 / 02hex
Store Byte sb I M[R[rs]+SignExtImm (7:0) =                             R[rt](7:0) (2)
28hex
Store Conditional sc I M[R[rs]+SignExtImm] = R[rt];               R[rt]  (atomic) ? 1 : 0 (2,7)
38hex
Store Halfword sh I M[R[rs]+SignExtImm](15:0) =                                  R[rt](15:0) (2)
29hex
Store Word sw I M[R[rs]+SignExtImm] = R[rt] (2) 2bhex
Subtract sub R R[rd] = R[rs] - R[rt] ( ) 0 / 22hex
Subtract Unsigned subu R R[rd] = R[rs] - R[rt] 0 / 23hex
(1) May cause overflow exception
(2) SignExtImm = { 16{immediate[15]}, immediate }
(3) ZeroExtImm = { 16{1b’0}, immediate }
(5) JumpAddr =    { PC+4[31:28], address, 2’b0 }
(7) Atomic test&set pair; R[rt] = 1 if pair atomic, 0 if not atomic
R opcode rs rt rd shamt funct
31 26 25 21 20 16 15 11 10 6 5 0
I opcode rs rt immediate
31 26 25 21 20 16 15 0
J opcode address
31 26 25 0
ARITHMETIC CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION 
/ FMT /FT
/ FUNCT
(Hex)
Branch On FP True bc1t FI if(FPcond)PC=PC+4+BranchAddr (4) 11/8/1/--
Branch On FP False bc1f FI if(!FPcond)PC=PC+4+BranchAddr(4) 11/8/0/--
Divide div R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] 0/--/--/1a
Divide Unsigned divu R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] (6) 0/--/--/1b
FP Add Single add.s FR F[fd ]= F[fs] + F[ft] 11/10/--/0
FP Add 
Double add.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} + 
                               {F[ft],F[ft+1]}
11/11/--/0
FP Compare Single c.x.s* FR FPcond = (F[fs] op F[ft]) ? 1 : 0 11/10/--/y
FP Compare 
Double c.x.d* FR
FPcond = ({F[fs],F[fs+1]} op
                   {F[ft],F[ft+1]}) ? 1 : 0
11/11/--/y
* (x is eq, lt, or le)  (op is ==, <, or <=) ( y is 32, 3c, or 3e)
FP Divide Single div.s FR F[fd] = F[fs] / F[ft] 11/10/--/3
FP Divide 
Double div.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} / 
                               {F[ft],F[ft+1]}
11/11/--/3
FP Multiply Single mul.s FR F[fd] = F[fs] * F[ft] 11/10/--/2
FP Multiply 
Double mul.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} * 
                               { [ft],F[ft+1]}
11/11/--/2
FP Subtract Single sub.s FR F[fd]=F[fs] - F[ft] 11/10/--/1
FP Subtract 
Double sub.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} - 
                               {F[ft],F[ft+1]}
11/11/--/1
Load FP Single lwc1 I F[rt]=M[R[rs]+SignExtImm] (2) 31/--/--/--
Load FP 
Double ldc1 I
F[rt]=M[R[rs]+SignExtImm]; (2)
F[rt+1]=M[R[rs]+SignExtImm+4]
35/--/--/--
Move From Hi mfhi R R[rd] = Hi 0 /--/--/10
Move From Lo mflo R R[rd] = Lo 0 /--/--/12
Move From C ntrol mfc0 R R[rd] = C [rs] 10 /0/--/0
Multiply mult R {Hi,Lo} = R[rs] *  R[rt] 0/--/--/18
Multiply Unsigned multu R {Hi,Lo} = R[rs] *  R[rt] (6) 0/--/--/19
Shift Right Arith. sra R R[rd] = R[rt] >>> shamt 0/--/--/3
Store FP Single swc1 I M[R[rs]+SignExtImm] = F[rt] (2) 39/--/--/--
Stor  FP 
Double sdc1 I
M[R[rs]+SignExtImm] = F[rt]; (2) 
M[R[rs]+SignExtImm+4] = F[rt+1]
3d/--/--/--
FR opcod fmt ft fs fd funct
31 26 25 21 20 16 15 11 10 6 5 0
FI opcode fmt ft immediate
31 26 25 21 20 16 15 0
NAME MNEMONIC OPERATION
Branch Less Than blt if(R[rs]<R[rt]) PC = Label
Branch Greater Than bgt if(R[rs]>R[rt]) PC = Label
Branch Less Than or Equal ble if(R[rs]<=R[rt]) PC = Label
Branch Greater Than or Equal bge if(R[rs]>=R[rt]) PC = Label
Load Immediate li R[rd] = immediate
Move move R[rd] = R[rs]
NAME NUMBER USE PRESERVED ACROSS A CALL?
$zero 0 The Constant Value 0 N.A.
$at 1 Assembler Temporary No
$v0-$v1 2-3 Values for Function Results and Expression Evaluation No
$a0-$a3 4-7 Arguments No
$t0-$t7 8-15 Temporaries No
$s0-$s7 16-23 Saved Temporaries Yes
$t8-$t9 24-25 Temporaries No
$k0-$k1 26-27 Reserved for OS Kernel No
$gp 28 Global Pointer Yes
$sp 29 Stack Pointer Yes
$fp 30 Frame Pointer Yes
$ra 31 Return Address Yes
1 2
M
IP
S 
 R
ef
er
en
ce
 D
at
a 
Ca
rd
 (“
Gr
ee
n
 C
ar
d”
)
1.
 P
ul
l a
lo
ng
 p
er
fo
ra
tio
n 
to
 s
ep
ar
at
e 
ca
rd
2.
 F
ol
d 
bo
tto
m
 s
id
e 
(c
ol
um
ns
 3
 a
nd
 4
) t
og
et
he
r
FLOATING-POINT INSTRUCTION FORMATS
PSEUDOINSTRUCTION SET
Copyright 2009 by Elsevier, Inc., All rights reserved. From Patterson and Hennessy, Computer Organization and Design, 4th ed.
(4) BranchAddr = { 14{immediate[15]}, immediate, 2’b0 }
’(6) Operands considered unsigned numbers (vs. 2 s comp.)
A 0 
B 1 
C 2 
D 3 
M I P S Reference Data
BASIC INSTRUCTION FORMATS
REGISTER NAME, NUMBER, USE, CALL CONVENTION
CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION (in Verilog)
/ FUNCT
(Hex)
Add add R R[rd] = R[rs] + R[rt] (1) 0 / 20hex
Add Immediate addi I R[rt] = R[rs] + SignExtImm (1,2) 8hex
Add Imm. Unsigned addiu I R[rt] = R[rs] + SignExtImm  (2) 9hex
Add Unsigned addu R R[rd] = R[rs] + R[rt] 0 / 21hex
And and R R[rd] = R[rs] & R[rt] 0 / 24hex
And Immediate andi I R[rt] = R[rs] & ZeroExtImm (3) chex
Branch On Equal beq I if(R[rs]==R[rt])  PC=PC+4+BranchAddr (4)
4hex
Branch On Not Equalbne I if(R[rs]!=R[rt])  PC=PC+4+BranchAddr (4)
5hex
Jump j J PC=JumpAddr (5) 2hex
Jump And Link jal J R[31]=PC+8;PC=JumpAddr (5) 3hex
Jump Register jr R PC=R[rs] 0 / 08hex
Load Byte Unsigned lbu I R[rt]={24’b0,M[R[rs]            +SignExtImm](7:0)} (2)
24hex
Load Halfword 
Unsigned lhu I
R[rt]={16’b0,M[R[rs]
            +SignExtImm](15:0)} (2)
25hex
Load Linked ll I R[rt] = M[R[rs]+SignExtImm] (2,7) 30hex
Load Upper Imm. lui I R[rt] = {imm, 16’b0} fhex
Load Word lw I R[rt] = M[R[rs]+SignExtImm] (2) 23hex
Nor nor R R[rd] = ~ (R[rs] | R[rt]) 0 / 27hex
Or or R R[rd] = R[rs] | R[rt] 0 / 25hex
Or Immediate o I R[rt] = R[rs] | ZeroExtImm (3) dhex
Set Less Than slt R R rd] = (R[rs] < R[rt]) ? 1 : 0 0 / 2ahex
Set Less Than Imm. slti I R[rt] = (R[rs] < SignExtImm)? 1 : 0 (2) ahex
Set Less Than Imm. 
Unsigned sltiu I
R[rt] = (R[rs] < SignExtImm) 
                    ? 1 : 0  (2,6)
bhex
Set Less Than Unsig. sltu R R[rd] = (R[rs] < R[rt]) ? 1 : 0  (6) 0 / 2bhex
Shift Left Logical sll R R[rd] = R[rt] << shamt 0 / 00hex
Shift Right Logical srl R R[rd] = R[rt] >> shamt 0 / 02hex
Store Byte sb I M[R[rs]+SignExtImm](7:0) =                             R[rt](7:0) (2)
28hex
Store Conditional sc I M[R[rs]+SignExtImm] = R[rt];               R[rt] = (atomic) ? 1 : 0 (2,7)
38hex
Store Halfword sh I M[R[rs]+SignExtImm](15:0) =                                  R[rt](15:0) (2)
29hex
Store Word sw I M[R[rs]+SignExtImm] = R[rt] (2) 2bhex
Subtract sub R [rd] = R[rs] - R[rt] (1) 0 / 22hex
Subtract Unsigned subu R R[rd] = R[rs] - R[rt] 0 / 23hex
(1) May cause overflow exception
(2) SignExtImm = { 16{immediate[15]}, immediat  }
(3) ZeroExtImm = { 16{1b’0}, immediate }
(5) JumpAddr =    { PC+4[31:28], address, 2’b0 }
(7) Atomic test&set pair; R[ t] = 1 if pair atomic, 0 if not atomic
R opcode rs rt rd shamt funct
31 26 25 21 20 16 15 11 10 6 5 0
I opcode rs rt immediate
31 26 25 21 20 16 15 0
J opcode address
31 26 25 0
ARITHMETIC CORE INSTRUCTION SET OPCODE
NAME, MNEMONIC
FOR-
MAT OPERATION 
/ FMT /FT
/ FUNCT
(Hex)
Branch On FP True bc1t FI if(FPcond)PC=PC+4+BranchAddr (4) 11/8/1/--
Branch On FP False bc1f FI if(!FPcond)PC=PC+4+BranchAddr(4) 11/8/0/--
Divide div R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] 0/--/--/1a
Divide Unsigned divu R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] (6) 0/--/--/1b
FP Add Single add.s FR F[fd ]= F[fs] + F[ft] 11/10/--/0
FP Add 
Double add.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} + 
                               {F[ft],F[ft+1]}
11/11/--/0
FP Compare Single c.x.s* FR FPcond = (F[fs] op F[ft]) ? 1 : 0 11/10/--/y
FP Compare 
Double c.x.d* FR
FPcond = ({F[fs],F[fs+1]} op
                   {F[ft],F[ft+1]}) ? 1 : 0
11/11/--/y
* (x is eq, lt, or le)  (op is ==, <, or <=) ( y is 32, 3c, or 3e)
FP Divide Single div.s FR F[fd] = F[fs] / F[ft] 11/10/--/3
FP Divide 
Double div.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} / 
                               {F[ft],F[ft+1]}
11/11/--/3
FP Multiply Single mul.s FR F[fd] = F[fs] * F[ft] 11/10/--/2
FP Multiply 
Double mul.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} * 
                               {F[ft],F[ft+1]}
11/11/--/2
FP Subtract Single sub.s FR F[fd]=F[fs] - F[ft] 11/10/--/1
FP Subtract 
Double sub.d FR
{F[fd],F[fd+1]} = {F[fs],F[fs+1]} - 
                               {F[ft],F[ft+1]}
11/11/--/1
Load FP Single lwc1 I F[rt]=M[R[rs]+SignExtImm] (2) 31/--/--/--
Load FP 
Double ldc1 I
F[rt]=M[R[rs]+SignExtImm]; (2)
F[rt+1]=M[R[rs]+SignExtImm+4]
35/--/--/--
Move From Hi mfhi R R[rd] = Hi 0 /--/--/10
Move From Lo mflo R R[rd] = Lo 0 /--/--/12
Move From Control mfc0 R R[rd] = CR[rs] 10 /0/--/0
Multiply mult R {Hi,Lo} = R[rs] *  R[rt] 0/--/--/18
Multiply Unsigned multu R {Hi,Lo} = R[rs] *  R[rt] (6) 0/--/--/19
Shift Right Arith. sra R R[rd] = R[rt] >>> shamt 0/--/--/3
Store FP Single swc1 I M[R[rs]+SignExtImm] = F[rt] (2) 39/--/--/--
Store FP 
Double sdc1 I
M[R[rs]+SignExtImm] = F[rt]; (2) 
M[R[rs]+SignExtImm+4] = F[rt+1]
3d/--/--/--
FR opcode fmt ft fs fd funct
31 26 25 21 20 16 15 11 10 6 5 0
FI opcode fmt ft immediate
31 26 25 21 20 16 15 0
NAME MNEMONIC OPERATION
Branch Less Than blt if(R[rs]<R[rt]) PC = Label
Branch Greater Than bgt if(R[rs]>R[rt]) PC = Label
Branch Less Than or Equal ble if(R[rs]<=R[rt]) PC = Label
Branch Greater Than or Equal bge if(R[rs]>=R[rt]) PC = Label
Load Immediate li R[rd] = immediate
Move move R[rd  = R[rs]
NAME NUMBER USE PRESERVED ACROSS A CALL?
$zero 0 The Constant Value 0 N.A.
$at 1 Assembler Temporary No
$v0-$v1 2-3 Values for Function Results and Expression Evaluation No
$a0-$a3 4-7 Arguments No
$t0-$t7 8-15 Temporaries No
$s0-$s7 16-23 Saved Temporaries Yes
$t8-$t9 24-25 Temporaries No
$k0-$k1 26-27 Reserved for OS Kernel No
$gp 28 Global Pointer Yes
$sp 29 Stack Pointer Yes
$fp 30 Frame Pointer Yes
$ra 31 Return Address Yes
1 2
M
IP
S 
 R
ef
er
en
ce
 D
at
a 
Ca
rd
 (“
Gr
ee
n
 C
ar
d”
)
1.
 P
ul
l a
lo
ng
 p
er
fo
ra
tio
n 
to
 s
ep
ar
at
e 
ca
rd
2.
 F
ol
d 
bo
tto
m
 s
id
e 
(c
ol
um
ns
 3
 a
nd
 4
) t
og
et
he
r
FLOATING-POINT INSTRUCTION FORMATS
PSEUDOINSTRUCTION SET
Copyright 2009 by Elsevier, Inc., All rights reserved. From Patterson and Hennessy, Computer Organization and Design, 4th ed.
(4) BranchAddr = { 14{immediate[15]}, immediate, 2’b0 }
’(6) Operands considered unsigned numbers (vs. 2 s comp.)
imm_val	  
imm_val	  	  
imm_val	  	  
8 
What you will need to learn for exam 2 
  You must become “fluent” in MIPS assembly: 
  Translate from C to MIPS and MIPS to C 
  Example problem from a 232 mid-term: 
Question 3: Write a recursive function (30 points) 
 
Here is a function pow that takes two arguments (n and m, both 32-bit 
numbers) and returns nm (i.e., n raised to the mth  power).  
 
int 
pow(int n, int m) { 
   if (m == 1) 
      return n; 
   return n * pow(n, m-1); 
} 
 
Translate this into a MIPS assembly language function. 
9 
MIPS register names 
  In hardware, all the registers are equivalent: 
  Except register $0, which is always zero 
  In software, we’ll use them for different purposes. 
  So we give them meaningful names 
  For temporary values, we’ll use the $t registers 
 $t0-$t9 
  If you have no reason for picking another register, 
then you should probably be using a $t register. 
10 
  Complex arithmetic expressions may require 
multiple operations at the instruction set level. 
t0 = (t1 + t2) × (t3 - t4)  
  add  $t0, $t1, $t2  # $t0 contains $t1 + $t2 
  sub  $t5, $t3, $t4  # Temporary value $t5 = $t3 - $t4 
  mul  $t0, $t0, $t5  # $t0 contains the final product 
Review: arithmetic expressions 
11 
  So, to compute with memory-based data, you must: 
1. Load the data from memory to the register file. 
2. Do the computation, leaving the result in a register. 
3. Store that value back to memory if needed. 
  For example, let’s say that you wanted to do the same 
addition, but the values were in memory. How can we 
do the following using MIPS assembly language? 
char A[4] = {1, 2, 3, 4}; 
int result; 
 
result = A[0] + A[1] + A[2] + A[3]; 
 
   
Computing with memory 
12 
AllocaDng	  memory	  in	  the	  data	  segment	  
  Data	  define	  outside	  of	  funcDons	  is	  called	  global	  data	  
  These	  variables	  can	  be	  accessed	  from	  any	  func0on	  
  This	  data	  is	  place	  in	  the	  program’s	  global	  data	  segment	  
  Allocated	  to	  memory	  addresses	  at	  compile	  0me.	  
  Amount	  of	  space	  allocated	  is	  based	  on	  variable	  type.	  
	  
.data  // indicates the beginning of data segment 
.word  // allocates space for 4-byte variable 
.byte  // allocates space for 1-byte variable	  
.asciiz  // allocates space for an ASCII string 
.space  // allocates a defined amount of space. 
13 
Review: Loading and storing bytes 
  The MIPS “load byte” instruction lb transfers one byte of data 
from main memory to a register.  
  lb $t0, 20($a0) # $t0 = Memory[$a0 + 20] 
  The “store byte” instruction sb transfers the lowest byte of 
data from a register into main memory.  
  sb $t0, 20($a0) # Memory[$a0 + 20] = $t0 
14 
Review: Loading and storing words 
  You can also load or store 32-bit quantities—a complete word 
instead of just a byte—with the lw and sw instructions. 
  lw $t0, 20($a0)  # $t0 = Memory[$a0 + 20] 
  sw $t0, 20($a0)  # Memory[$a0 + 20] = $t0 
  Most programming languages support several 32-bit data types. 
  Integers 
  Single-precision floating-point numbers 
  Memory addresses, or pointers 
  Unless otherwise stated, we’ll assume words are the basic unit of 
data.  
0  1       2       3       4      5       6      7       8       9     10     11 Address 
8-bit data 
15 
Review: Memory alignment 
  Since memory is byte-addressable, a 32-bit word actually occupies 
four contiguous locations (bytes) of main memory. 
 
 
  The MIPS architecture requires words to be aligned in memory; 32-
bit words must start at an address that is divisible by 4. 
  0, 4, 8 and 12 are valid word addresses. 
  1, 2, 3, 5, 6, 7, 9, 10 and 11 are not valid word addresses. 
  Unaligned memory accesses result in a bus error, which you may 
have unfortunately seen before. 
Word 1 Word 2 Word 3 
Address 
8-bit data 
0  1       2       3       4      5       6      7       8       9     10     11 
16 
Arrays	  
  Arrays	  are	  just	  groups	  of	  variables	  conDguous	  in	  memory	  
  Con0guous	  =	  laid	  out	  one	  aQer	  another	  in	  memory.	  
char name[8];	  
 
 
 
 
int pair[2]; 
0  1       2       3       4      5       6      7       8       9     10     11 Address 
8-bit data 
0  1       2       3       4      5       6      7       8       9     10     11 Address 
8-bit data 
17 
October 2, 2013 Introduction to CS232 17 
An array of words 
  Remember to be careful with memory addresses when accessing 
words. 
  For instance, assume an array of words begins at address 2000. 
  The first array element is at address 2000. 
  The second word is at address 2004, not 2001. 
  Revisiting the earlier example, if $a0 contains 2000, then 
lw $t0, 0($a0) 
 accesses the 0th word of the array, but 
lw $t0, 8($a0) 
 would access the 2nd word of the array, at address 2008. 
18 
Pseudo-instructions 
  MIPS assemblers support pseudo-instructions that give the 
illusion of a more expressive instruction set, but are actually 
translated into one or more simpler, “real” instructions. 
  In addition to the la (load address) we saw in section, you can 
use the li and move pseudo-instructions: 
  li  $a0, 2000  # Load immediate 2000 into $a0 
  move  $a1, $t0  # Copy $t0 into $a1 
  They are probably clearer than their corresponding MIPS 
instructions: 
  addi  $a0, $0, 2000  # Initialize $a0 to 2000 
  add  $a1, $t0, $0  # Copy $t0 into $a1 
  We’ll see lots more pseudo-instructions this semester. 
  A complete list of instructions is given in Appendix A of the text. 
  Unless otherwise stated, you can always use pseudo-instructions 
in your assignments and on exams. 
 
19 
  Do you remember how much of a pain it is to implement: 
if (x < 10) { 
  ... 
} 
 
  Need a slt and a beq…. (or was it a bne?) 
slti $t0, $t4, 10     # immediate version of slt 
____ $t0, $zero, skip_if_body   # beq(a) or bne(b)? 
 
  This is extremely error prone; bad design for humans 
Pseudo-branches (motivation) 
20 
  The MIPS processor only supports two branch instructions, 
beq and bne, but to simplify your life the assembler provides 
the following other branches:  
    
   blt  $t0, $t1, L1  // Branch if $t0 < $t1 
   ble  $t0, $t1, L2  // Branch if $t0 <= $t1 
   bgt  $t0, $t1, L3  // Branch if $t0 > $t1 
   bge  $t0, $t1, L4  // Branch if $t0 >= $t1 
  There are also immediate versions of these branches, where 
the second source is a constant instead of a register. 
 
Pseudo-branches 
21 
  Most pseudo-branches are implemented using slt. For example, a 
branch-if-less-than instruction blt $a0, $a1, Label is translated 
into the following. 
  slt  $at, $a0, $a1  // $at = 1 if $a0 < $a1 
  bne  $at, $0, Label  // Branch if $at != 0 
  All of the pseudo-branches need a register to save the result of 
slt, even though it’s not needed afterwards. 
  MIPS assemblers use register $1, or $at, for temporary storage. 
  You should probably avoid using $at in your own programs, as it 
may be overwritten by assembler-generated code. 
Implementing pseudo-branches 
22 
Translating an if-then-else statements 
  If there is an else clause, it is the target of the 
conditional branch 
  And the then clause needs a jump over the else clause 
  // increase the magnitude of v0 by one 
  if (v0 < 0)   bge  $v0, $0, E 
   v0 --;   subi $v0, $v0, 1 
     j  L 
  else     
   v0 ++;  E:  addi $v0, $v0, 1 
  v1 = v0;  L:  move $v1, $v0 
  Dealing with else-if code is similar, but the target of 
the first branch will be another if statement. 
  Drawing the control-flow graph can help you out. 
