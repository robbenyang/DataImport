1 
MP4 available, due 10/18, 11:59p.  
 
 
 
 
 
 
 
 
 
Announcements 
Dictionary ADT:  (BST implementation) 
insert 
remove 
find 
traverse 
template <class K, class D> 
class Dictionary{ 
public: 
// constructor for empty tree. 
private: 
   struct treeNode{ 
      D data; 
      K key; 
      treeNode * left; 
      treeNode * right; 
   }; 
   treeNode * root 
}; 
Binary Search Tree - Find 
 
treeNode * BST<K,D>::find(treeNode * cRoot, const K & key) { 
   if (cRoot == NULL) 
      return cRoot; 
   else if (cRoot->key == key) 
      return cRoot; 
   else if (key < cRoot->key) 
      return find(cRoot->left, key); 
   else 
      return find(cRoot->right, key); 
} 
(http://webdiis.unizar.es/asignaturas/EDA/AVLTree/avltree.html) 
Binary Search Tree - Insert 
 
________________________ 
(treeNode * cRoot, const K & key, const D & data){ 
   if (cRoot == NULL) 
 
 
   else if (cRoot->key == key) 
 
 
   else if (key < cRoot->key) 
 
 
   else 
 
 
} 
Binary Search Tree - Remove 
void BST<K>::remove(treeNode * & cRoot, const T & key) { 
   if (cRoot == NULL) 
      return;  // no op… key not found 
   else if (cRoot->key == key) 
      doRemoval(cRoot); 
   else if (d < cRoot->key) 
      remove(cRoot->left,d); 
   else 
      remove(cRoot->right,d); 
} 
Binary Search Tree - Remove 
T.remove(37); 
T.remove(10); 
T.remove(13); 
Binary Search Tree - Remove 
void BST<K>::remove(treeNode * & cRoot, const T & d) { 
   if (cRoot == NULL) 
      return;  // no op… key not found 
   else if (cRoot->key == d) 
      doRemoval(cRoot); 
   else if (d < cRoot->key) 
      remove(cRoot->left,d); 
   else 
      remove(cRoot->right,d); 
} 
void BST<K>::doRemoval(treeNode * & cRoot) { 
   if ((cRoot->left == NULL) && (cRoot->right == NULL)) 
      noChildRemove(cRoot); 
   else if ((cRoot->left != NULL) && (cRoot->right != NULL)) 
      twoChildRemove(cRoot); 
   else  
      oneChildRemove(cRoot); 
} 
Binary Search Tree - Remove 
void BST<K>::remove(treeNode * & cRoot, const T & d) { 
   if (cRoot == NULL) 
      return;  // no op… key not found 
   else if (cRoot->key == d) 
      doRemoval(cRoot); 
   else if (d < cRoot->key) 
      remove(cRoot->left,d); 
   else 
      remove(cRoot->right,d); 
} 
void BST<K>::doRemoval(treeNode * & cRoot) { 
   if ((cRoot->left == NULL) && (cRoot->right == NULL)) 
      noChildRemove(cRoot); 
   else if ((cRoot->left != NULL) && (cRoot->right != NULL)) 
      twoChildRemove(cRoot); 
   else  
      oneChildRemove(cRoot); 
} 
void BST<K>::noChildRemove(treeNode * & cRoot) { 
   delete cRoot; 
   cRoot = NULL; 
} 
Binary Search Tree - Remove 
void BST<K>::remove(treeNode * & cRoot, const T & d) { 
   if (cRoot == NULL) 
      return;  // no op… key not found 
   else if (cRoot->key == d) 
      doRemoval(cRoot); 
   else if (d < cRoot->key) 
      remove(cRoot->left,d); 
   else 
      remove(cRoot->right,d); 
} 
void BST<K>::doRemoval(treeNode * & cRoot) { 
   if ((cRoot->left == NULL) && (cRoot->right == NULL)) 
      noChildRemove(cRoot); 
   else if ((cRoot->left != NULL) && (cRoot->right != NULL)) 
      twoChildRemove(cRoot); 
   else  
      oneChildRemove(cRoot); 
} 
void BST<T,S>::noChildRemove(treeNode * & cRoot) { 
   treeNode * temp = cRoot; 
   cRoot = NULL; 
   delete temp; 
} 
void BST<K>::oneChildRemove(treeNode * & cRoot) { 
   treeNode * temp = cRoot; 
   if (cRoot->left == NULL) cRoot = cRoot->right; 
   else cRoot = cRoot->left;  
   delete temp;      
} 
Binary Search Tree - Remove 
void BST<K>::remove(treeNode * & cRoot, const T & d) { 
   if (cRoot == NULL) 
      return;  // no op… key not found 
   else if (cRoot->key == d) 
      doRemoval(cRoot); 
   else if (d < cRoot->key) 
      remove(cRoot->left,d); 
   else 
      remove(cRoot->right,d); 
} 
void BST<K>::doRemoval(treeNode * & cRoot) { 
   if ((cRoot->left == NULL) && (cRoot->right == NULL)) 
      noChildRemove(cRoot); 
   else if ((cRoot->left != NULL) && (cRoot->right != NULL)) 
      twoChildRemove(cRoot); 
   else  
      oneChildRemove(cRoot); 
} 
void BST<T,S>::noChildRemove(treeNode * & cRoot) { 
   treeNode * temp = cRoot; 
   cRoot = NULL; 
   delete temp; 
} 
void BST<T,S>::oneChildRemove(treeNode * & cRoot) { 
   treeNode * temp = cRoot; 
   if (cRoot->left == NULL) cRoot = cRoot->right; 
   else cRoot = cRoot->left;  
   delete temp;      
} 
void BST<K>::twoChildRemove(treeNode * & cRoot) { 
   treeNode * iop = IOP(cRoot); 
   cRoot->key = iop->key; 
   doRemoval(IOP(cRoot));      
} 
Binary Search Tree - Remove 
void BST<K>::remove(treeNode * & cRoot, const T & d) { 
   if (cRoot == NULL) 
      return;  // no op… key not found 
   else if (cRoot->key == d) 
      doRemoval(cRoot); 
   else if (d < cRoot->key) 
      remove(cRoot->left,d); 
   else 
      remove(cRoot->right,d); 
} 
void BST<K>::doRemoval(treeNode * & cRoot) { 
   if ((cRoot->left == NULL) && (cRoot->right == NULL)) 
      noChildRemove(cRoot); 
   else if ((cRoot->left != NULL) && (cRoot->right != NULL)) 
      twoChildRemove(cRoot); 
   else  
      oneChildRemove(cRoot); 
} 
void BST<T,S>::noChildRemove(treeNode * & cRoot) { 
   treeNode * temp = cRoot; 
   cRoot = NULL; 
   delete temp; 
} 
void BST<T,S>::oneChildRemove(treeNode * & cRoot) { 
   treeNode * temp = cRoot; 
   if (cRoot->left == NULL) cRoot = cRoot->right; 
   else cRoot = cRoot->left;  
   delete temp;      
} 
void BST<T,S>::twoChildRemove(treeNode * & cRoot) { 
   treeNode * iop = IOP(cRoot); 
   cRoot->key = iop->key; 
   doRemoval(iop);      
} 
treeNode * & BST<K>::IOP(treeNode * & cRoot) { 
   return rightMostChild(cRoot->left); 
} 
Binary Search Tree - Remove 
void BST<K>::remove(treeNode * & cRoot, const T & d) { 
   if (cRoot == NULL) 
      return;  // no op… key not found 
   else if (cRoot->key == d) 
      doRemoval(cRoot); 
   else if (d < cRoot->key) 
      remove(cRoot->left,d); 
   else 
      remove(cRoot->right,d); 
} 
void BST<K>::doRemoval(treeNode * & cRoot) { 
   if ((cRoot->left == NULL) && (cRoot->right == NULL)) 
      noChildRemove(cRoot); 
   else if ((cRoot->left != NULL) && (cRoot->right != NULL)) 
      twoChildRemove(cRoot); 
   else  
      oneChildRemove(cRoot); 
} 
void BST<T,S>::noChildRemove(treeNode * & cRoot) { 
   treeNode * temp = cRoot; 
   cRoot = NULL; 
   delete temp; 
} 
void BST<T,S>::oneChildRemove(treeNode * & cRoot) { 
   treeNode * temp = cRoot; 
   if (cRoot->left == NULL) cRoot = cRoot->right; 
   else cRoot = cRoot->left;  
   delete temp;      
} 
void BST<T,S>::twoChildRemove(treeNode * & cRoot) { 
   treeNode * iop = IOP(cRoot); 
   cRoot->key = iop->key; 
   doRemoval(iop);      
} 
treeNode * & BST<T,S>::IOP(treeNode * & cRoot) { 
   return rightMostChild(cRoot->left); 
} 
treeNode * & BST<K>::rightMostChild(treeNode * & cRoot) { 
   if (cRoot->right == NULL) return cRoot; 
   else return rightMostChild(cRoot->right); 
} 
