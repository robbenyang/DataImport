L1:!Labels:  
j target_label!Uncondi/onal  Jump:  
#  mark  a  place  in  the  code  to  reference  
#  from  other  instruc4ons  
#  the  next  instruc4on  to  execute  is  the    
#  one  labeled  with  the  “target_label”  
beq rs, rt, label!Condi/onal  Branch:   #  if  R[rs]  ==  R[rt]  execute  instruc4on  at    
#  “label”,  otherwise  execute  next  inst.  
op address 
op rs rt address 
Next_PC[31:0]  =  PC[31:28],  “address”  [25:0],  2’b00.  
Next_PC[31:0]  =  PC[31:0]  +  4  +  sign_extend(address  <<  2)  
jr rs!Jump  Register:   #  execute  the  instruc4on  at  the  address  
#  held  in  register  “rs”.  
Next_PC[31:0]  =  R[rs]  
op rs rt rd shamt func 
int sum = 0, i = 0;!
do {!
   sum += i;!
   i++!
} while (i != 10) !
int sum = 0;!
for (int i = 0 ; i != x ; i ++) {!
!sum += i;!
}!
2 (Add)
32
alu_op[2:0]
write_enable
itype
except
opcode[5:0]
funct[5:0]
MIPS decoder
A[31:0]
alu_op[2:0]
out[31:0]
B[31:0]
ALU
rsDatarsNum
reset
rdNum
rtDatartNum
rdWriteEnable
rdData
Register File
reset
clk
wr_enable
Rdest
Rt
Rs
zero
negative
overflow
0
1
wr_enable
itype
itype
alu_op[2:0]
reset
enable
Q[31:0]
D[31:0]
PC Register
Sign 
Extender
out[31:0]
in[15:0]
data[31:0]
addr[29:0]
Instruction
Memory
4
inst[31:0]
PC[31:0]
ALU
1
nextPC[31:0]
0
1
itype
inst[25:21]
inst[20:16]
inst[15:11]
inst[20:16]
inst[5:0]
inst[15:0]
inst[31:26]
except
PC
[3
1:
2]
Rt
Rd
imm16
imm32
32
30
32
3
5
5
5
16
32
6
6
32
32
32
32
32
3
3
control_type
0 1 2 3
2 (Add)
ALU
3
Shift Left 2
out[31:0]
in[29:0]30 32
inst[25:21] 00 (for LSBs)
PC[31:28] (for MSBs)
branch
offset
branch
offset
32
control_type control_type
inst[25:0]	  
