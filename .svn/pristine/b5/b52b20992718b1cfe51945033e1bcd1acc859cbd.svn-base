10/29/13 1 
Programming Languages and 
Compilers (CS 421) 
Elsa L Gunter 
2112 SC, UIUC 
http://courses.engr.illinois.edu/cs421 
Based in part on slides by Mattox Beckman, as updated 
by Vikram Adve and Gul Agha 
10/29/13 2 
Types of Formal Language Descriptions 
n  Regular expressions, regular grammars 
n  Context-free grammars, BNF grammars, 
syntax  diagrams 
n  Finite state automata 
n  Whole family more of grammars and 
automata – covered in automata theory 
10/29/13 3 
Sample Grammar 
n  Language: Parenthesized sums of 0’s and 
1’s 
 
n  <Sum> ::= 0  
n  <Sum >::= 1  
n  <Sum> ::= <Sum> + <Sum> 
n  <Sum> ::= (<Sum>) 
10/29/13 4 
BNF Grammars 
n  Start with a set of characters,   a,b,c,… 
n  We call these terminals 
n  Add a set of different characters, X,Y,Z,
… 
n  We call these nonterminals 
n  One special nonterminal S called start 
symbol 
10/29/13 5 
BNF Grammars 
n  BNF rules (aka productions) have form 
         X ::= y 
    where X is any nonterminal and y is a string 
of terminals and nonterminals 
n  BNF grammar is a set of BNF rules such that 
every nonterminal appears on the left of 
some rule 
10/29/13 6 
Sample Grammar 
n  Terminals: 0 1 + ( ) 
n  Nonterminals: <Sum> 
n  Start symbol = <Sum> 
n  <Sum> ::= 0  
n  <Sum >::= 1  
n  <Sum> ::= <Sum> + <Sum> 
n  <Sum> ::= (<Sum>) 
n  Can be abbreviated as 
 <Sum> ::= 0 | 1  
                | <Sum> + <Sum> | (<Sum>) 
10/29/13 7 
BNF Deriviations 
n  Given rules  
X::= yZw and Z::=v  
we may replace Z by v to say 
X => yZw => yvw  
n  Sequence of such replacements called 
derivation 
n  Derivation called right-most if always 
replace the right-most non-terminal 
10/29/13 8 
BNF Derivations 
n  Start with the start symbol: 
 
<Sum> => 
10/29/13 9 
BNF Derivations 
n  Pick a non-terminal 
<Sum> => 
10/29/13 10 
n  Pick a rule and substitute: 
n  <Sum> ::= <Sum> + <Sum> 
<Sum> => <Sum> + <Sum > 
BNF Derivations 
10/29/13 11 
n  Pick a non-terminal: 
 
<Sum> => <Sum> + <Sum > 
BNF Derivations 
10/29/13 12 
n  Pick a rule and substitute: 
n  <Sum> ::= ( <Sum> ) 
<Sum> => <Sum> + <Sum > 
            => ( <Sum> ) + <Sum> 
BNF Derivations 
10/29/13 13 
n  Pick a non-terminal: 
 
<Sum> => <Sum> + <Sum > 
            => ( <Sum> ) + <Sum> 
BNF Derivations 
10/29/13 14 
n  Pick a rule and substitute: 
n  <Sum> ::= <Sum> + <Sum> 
<Sum> => <Sum> + <Sum > 
            => ( <Sum> ) + <Sum> 
            => ( <Sum> + <Sum> ) + <Sum>  
BNF Derivations 
10/29/13 15 
n  Pick a non-terminal: 
 
<Sum> => <Sum> + <Sum > 
            => ( <Sum> ) + <Sum> 
            => ( <Sum> + <Sum> ) + <Sum>  
BNF Derivations 
10/29/13 16 
n  Pick a rule and substitute: 
n  <Sum >::= 1 
<Sum> => <Sum> + <Sum > 
            => ( <Sum> ) + <Sum> 
            => ( <Sum> + <Sum> ) + <Sum>  
            => ( <Sum> + 1 ) + <Sum> 
BNF Derivations 
10/29/13 17 
n  Pick a non-terminal: 
 
<Sum> => <Sum> + <Sum > 
            => ( <Sum> ) + <Sum> 
            => ( <Sum> + <Sum> ) + <Sum>  
            => ( <Sum> + 1 ) + <Sum> 
BNF Derivations 
10/29/13 18 
n  Pick a rule and substitute: 
n  <Sum >::= 0 
<Sum> => <Sum> + <Sum > 
            => ( <Sum> ) + <Sum> 
            => ( <Sum> + <Sum> ) + <Sum>  
            => ( <Sum> + 1 ) + <Sum> 
            => ( <Sum> + 1 ) + 0 
BNF Derivations 
10/29/13 19 
n  Pick a non-terminal: 
<Sum> => <Sum> + <Sum > 
            => ( <Sum> ) + <Sum> 
            => ( <Sum> + <Sum> ) + <Sum>  
            => ( <Sum> + 1 ) + <Sum> 
            => ( <Sum> + 1 ) + 0 
BNF Derivations 
10/29/13 20 
n  Pick a rule and substitute 
n  <Sum> ::= 0 
<Sum> => <Sum> + <Sum > 
            => ( <Sum> ) + <Sum> 
            => ( <Sum> + <Sum> ) + <Sum>  
            => ( <Sum> + 1 ) + <Sum> 
            => ( <Sum> + 1 ) 0 
            => ( 0 + 1 ) + 0 
BNF Derivations 
10/29/13 21 
n  ( 0 + 1 ) + 0  is generated by grammar 
<Sum> => <Sum> + <Sum > 
            => ( <Sum> ) + <Sum> 
            => ( <Sum> + <Sum> ) + <Sum>  
            => ( <Sum> + 1 ) + <Sum> 
            => ( <Sum> + 1 ) + 0 
            => ( 0 + 1 ) + 0 
BNF Derivations 
10/29/13 22 
<Sum> ::= 0 | 1 | <Sum> + <Sum> | (<Sum>) 
<Sum> => 
10/29/13 23 
BNF Semantics 
n  The meaning of a BNF grammar is the 
set of all strings consisting only of 
terminals that can be derived from the 
Start symbol 
10/29/13 24 
Regular Grammars 
n  Subclass of BNF 
n  Only rules of form 
<nonterminal>::=<terminal><nonterminal> or 
<nonterminal>::=<terminal> or 
<nonterminal>::=ε 
n  Defines same class of languages as regular 
expressions 
n  Important for writing lexers (programs that 
convert strings of characters into strings of 
tokens) 
10/29/13 25 
Example 
n  Regular grammar:  
<Balanced> ::= ε 
<Balanced> ::=  0<OneAndMore> 
<Balanced> ::= 1<ZeroAndMore> 
<OneAndMore> ::= 1<Balanced> 
<ZeroAndMore> ::= 0<Balanced> 
n  Generates even length strings where every 
initial substring of even length has same 
number of 0’s as 1’s 
10/29/13 26 
Extended BNF Grammars 
n  Alternatives: allow rules of from X::=y|z 
n  Abbreviates  X::= y, X::= z 
n  Options:  X::=y[v]z 
n  Abbreviates X::=yvz, X::=yz 
n  Repetition: X::=y{v}*z 
n  Can be eliminated by adding new 
nonterminal V and rules X::=yz, X::=yVz, 
V::=v, V::=vV 
10/29/13 27 
n  Graphical representation of derivation 
n  Each node labeled with either non-terminal 
or terminal 
n  If node is labeled with a terminal, then it is a 
leaf (no sub-trees) 
n  If node is labeled with a non-terminal, then 
it has one branch for each character in the 
right-hand side of rule used to substitute for 
it 
Parse Trees 
10/29/13 28 
Example 
n  Consider grammar: 
 <exp>  ::= <factor> 
               |  <factor> +  <factor> 
 <factor>  ::=  <bin>  
                 |  <bin>  *  <exp> 
 <bin> ::=  0  | 1 
n  Problem: Build parse tree for  1 * 1 + 0 as 
an <exp> 
10/29/13 29 
Example cont. 
n  1 * 1 + 0:    <exp> 
 
 
<exp> is the start symbol for this parse 
tree 
10/29/13 30 
Example cont. 
n  1 * 1 + 0:    <exp> 
 
                    <factor> 
 
Use rule: <exp> ::=  <factor> 
10/29/13 31 
Example cont. 
n  1 * 1 + 0:    <exp> 
 
                    <factor> 
 
           <bin>      *         <exp> 
 
Use rule:  <factor> ::=  <bin> *  <exp> 
10/29/13 32 
Example cont. 
n  1 * 1 + 0:    <exp> 
 
                    <factor> 
 
           <bin>      *         <exp> 
 
              1         <factor>  +    <factor> 
 
Use rules:  <bin> ::= 1   and 
                  <exp> ::= <factor>  + 
<factor> 
10/29/13 33 
Example cont. 
n  1 * 1 + 0:    <exp> 
 
                    <factor> 
 
           <bin>      *         <exp> 
 
              1         <factor>  +    <factor> 
 
                           <bin>            <bin> 
 
 
Use rule:  <factor> ::= <bin> 
10/29/13 34 
Example cont. 
n  1 * 1 + 0:    <exp> 
 
                    <factor> 
 
           <bin>      *         <exp> 
 
              1         <factor>  +    <factor> 
 
                           <bin>            <bin> 
 
                               1                   0 
Use rules:  <bin> ::= 1 | 0 
10/29/13 35 
Example cont. 
n  1 * 1 + 0:    <exp> 
 
                    <factor> 
 
           <bin>      *         <exp> 
 
              1         <factor>  +    <factor> 
 
                           <bin>            <bin> 
 
                               1                   0 
Fringe of tree is string generated by grammar 
10/29/13 36 
Your Turn: 1 * 0 + 0 * 1 
10/29/13 37 
Parse Tree Data Structures 
n  Parse trees may be represented by OCaml 
datatypes 
n  One datatype for each nonterminal 
n  One constructor for each rule 
n  Defined as mutually recursive collection of 
datatype declarations 
10/29/13 38 
Example 
n  Recall grammar: 
<exp>  ::= <factor>  |  <factor> +  <factor> 
<factor>  ::=  <bin> |  <bin>  *  <exp> 
<bin> ::=  0  | 1 
n  type exp = Factor2Exp of factor 
                   | Plus of factor * factor 
    and factor = Bin2Factor of bin  
                       | Mult of bin * exp 
    and bin = Zero | One 
10/29/13 39 
Example cont. 
n  1 * 1 + 0:    <exp> 
 
                    <factor> 
 
           <bin>      *         <exp> 
 
              1         <factor>  +    <factor> 
 
                           <bin>            <bin> 
 
                               1                   0 
 
10/29/13 40 
Example cont. 
n  Can be represented as 
Factor2Exp 
(Mult(One,   
          Plus(Bin2Factor One, 
                   Bin2Factor Zero))) 
10/29/13 41 
Ambiguous Grammars and Languages 
n  A BNF grammar is ambiguous if its language 
contains strings for which there is more than 
one parse tree 
n  If all BNF’s for a language are ambiguous 
then the language is inherently ambiguous 
10/29/13 42 
Example: Ambiguous Grammar 
n  0 + 1 + 0 
                <Sum>                 <Sum> 
 
        <Sum> + <Sum>  <Sum> + <Sum> 
 
<Sum> + <Sum>  0         0   <Sum> + <Sum> 
 
     0             1                            1             0 
 
10/29/13 43 
Example 
n  What is the result for: 
3 + 4 * 5 + 6 
10/29/13 44 
Example 
n  What is the result for: 
3 + 4 * 5 + 6 
n  Possible answers: 
n     41 = ((3 + 4) * 5) + 6 
n     47 = 3 + (4 * (5 + 6)) 
n     29 = (3 + (4 * 5)) + 6 = 3 + ((4 * 5) + 6) 
n     77 = (3 + 4) * (5 + 6) 
10/29/13 45 
Example 
n  What is the value of: 
7 – 5 – 2 
10/29/13 46 
Example 
n  What is the value of: 
7 – 5 – 2 
n  Possible answers: 
n  In Pascal, C++, SML assoc. left 
  7 – 5 – 2 = (7 – 5) – 2 = 0 
n  In APL, associate to right 
  7 – 5 – 2 = 7 – (5 – 2) = 4 
10/29/13 47 
Two Major Sources of Ambiguity 
n  Lack of determination of operator 
precedence 
n  Lack of determination of operator 
assoicativity 
n  Not the only sources of ambiguity 
Disambiguating a Grammar 
n  Given ambiguous grammar G, with start 
symbol S, find a grammar G’ with same start 
symbol, such that 
language of G = language of G’ 
n  Not always possible 
n  No algorithm in general 
10/29/13 48 
Disambiguating a Grammar 
n  Idea: Each non-terminal represents all 
strings having some property 
n  Identify these properties (often in terms of 
things that can’t happen) 
n  Use these properties to inductively 
guarantee every string in language has a 
unique parse 
10/29/13 49 
10/29/13 50 
Example 
n  Ambiguous grammar: 
<exp>  ::=  0  | 1  | <exp> +  <exp> 
              |  <exp>  *  <exp> 
n  String with more then one parse: 
0 + 1 + 0 
1 * 1 + 1 
n  Sourceof ambiuity: associativity and 
precedence 
10/4/07 51 
Two Major Sources of Ambiguity 
n  Lack of determination of operator 
precedence 
n  Lack of determination of operator 
assoicativity 
n  Not the only sources of ambiguity 
10/4/07 52 
How to Enforce Associativity 
n  Have at most one recursive call per 
production 
n  When two or more recursive calls would 
be natural leave right-most one for 
right assoicativity, left-most one for left 
assoiciativity 
10/4/07 53 
Example 
n  <Sum> ::= 0 | 1 | <Sum> + <Sum> 
                | (<Sum>) 
n  Becomes 
n  <Sum> ::= <Num> | <Num> + <Sum> 
n  <Num> ::= 0 | 1 | (<Sum>) 
 
 
10/4/07 54 
Operator Precedence 
n  Operators of highest precedence 
evaluated first (bind more tightly). 
n  Precedence for infix binary operators 
given in following table 
n  Needs to be reflected in grammar 
10/4/07 55 
Precedence Table - Sample 
Fortan Pascal C/C++ 
 
Ada SML 
highest ** *, /, 
div, 
mod 
++, -- ** div, 
mod, /
, * 
*, / +, - *, /, 
% 
*, /, 
mod 
+, -, 
^ 
+, - +, - +, - :: 
10/4/07 56 
First Example Again 
n  In any above language, 3 + 4 * 5 + 6 
= 29 
n  In APL, all infix operators have same 
precedence 
n  Thus we still don’t know what the value is 
(handled by associativity) 
n  How do we handle precedence in 
grammar? 
10/4/07 57 
Predence in Grammar 
n  Higher precedence translates to longer 
derivation chain 
n  Example: 
<exp> ::= 0 | 1  | <exp> + <exp>  
              | <exp> * <exp> 
n  Becomes 
<exp> ::= <mult_exp> 
              | <exp> + <mult_exp> 
<mult_exp> ::= <id> | <mult_exp> * <id>  
<id> ::= 0 | 1  
