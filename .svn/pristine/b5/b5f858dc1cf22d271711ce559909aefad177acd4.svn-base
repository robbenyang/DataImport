Register @ acm.uiuc.edu/attend 
 
reflections   
October 10th-13th, Siebel 
Center 
Registration is free and open to 
all. 
Volunteer for a free t-shirt and 
catered meals every day of 
conference! 
Volunteer @ acm.uiuc.edu/helpout 
 
projections 2013 
 
1
MP1 grading run for late adders 9/11, 11:59p.
MP2 available, due 9/17, 11:59p.
VIM tutorial - Fri, 9/13, 7p, Siebel 0224  **************************
Where were we?  
Write the copy constructor function signature as it appears in the sphere class 
definition:
List two instances in which a class’s copy constructor is called:
1. 
2. 
Announcements
 
class sphere{
public:
sphere();
sphere(double r);
sphere(const sphere & orig);
void setRadius(double newRad);
double getDiameter() const;
…
private:
double theRadius;
int numAtts;
string * atts;
};
int main(){
   sphere s;
   …// initialize s
   sphere t(s); //invokes CC
   return 0;
}
Poser: cctor - why pbr?
…
//copy constructor
sphere::sphere(const sphere & orig):
theRadius(orig.theRadius),numatts(orig.numAtts)
{
  atts = new string[numAtts];
  for(int i=0; i<numAtts;i++)
    atts[i]= orig.atts[i];
}
…
red
shiny
juicy
1.0
3
Destructors:
class sphere{
public:
sphere();
sphere(double r);
sphere(const sphere & orig);
~sphere();
…
private:
double theRadius;
int numAtts;
string * atts;
};
//destructor
sphere::~sphere(){
   
}
void myFun(sphere s){
   sphere t(s);
   …
   // play with s and t
   …
}
int main(){
  sphere a;
   myFun(a);
}
3.2
3
Red Shiny juicy
Destructors:
class sphere{
public:
sphere();
sphere(double r);
sphere(const sphere & orig);
~sphere();
…
private:
double theRadius;
int numAtts;
string * atts;
};
//destructor
sphere::~sphere(){
   
}
3.2
3
Red Shiny juicy
int main(){
   sphere * b = new sphere;
   delete b;
   return 0;
}
The destructor, a summary:
1.  Destructor is never “called.”  Rather, we provide it for the 
system to use in two situations:
a)  __________________
b)  __________________
2.  If your constructor, __________________, allocates 
dynamic memory, then you need a destructor.
3.Destructor typically consists of a sequence of delete 
statements.
One more problem:
class sphere{
public:
sphere();
sphere(double r);
sphere(const sphere & orig);
~sphere();
…
private:
double theRadius;
int numAtts;
string * atts;
};
int main(){
  sphere a, b;
   // initialize a 
   b = a;
   return 0;
}
Overloaded operators:
int main(){
   // declare a,b,c
   // initialize a,b
   c = a + b;
   return 0;
}
// overloaded operator
sphere & sphere::operator+
    (const sphere & s){
  
 
}
Overloaded operators: what can be overloaded?
arithmetic operators, logical operators, I/O stream operators
+    -    *    /    =    <    >    +=   -=   *=   /=   
<<   >>     <<=  >>=  ==   !=   <=   >=   ++   --   %    &   
^    !    | ~    &=   ^=   |=   &&   ||   %=   
[]   ()   ,    ->*  ->   
new   delete    new[]     delete[]
One more problem: default assignment is memberwise, so we redefine =.
class sphere{
public:
sphere();
sphere(double r);
sphere(const sphere & orig);
~sphere();
sphere & operator=(const sphere & rhs);
…
private:
double theRadius;
int numAtts;
string * atts;
};
int main(){
  sphere a, b;
   // initialize a 
   b = a;
   return 0;
}
2.5
3
Red
Juicy
crunchy
2.5
3
a b
Operator= the plan:
class sphere{
public:
sphere();
sphere(double r);
sphere(const sphere & orig);
~sphere();
…
private:
double theRadius;
int numAtts;
string * attributes;
};
…
// overloaded = 
_________sphere::operator=(const sphere & rhs){
   
}
…
int main(){
  sphere a, b;
   // initialize a
   b = a;
   return 0;
}
250690176
4
wet
rocky
rotating
inhabited
2.5
3
b a
Red
Juicy
crunchy
