1 
MP3, EC grading runs 9/27-10/1 with EC due 10/1, due 10/08 
MP 3.1 will be on Exam 1. 
Exam 1: 10/1, 7-10p, in rooms tba. 75min exam, given 3hr. 
Class cancelled 9/30. 
Review session – 9/30, 12-2p, Siebel 1404. 
Review session – 9/30, 2-3p, Siebel 0216. 
 
MP2 solution party: Sun, 9/29, 4-6pm, Room ?. 
Code Challenge 10/2 9pm 
 
 
 
 
Announcements 
Summary – running times for List functions: 
      SLL  Array 
Insert/Remove at front:  O(1)  O(1) 
 
Insert at given location:  O(1)  O(1) 
 
Remove at given location:  O(1) hack O(n) shift 
 
Insert at arbitrary location:  O(1)   O(n) shift 
 
Remove at arbitrary location: O(n) find O(n) shift 
What happens? 
3 
 int v; 
 int * w; 
 v = 10; 
 w = v; 
 *w = 8; 
 cout << v << endl; 
 int b; 
 int * a = new int(8); 
 b = *a; 
 *a = 10; 
 cout << b << endl; 
 delete a; 
What is the result of executing 
these statements? 
(a) 8 is sent to standard out. 
(b) 10 is sent to standard out. 
(c) This code does not compile. 
(d) This code results in a     
 runtime error. 
(e) None of these options is 
correct. 
What is the result of executing these 
statements? 
(a) 8 is sent to standard out. 
(b) 10 is sent to standard out. 
(c) This code does not compile. 
(d) This code results in a runtime 
 error. 
(e) None of these options is correct.  
Generic Programming: lots of magic: 
#include <list> 
#include <iostream> 
#include <string> 
using namespace std; 
 
struct animal { 
   string name; 
   string food; 
   bool big; 
   animal(string n="blob", string f="you”, bool b=true):name(n),food(f),big(b) {} 
}; 
 
int main() { 
 
   animal g("giraffe","leaves"), p("penguin","fish”,false), b("bear");  
   list<animal> zoo; 
 
   zoo.push_back(g); zoo.push_back(p); zoo.push_back(b); //STL list insertAtEnd 
 
   for(list<animal>::iterator it = zoo.begin(); it != zoo.end(); it++) 
      cout << (*it).name << " eats " << (*it).food << endl; 
 
return 0; 
} 
Suppose these familiar structures were encapsulated. 
Iterators give us the access we need to traverse them anyway! 
Iterators: 
Objects of type “iterator” promise to have at least the following defined: 
 
operator++ 
operator* 
operator!= 
operator== 
operator= 
 
“Container classes” typically have a variety of iterators defined within: 
 
Forward 
Reverse 
Bidirectional 
http://www.sgi.com/tech/stl/ 
class human { 
public: 
 
 
 
 
    
 
private: 
 
 
 
 
}; 
Iterators: 
pm ++ * 
linked list 
array 
hypercube 
9 
 class Sport{ 
 public: 
     int winner() const; 
 private: 
      int score; 
 }; 
 class VolleyBall: public Sport { 
 public: 
 int loser(); 
}; 
Where could the assignment score=20; appear for the private 
variable score? 
 
(a) Both winner() and loser() can make the assignment. 
(b) loser() can make the assignment, but winner() cannot. 
(c) winner() can make the assignment, but loser() cannot. 
(d) Neither loser() nor winner() can make the assignment. 
(e) The answer to this question cannot be determined from the 
given code. 
10 
 void doub(int x) { x = x * 2;} 
 void trip(int * x) { *x = *x * 3; } 
 void quin(int & x) { x = x * 5; } 
 int main() { 
 
 int x = 1; 
 
 doub(x); 
 trip(&x); 
 quin(x); 
 
 cout << x << endl; 
 
 return 0; 
 } 
What is the result of executing these statements? 
(a) 1 is sent to standard out. 
(b) 5 is sent to standard out. 
(c) 6 is sent to standard out. 
(d) 10 is sent to standard out. 
(e) 15 is sent to standard out. 
Generic programming: (more magic) 
#include <list> 
#include <iostream> 
#include <string> 
using namespace std; 
 
struct animal { 
   string name; 
   string food; 
   bool big; 
   animal(string n="blob", string f="you”, bool b=true):name(n),food(f),big(b) {} 
}; 
 
int main() { 
 
   animal g("giraffe","leaves"), p("penguin","fish”,false), b("bear");  
   list<animal> zoo; 
 
   zoo.push_back(g); zoo.push_back(p); zoo.push_back(b); //STL list insertAtEnd 
 
   for(list<animal>::iterator it = zoo.begin(); it != zoo.end(); it++) 
      cout << (*it).name << "  " << (*it).food << endl; 
 
return 0; 
} 
emplate<class Iter, class Formatter> 
void print(Iter first, Iter second, Formatter printer) { 
   while (!(first==second)) { 
      printer(*first); 
     first++; 
   } 
} 
Generic programming: (more magic) 
#include <list> 
#include <iostream> 
#include <string> 
using namespace std; 
 
struct animal { 
   string name; 
   string food; 
   bool big; 
   animal(string n="blob", string f="you”, bool b=true):name(n),food(f),big(b) {} 
}; 
 
int main() { 
 
   animal g("giraffe","leaves"), p("penguin","fish”,false), b("bear");  
   list<animal> zoo; 
 
   zoo.push_back(g); zoo.push_back(p); zoo.push_back(b); //STL list insertAtEnd 
 
   for(list<animal>::iterator it = zoo.begin(); it != zoo.end(); it++) 
      cout << (*it).name << "  " << (*it).food << endl; 
 
return 0; 
} 
emplate<class Iter, class Formatter> 
void print(Iter first, Iter second, Formatter printer) { 
   while (!(first==second)) { 
      printer(*first); 
     first++; 
   } 
} 
class printIfBig { 
public: 
   void operator()(animal a) { 
      if (a.big) out << a.name << endl; 
   } 
}; 
Generic programming: (more magic) 
#include <list> 
#include <iostream> 
#include <string> 
using namespace std; 
 
struct animal { 
   string name; 
   string food; 
   bool big; 
   animal(string n="blob", string f="you”, bool b=true):name(n),food(f),big(b) {} 
}; 
 
int main() { 
 
   animal g("giraffe","leaves"), p("penguin","fish”,false), b("bear");  
   list<animal> zoo; 
 
   zoo.push_back(g); zoo.push_back(p); zoo.push_back(b); //STL list insertAtEnd 
 
   for(list<animal>::iterator it = zoo.begin(); it != zoo.end(); it++) 
      cout << (*it).name << "  " << (*it).food << endl; 
 
return 0; 
} 
emplate<class Iter, class Formatter> 
void print(Iter first, Iter second, Formatter printer) { 
   while (!(first==second)) { 
      printer(*first); 
     first++; 
   } 
} 
class printIfBig { 
public: 
   void operator()(animal a) { 
      if (a.big) out << a.name << endl; 
   } 
}; 
printIfBig myFun; 
print<list<animal>::iterator,printIfBig>(zoo.begin(),zoo.end(),myFun); 
Suppose these familiar structures were encapsulated. 
Iterators give us the access we need to traverse them anyway! 
And function objects give us the ability to change their data systematically. 
