1 Introducing Nondeterminism
1.1 Informal Overview
Nondeterminism
Michael Rabin and Dana Scott (1959)
Figure 1: Michael Rabin
Figure 2: Dana Scott
Nondeterminism
Given a current state of the machine and input symbol to be read, the next state is not uniquely
determined.
Comparison to DFAs
Nondeterministic Finite Automata (NFA)
NFAs have 3 features when compared with DFAs.
1. Ability to take a step without reading any input symbol
2. A state may have no transition on a particular symbol
3. Ability to transition to more than one state on a given symbol
-Transitions
Transitions without reading input symbols
Example 1. The British spelling of “color” is “colour”. In a web search application, you may want
to recognize both variants.
1
q0 q1 q2 q3 q4 q5 q6
c o l o u

r
Figure 3: NFA with -transitions
No transitions
Example 2.
q0 q1 . . .
1
Figure 4: No 0-transition out of initial state
In the above automaton, if the string starts with a 0 then the string has no computation (i.e.,
rejected).
Multiple Transitions
q q0 q00 qp
0, 1
0 0 1
0, 1
Figure 5: q has two 0-transitions
1.2 Nondeterministic Computation
Parallel Computation View
At each step, the machine “forks” a thread corresponding to one of the possible next states.
• If a state has an -transition, then you fork a new process for each of the possible -transitions,
without reading any input symbol
• If the state has multiple transitions on the current input symbol read, then fork a process for
each possibility
• If from current state of a thread, there is no transition on the current input symbol then the
thread dies
2
Parallel Computation View: An Example
q q0 q00 qp
0, 1
0 0

1
0, 1
Figure 6: Example NFA
q
q0 qq00
qp X q
qp q q0 q00
qp q0
q00
q q00 X
0 0

1 1 1
0 0 0

0 0 0

0 0
Figure 7: Computation on 0100
Nondeterministic Acceptance
Parallel Computation View
Input is accepted if after reading all the symbols, one of the live threads of the automaton is in a
final/accepting state. If none of the live threads are in a final/accepting state, the input is rejected.
q q0 q00 qp
0, 1
0
0

1
0, 1
0100 is accepted because one thread of computation is q
0→ q0 → q00 1→ qp 0→ qp 0→ qp
Computation: Guessing View
3
The machine magically guesses the choices that lead to acceptance
q0 q1 q2 q3 q4 q5 q6
c o l o u

r
Figure 8: NFA Mcolor
After seeing “colo” the automaton guesses if it will see the british or the american spelling. If
it guesses american then it moves without reading the next input symbol.
Observations: Guessing View
• If there is a sequence of choices that will lead to the automaton (not “dying” and) ending up
in an accept state, then those choices will be magically guessed
• On the other hand, if the input will not be accepted then no guess will lead the to automaton
being in an accept state
– On the input “colobr”, whether automaton Mcolor guesses british or american, it will
not proceed when it reads ‘b’.
2 Formal Definitions
2.1 NFAs
Nondeterministic Finite Automata (NFA)
Formal Definition
Definition 3. A nondeterministic finite automaton (NFA) is M = (Q,Σ, δ, q0, F ), where
• Q is the finite set of states
• Σ is the finite alphabet
• δ : Q× (Σ ∪ {})→ P(Q), where P(Q) is the powerset of Q
• q0 ∈ Q initial state
• F ⊆ Q final/accepting states
Example of NFA
4
q q0 q00 qp
0, 1
0 0 1
0, 1
Figure 9: Transition Diagram of NFA
Formally, the NFA is M001 = ({q, q0, q00, qp}, {0, 1}, δ, q, {qp}) where δ is given by
δ(q, 0) = {q, q0} δ(q, 1) = {q} δ(q0, 0) = {q00}
δ(q00, 1) = {qp} δ(qp, 0) = {qp} δ(qp, 1) = {qp}
δ is ∅ in all other cases.
2.2 Nondeterministic Computation
Computation
Definition 4. For an NFA M = (Q,Σ, δ, q0, F ), string w, and states q1, q2 ∈ Q, we say q1 w−→M q2
if there is one thread of computation on input w from state q1 that ends in q2. Formally, q1
w−→M q2
if there is a sequence of states r0, r1, . . . rk and a sequence x1, x2, . . . xk, where for each i, xi ∈ Σ∪{},
such that
• r0 = q1,
• for each i, ri+1 ∈ δ(ri, xi+1),
• rk = q2, and
• w = x1x2x3 · · ·xk
Differences with definition for DFA
• Since δ gives a set of states, for each i, ri+1 is required to be in δ(r1, xi+1), and not equal to
it (as is the case for DFAs)
• Allowing/inserting  in to the input sequence
Example Computation
q q0 q00 qp
0, 1
0
0

1
0, 1
5
q
0100−→M qp because taking r0 = q, r1 = q0, r2 = q00, r3 = qp, r4 = qp, r5 = qp, and x1 = 0,
x2 = , x3 = 1, x4 = 0, x5 = 0, we have
• x1x2 · · ·x5 = 0100 = 0100
• ri+1 ∈ δ(ri, xi+1)
Acceptance/Recognition
Definition 5. For an NFA M = (Q,Σ, δ, q0, F ) and string w ∈ Σ∗, we say M accepts w iff q0 w−→M q
for some q ∈ F .
Definition 6. The language accepted or recognized by NFA M over alphabet Σ is L(M) = {w ∈
Σ∗ |M accepts w}. A language L is said to be accepted/recognized by M if L = L(M).
Useful Notation
Definition 7. For an NFA M = (Q,Σ, δ, q0, F ), string w, and state q ∈ Q, we say δˆM (q, w) to
denote states of all the active threads of computation on input w from q. Formally,
δˆM (q, w) = {q′ ∈ Q | q w−→M q′}
We could say M accepts w iff δˆM (q0, w) ∩ F 6= ∅.
Observation 1
For NFA M , string w and state q1 it could be that
• δˆM (q1, w) = ∅
• δˆM (q1, w) has more than one element
Observation 2
However, the following proposition about DFAs continues to hold for NFAs
For NFA M , strings u and v, and states q1, q2, q1
uv−→M q2 iff there is a state q such
that q1
u−→M q and q v−→M q2
Example
q q0 q00 qp
0, 1
0 0

1
0, 1
Figure 10: Example NFA
6
δˆM (q, 0100) = {qp, q00, q}
q
q0 qq00
qp X q
qp q q0 q00
qp q0
q00
q q00 X
0 0

1 1 1
0 0 0

0 0 0

0 0
Figure 11: Computation on 0100
2.3 Examples
Example I
q0 q1 q2 q3
0, 1
1 0, 1 0, 1
Figure 12: Automaton accepts strings having a 1 three positions from end of input
The automaton “guesses” at some point that the 1 it is seeing is 3 positions from end of input.
Example II
7
AB C
D E
F

 0
00
0
0
Figure 13: NFA accepting strings where the length is either a multiple 2 or 3
The NFA “guesses” at the begining whether it will see a multiple of 2 or 3, and then confirms that
the guess was correct.
Example III
q q0 q00 qp
0, 1
0 0 1
0, 1
Figure 14: NFA accepting strings with 001 as substring
At some point the NFA “guesses” that the pattern 001 is starting and then checks to confirm the
guess.
3 Power of Nondeterminism
3.1 Overview
Using Nondeterminism
When designing an NFA for a language
• You follow the same methodology as for DFAs, like identifying what needs to be remembered
• But now, the machine can “guess” at certain steps
8
3.2 Examples
Back to the Future
Problem
For Σ = {0, 1, 2}, let
L = {w#c | w ∈ Σ∗, c ∈ Σ, and c occurs in w}
So 1011#0 ∈ L but 1011#2 6∈ L. Design an NFA recognizing L.
Solution
• Read symbols of w, i.e., portion of input before # is seen
• Guess at some point that current symbol in w is going to be the same as ‘c’; store this symbol
in the state
• Read the rest of w
• On reading #, check that the symbol immediately after is the one stored, and that the input
ends immediately after that.
qs
q0
q1
q2
q′0
q′1
q′2
qf
0, 1, 2
0, 1, 2
0, 1, 2
0, 1, 2
0
1
2
#
#
#
0
1
2
Figure 15: L(M) = {w#c | c occurs in w}
Pattern Recognition
Problem
For alphabet Σ and u ∈ Σ∗, let
Lu = {w ∈ Σ∗ | ∃v1, v2 ∈ Σ∗. w = v1uv2}
That is, Lu is all strings that have u as a substring.
Solution
9
• Read symbols of w
• Guess at some point that the string u is going to be seen
• Check that u is indeed read
• After reading u, read the rest of w
To do this, the automaton will remember in its state what prefix of u it has seen so far; the initial
state will assume that it has not seen any of u, and the final state is one where all the symbols of
u have been observed.
Formally, we can define this automaton as follows. Let u = a1a2 · · · an. The NFA M =
(Q,Σ, δ, q0, F ) where
• Q = {, a1, a2a2, a1a2a3, . . . , a1a2 · · · an = u}. Thus, every prefix of u is a state of NFA M .
• q0 = ,
• F = {u},
• And δ is given as follows
δ(q, a) =

{} if q = , a 6= a1
{, a1} if q = , a = a1
{a1a2 · · · ai+1} if q = a1 · · · ai (1 ≤ i < n), a = ai+1
{u} if q = u
∅ otherwise
See Example III above for a concrete case.
1 k-positions from the end
Problem
For alphabet Σ = {0, 1},
Lk = {w ∈ Σ∗ | ∃v1, v2 ∈ Σ∗. w = v11v2 and |v2| = k − 1}
That is, Lk is all strings that have a 1 k positions from the end.
Solution
• Read symbols of w
• Guess at some point that there are only going to be k more symbols in the input
• Check that the first symbol after this point is a 1, and that we see k − 1 symbols after that
• Halt and accept no more input symbols
10
The states need to remember that how far we are from the end of the input; either very far (initial
state), or less that k symbols from end.
Formally, M = (Q,Σ, δ, q0, F ) where
• Q = {qi | 0 ≤ i ≤ k}. The subscript of the state counts how far we are from the end of the
input; q0 means that there can be many symbols left before the end, and qi (i > 1) means
there are k − i symbols left to read.
• q0 = q0
• F = {qk},
• And δ is given as follows
δ(q, a) =

{q0} if q = q0, a = 0
{q0, q1} if q = q0, a = 1
{qi+1} if q = qi(1 ≤ i < k)
∅ otherwise
See Example I above for a concrete case.
Observe that this automaton has only k + 1 states, whereas we proved in lecture 3 that any
DFA recognizing this language must have size at least 2k. Thus, NFAs can be exponentially smaller
than DFAs.
Proposition 8. There is a family of languages Lk (for k ∈ N) such that the smallest DFA recog-
nizing Lk has at least 2
k states, whereas there is an NFA with only O(k) recognizing Lk.
Proof. Follows from the observations above.
Halving a Language
Definition 9. For a language L, define 12L as follows.
1
2
L = {x | ∃y. |x| = |y| and xy ∈ L}
In other words, 12L consists of the first halves of strings in L
Example 10. If L = {001, 0000, 01, 110010} then 12L = {00, 0, 110}.
Recognizing Halves of Regular Languages
Proposition 11. If L is recognized by a DFA M then there is a NFA N such that L(N) = 12L.
Proof Idea
On input x, need to check if x is the first half of some string w = xy that is accepted by M .
11
• “Run” M on input x; let M be in state qi after reading all of x
• Guess a string y such that |y| = |x|
• Check if M reaches a final state on reading y from qi
How do you guess a string y of equal length to x using finite memory? Seems to require remembering
the length of x!
Fixing the Idea
Problem and Fix(?)
• How do you guess a string y of equal length to x using finite memory? Guess one symbol of
y as you read one symbol of x!
• How do you “run” M on y from qi, if you cannot store all the symbols of y? Run M on y as
you guess each symbol, without waiting to finish the execution on x!
• If we don’t first execute M on x, how do we know the state qi from which we have to execute
y from? Guess it! And then check that running M on x does indeed end in qi, your guessed
state.
New Algorithm
On input x, NFA N
1. Guess state qi and place “left finger” on (initial state of M) q0 and “right finger” on qi
2. As characters of x are read, N moves the left finger along transitions dictated by x and
simultaneously moves the right finger along nondeterministically chosen transitions labelled
by some symbol
3. Accept if after reading x, left finger is at qi (state initially guessed for right finger) and right
finger is at an accepting state
Things to remember: initial guess for right finger, and positions of left and right finger.
Algorithm on Example
12
q0 q1 q2
q3
0
1
1
0 1
1
0
0
Figure 16: DFA M
100010 ∈ L and so x = 100 ∈ 12L
NFA N execution on x = 100 is
String Read Left Finger Right Finger
 q0  q21 q1 q2
10 q3
=?
q1
100 q2

q3
↑
accept?
Formal Construction of NFA N
States and Initial State
Given M = (Q,Σ, δ, q0, F ) recognizing L define N = (Q
′,Σ, δ′, q′0, F ′) that recognizes
1
2L
• Q′ = Q×Q×Q ∪ {s}, where s 6∈ Q
– s is a new start state
– Other states are of the form 〈left finger, initial guess, right finger〉; “initial guess” records
the initial guess for the right finger
• q′0 = s
• Transitions
δ′(s, ) = {〈q0, qi, qi〉 | qi ∈ Q}
“Guess” the state qi that the input will lead to
δ′(〈qi, qj , qk〉, a) = {〈ql, qj , qm〉 | δ(qi, a) = ql,
∃b ∈ Σ. δ(qk, b) = qm}
b is the guess for the next symbol of y and initial guess
does not change
• F ′ = {〈qi, qi, qj〉 | qi ∈ Q, qj ∈ F}
13
