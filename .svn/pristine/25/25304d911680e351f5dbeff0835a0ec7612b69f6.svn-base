1 Three Simplifications
Motivation for Grammar Simplification
Parsing Problem
Given a CFG G and string w, determine if w ∈ L(G).
• Fundamental problem in compiler design and natural language processing.
If G is in general form then the procedure maybe very inefficient. So the grammar is “transformed”
into a simpler form to make the parsing problem easier.
1.1 Eliminating -productions
Eliminating -productions
• Often would like to ensure that the length of the intermediate strings in a derivation are not
longer than the final string derived
• But a long intermediate string can lead to a short final string if there are -productions (rules
of the form A→ ).
• Can we rewrite the grammar not to have -productions?
Eliminating -production
The Problem
Given a grammar G produce an equivalent grammar G′ (i.e., L(G) = L(G′)) such that G′ has no
rules of the form A → , except possibly S → , and S does not appear on the right hand side of
any rule.
Note: If S can appear on the RHS of a rule, say S → SS, then when there is the rule S → ,
we can again have long intermediate strings yielding short final strings.
We will first introduce a concept that will be useful in this transformation.
Nullable Variables
Definition 1. A variable A (of grammar G) is nullable if A
∗⇒ .
How do you determine if a variable is nullable?
• If A→  is a production in G then A is nullable
• If A→ B1B2 · · ·Bk is a production and each Bi is nullable, then A is nullable.
• Repeat the above steps until no new nullable variables can be found.
1
Using nullable variables
Intuition
For every variable A in G have a variable A in G′ such that A ∗⇒G′ w iff A ∗⇒G w and w 6= .
For every rule B → CAD in G, where A is nullable, add two rules in G′: B → CD and
B → CAD.
The Algorithm
• If G = (V,Σ, R, S) then G′ = (V ∪ {S′},Σ, R′, S′) where S′ 6∈ V .
• And the set R′ will be defined as follows. For each rule A → X1X2 · · ·Xk in G, create rules
A→ α1α2 · · ·αk where
αi =
{
Xi if Xi is a non-nullable variable/terminal in G
Xi or  if Xi is nullable in G
and not all αi are 
• Add rule S′ → S. If S nullable in G, add S′ →  also.
Correctness of the Algorithm
Leftmost Derivations
Before proving the correctness, we will introduce the notion of a leftmost derivation. A derivation
A
∗⇒ w is a leftmost derivation if every step of the derivation is obtained by applying a rule to the
leftmost variable; we will denote this by A
∗⇒lm w.
Example 2. Let G = ({S,A,B}, {a, b}, {S → AB, A → aA | a, B → bB | b}, S). The derivation
S ⇒ AB ⇒ aB ⇒ ab is a leftmost derivation. However, S ⇒ AB ⇒ Ab ⇒ ab is not a leftmost
derivation.
A few properties of leftmost derivations are useful to observe.
• Our proof constructing a derivation corresponding to a parse tree constructed a leftmost
derivation.
• Therefore, A ∗⇒ w iff A ∗⇒lm w.
• A grammar G = (V,Σ, R, S) is ambiguous iff there is w ∈ Σ∗ such that w has two (different)
parse trees with root S and yield w iff there is w ∈ Σ∗ such that there are two (different)
leftmost derivation of w from S.
• For w ∈ Σ∗, a leftmost derivation A ∗⇒lm w has the form
A⇒ X1X2 · · ·Xk ∗⇒lm w1X2 · · ·Xk ∗⇒lm w1w2X3 · · ·Xk · · · ∗⇒lm w1w2 · · ·wk = w
2
where wi ∈ Σ∗, and wi = Xi if Xi ∈ Σ. That is, the derivation applies a rule to A, and then
applies a sequence of steps to the leftmost symbol until we get a string of terminals (and no
steps if the leftmost symbol is not a variable), and then sequence of steps the second symbol,
and so on. Thus, here we have Xi
∗⇒lm wi.
We are now ready to prove the correctness of the algorithm eliminating -rules.
Proof. • By construction, there are no rules of the form A→  in G′ (except possibly S′ → ),
and S′ does not appear in the RHS of any rule.
• L(G) = L(G′)
– L(G′) ⊆ L(G): For every rule A → w in G′, we have A ∗⇒G w (by expanding zero or
more nullable variables in w to )
– L(G) ⊆ L(G′): If  ∈ L(G), then  ∈ L(G′). For w 6= , we will prove by induction a
stronger statement. We will show that for every w ∈ Σ∗ (w 6= ), and every variable
A, if A
∗⇒Glm w then A ∗⇒
G′
lm w by induction on the number of steps in the derivation
A
∗⇒Glm w.
∗ Base Case: If A ∗⇒Glm w in one step, then A→ w is rule in G. Since w 6= , A→ w
is also a rule in G′, and so A ∗⇒G
′
lm w.
∗ Ind. Step: Consider A ∗⇒Glm w. Then by the property of leftmost derivations,
A
∗⇒Glm w is of the form
A⇒ X1X2 · · ·Xk ∗⇒lm w1X2 · · ·Xk ∗⇒lm w1w2X3 · · ·Xk · · · ∗⇒lm w1w2 · · ·wk = w
where Xi
∗⇒Glm wi. Now if wi 6= , then by induction hypothesis we have Xi ∗⇒
G′
lm wi.
Thus, if i1, . . . in are the indices such that wi 6= , then we have A⇒G′ Xi1Xi2 · · ·Xin
(as the other veriables are nullable, Xij
∗⇒G
′
lm wij by induction hypothesis, and
w = wi1 · · ·win (as the other wjs are ). Putting it all together we have
A⇒G′ Xi1 · · ·Xin ∗⇒
G′
lm wi1Xi2 · · ·Xin ∗⇒
G′
lm · · · ∗⇒
G′
lm wi1wi2 · · ·win = w
Eliminating -productions
An Example
Example 3. Let G = ({S,A,B}, {a, b}, R, S) where R is given by: S → AB; A → AaA|; and
B → BbB|.
• Nullables in G are A,B and S
• G′ will have variables {S′, S,A,B} and rules:
– S → AB|A|B
3
– A→ AaA|aA|Aa|a
– B → BbB|bB|Bb|b
– S′ → S|
1.2 Eliminating Unit Productions
Eliminating Unit Productions
• Often would like to ensure that the number of steps in a derivation are not much more than
the length of the string derived
• But can have a long chain of derivation steps that make little or no “progress,” if the grammar
has unit productions (rules of the form A→ B, where B is a non-terminal).
– Note: A→ a is not a unit production
• Can we rewrite the grammar not to have unit-productions?
Eliminating unit-productions
Given a grammar G produce an equivalent grammar G′ (i.e., L(G) = L(G′)) such that G′ has no
rules of the form A→ B where B ∈ V ′.
Role of Unit Productions
Unit productions can play an important role in designing grammars:
• While eliminating -productions we added a rule S′ → S. This is a unit production.
• We have used unit productions in building an unambiguous grammar:
I → a | b | Ia | Ib T → F | T ∗ F
N → 0 | 1 |N0 |N1 E → T | E + T
F → I |N | −N | (E)
But as we shall see now, they can be (safely) eliminated
Eliminating Unit Productions
Basic Idea
Introduce new “look-ahead” productions to replace unit productions: look ahead to see where the
unit production (or a chain of unit productions) leads to and add a rule to directly go there.
Example 4. E → T → F → I → a|b|Ia|Ib. So introduce new rules E → a|b|Ia|Ib
4
But what if the grammar has cycles of unit productions? For example, A→ B|a, B → C|b and
C → A|c. You cannot use the “look-ahead” approach, because then you will get into an infinite
loop.
The Algorithm
1. Determine pairs 〈A,B〉 such that A ∗⇒u B, i.e., A derives B using only unit rules. Such pairs
are called unit pairs.
• Easy to determine unit pairs: Make a directed graph with vertices = V , and edges =
unit productions. 〈A,B〉 is a unit pair, if there is a directed path from A to B in the
graph.
• Note, it is possible to A ∗⇒ B without using unit productions. Example, A → BC and
C → .
2. If 〈A,B〉 is a unit pair, then add production rules A→ β1|β2| · · ·βk, where B → β1|β2| · · · |βk
are all the non-unit production rules of B
3. Remove all unit production rules.
Proposition 5. Let G′ be the grammar obtained from G using this algorithm to eliminate unit
productions. Then L(G′) = L(G)
Proof. L(G′) ⊆ L(G): For every rule A → w in G′, we have A ∗⇒G w (by a sequence of zero or
more unit productions followed by a nonunit production of G)
L(G) ⊆ L(G′): For w ∈ L(G) consider a leftmost derivation S ∗⇒lm w in G.
• All these derivation steps are possible in G′ also, except the ones using the unit productions
of G.
• Suppose S ∗⇒ xAα⇒1 xBα⇒2 · · · , where⇒1 corresponds to a unit rule. Then (in a leftmost
derivation) ⇒2 must correspond to using a rule for B.
• So a leftmost derivation of w in G can be broken up into “big-steps” each consisting of zero
or more unit productions on the leftmost variable, followed by a non-unit production.
• For each such “big-step” there is a single production rule in G′ that yields the same result.
1.3 Eliminating Useless Symbols
Eliminating Useless Symbols
• Ideally one would like to use a compact grammar, with the fewest possible variables
• But a grammar may have “useless” variables which do not appear in any valid derivation
• Can we identify all the useless variables and remove them from the grammar? (Note: there
may still be other redundancies in the grammar.)
5
Useless Symbols
Definition 6. A symbol X ∈ V ∪Σ is useless in a grammar G = (V,Σ, S, P ) if there is no derivation
of the form S
∗⇒ αXβ ∗⇒ w where w ∈ Σ∗ and α, β ∈ (V ∪ Σ)∗.
Removing useless symbols (and rules involving them) from a grammar does not change the
language of the grammar.
We can say X is useless iff either
Type 1: X is not “reachable” from S (i.e., no α, β such that S
∗⇒ αXβ), or
Type 2: for all α, β such that S
∗⇒ αXβ, either α, X or β cannot yield a string in Σ∗. i.e., either
Type 2a: X is not “generating” (i.e., no w ∈ Σ∗ such that X ∗⇒ w), or
Type 2b: α or β contains a non-generating symbol
Algorithm to Remove Useless Symbols
Algorithm
So, in order to remove useless symbols,
1. First remove all symbols that are not generating (Type 2a)
• If X was useless, but reachable and generating (i.e., Type 2b) then X becomes unreach-
able after this step
– Type 2b: for all α, β such that S
∗⇒ αXβ, α or β contains a non-generating symbol.
Then in the new grammar all such derivations disappear (because some variable in
α or β is removed).
2. Next remove all unreachable symbols in the new grammar.
• Removes Type 1 (originally unreachable) and Type 2b useless symbols now
Doesn’t remove any useful symbol in either step (Why?)
Only remains to show how to do the two steps in this algorithm
Generating and Reachable Symbols
Generating symbols
• If A→ x, where x ∈ Σ∗, is a production then A is generating
• If A→ γ is a production and all variables in γ are generating, then A is generating.
Reachable symbols
• S is reachable
• If A is reachable and A→ αBβ is a production, then B is reachable
6
1.4 Putting Together the Three Simplifications
The Three Simplifications, Together
Proposition 7. Given a grammar G, such that L(G) 6= ∅, we can find a grammar G′ such that
L(G′) = L(G) and G′ has no -productions (except possibly S → ), unit productions, or useless
symbols, and S does not appear in the RHS of any rule.
Proof. Apply the following 3 steps in order:
1. Eliminate -productions
2. Eliminate unit productions
3. Eliminate useless symbols.
Note: Applying the steps in a different order may result in a grammar not having all the desired
properties.
7
