1 Three Simplifications
Motivation for Grammar Simplification
Parsing Problem
Given a CFG G and string w, determine if w âˆˆ L(G).
â€¢ Fundamental problem in compiler design and natural language processing.
If G is in general form then the procedure maybe very inefficient. So the grammar is â€œtransformedâ€
into a simpler form to make the parsing problem easier.
1.1 Eliminating -productions
Eliminating -productions
â€¢ Often would like to ensure that the length of the intermediate strings in a derivation are not
longer than the final string derived
â€¢ But a long intermediate string can lead to a short final string if there are -productions (rules
of the form Aâ†’ ).
â€¢ Can we rewrite the grammar not to have -productions?
Eliminating -production
The Problem
Given a grammar G produce an equivalent grammar Gâ€² (i.e., L(G) = L(Gâ€²)) such that Gâ€² has no
rules of the form A â†’ , except possibly S â†’ , and S does not appear on the right hand side of
any rule.
Note: If S can appear on the RHS of a rule, say S â†’ SS, then when there is the rule S â†’ ,
we can again have long intermediate strings yielding short final strings.
We will first introduce a concept that will be useful in this transformation.
Nullable Variables
Definition 1. A variable A (of grammar G) is nullable if A
âˆ—â‡’ .
How do you determine if a variable is nullable?
â€¢ If Aâ†’  is a production in G then A is nullable
â€¢ If Aâ†’ B1B2 Â· Â· Â·Bk is a production and each Bi is nullable, then A is nullable.
â€¢ Repeat the above steps until no new nullable variables can be found.
1
Using nullable variables
Intuition
For every variable A in G have a variable A in Gâ€² such that A âˆ—â‡’Gâ€² w iff A âˆ—â‡’G w and w 6= .
For every rule B â†’ CAD in G, where A is nullable, add two rules in Gâ€²: B â†’ CD and
B â†’ CAD.
The Algorithm
â€¢ If G = (V,Î£, R, S) then Gâ€² = (V âˆª {Sâ€²},Î£, Râ€², Sâ€²) where Sâ€² 6âˆˆ V .
â€¢ And the set Râ€² will be defined as follows. For each rule A â†’ X1X2 Â· Â· Â·Xk in G, create rules
Aâ†’ Î±1Î±2 Â· Â· Â·Î±k where
Î±i =
{
Xi if Xi is a non-nullable variable/terminal in G
Xi or  if Xi is nullable in G
and not all Î±i are 
â€¢ Add rule Sâ€² â†’ S. If S nullable in G, add Sâ€² â†’  also.
Correctness of the Algorithm
Leftmost Derivations
Before proving the correctness, we will introduce the notion of a leftmost derivation. A derivation
A
âˆ—â‡’ w is a leftmost derivation if every step of the derivation is obtained by applying a rule to the
leftmost variable; we will denote this by A
âˆ—â‡’lm w.
Example 2. Let G = ({S,A,B}, {a, b}, {S â†’ AB, A â†’ aA | a, B â†’ bB | b}, S). The derivation
S â‡’ AB â‡’ aB â‡’ ab is a leftmost derivation. However, S â‡’ AB â‡’ Ab â‡’ ab is not a leftmost
derivation.
A few properties of leftmost derivations are useful to observe.
â€¢ Our proof constructing a derivation corresponding to a parse tree constructed a leftmost
derivation.
â€¢ Therefore, A âˆ—â‡’ w iff A âˆ—â‡’lm w.
â€¢ A grammar G = (V,Î£, R, S) is ambiguous iff there is w âˆˆ Î£âˆ— such that w has two (different)
parse trees with root S and yield w iff there is w âˆˆ Î£âˆ— such that there are two (different)
leftmost derivation of w from S.
â€¢ For w âˆˆ Î£âˆ—, a leftmost derivation A âˆ—â‡’lm w has the form
Aâ‡’ X1X2 Â· Â· Â·Xk âˆ—â‡’lm w1X2 Â· Â· Â·Xk âˆ—â‡’lm w1w2X3 Â· Â· Â·Xk Â· Â· Â· âˆ—â‡’lm w1w2 Â· Â· Â·wk = w
2
where wi âˆˆ Î£âˆ—, and wi = Xi if Xi âˆˆ Î£. That is, the derivation applies a rule to A, and then
applies a sequence of steps to the leftmost symbol until we get a string of terminals (and no
steps if the leftmost symbol is not a variable), and then sequence of steps the second symbol,
and so on. Thus, here we have Xi
âˆ—â‡’lm wi.
We are now ready to prove the correctness of the algorithm eliminating -rules.
Proof. â€¢ By construction, there are no rules of the form Aâ†’  in Gâ€² (except possibly Sâ€² â†’ ),
and Sâ€² does not appear in the RHS of any rule.
â€¢ L(G) = L(Gâ€²)
â€“ L(Gâ€²) âŠ† L(G): For every rule A â†’ w in Gâ€², we have A âˆ—â‡’G w (by expanding zero or
more nullable variables in w to )
â€“ L(G) âŠ† L(Gâ€²): If  âˆˆ L(G), then  âˆˆ L(Gâ€²). For w 6= , we will prove by induction a
stronger statement. We will show that for every w âˆˆ Î£âˆ— (w 6= ), and every variable
A, if A
âˆ—â‡’Glm w then A âˆ—â‡’
Gâ€²
lm w by induction on the number of steps in the derivation
A
âˆ—â‡’Glm w.
âˆ— Base Case: If A âˆ—â‡’Glm w in one step, then Aâ†’ w is rule in G. Since w 6= , Aâ†’ w
is also a rule in Gâ€², and so A âˆ—â‡’G
â€²
lm w.
âˆ— Ind. Step: Consider A âˆ—â‡’Glm w. Then by the property of leftmost derivations,
A
âˆ—â‡’Glm w is of the form
Aâ‡’ X1X2 Â· Â· Â·Xk âˆ—â‡’lm w1X2 Â· Â· Â·Xk âˆ—â‡’lm w1w2X3 Â· Â· Â·Xk Â· Â· Â· âˆ—â‡’lm w1w2 Â· Â· Â·wk = w
where Xi
âˆ—â‡’Glm wi. Now if wi 6= , then by induction hypothesis we have Xi âˆ—â‡’
Gâ€²
lm wi.
Thus, if i1, . . . in are the indices such that wi 6= , then we have Aâ‡’Gâ€² Xi1Xi2 Â· Â· Â·Xin
(as the other veriables are nullable, Xij
âˆ—â‡’G
â€²
lm wij by induction hypothesis, and
w = wi1 Â· Â· Â·win (as the other wjs are ). Putting it all together we have
Aâ‡’Gâ€² Xi1 Â· Â· Â·Xin âˆ—â‡’
Gâ€²
lm wi1Xi2 Â· Â· Â·Xin âˆ—â‡’
Gâ€²
lm Â· Â· Â· âˆ—â‡’
Gâ€²
lm wi1wi2 Â· Â· Â·win = w
Eliminating -productions
An Example
Example 3. Let G = ({S,A,B}, {a, b}, R, S) where R is given by: S â†’ AB; A â†’ AaA|; and
B â†’ BbB|.
â€¢ Nullables in G are A,B and S
â€¢ Gâ€² will have variables {Sâ€², S,A,B} and rules:
â€“ S â†’ AB|A|B
3
â€“ Aâ†’ AaA|aA|Aa|a
â€“ B â†’ BbB|bB|Bb|b
â€“ Sâ€² â†’ S|
1.2 Eliminating Unit Productions
Eliminating Unit Productions
â€¢ Often would like to ensure that the number of steps in a derivation are not much more than
the length of the string derived
â€¢ But can have a long chain of derivation steps that make little or no â€œprogress,â€ if the grammar
has unit productions (rules of the form Aâ†’ B, where B is a non-terminal).
â€“ Note: Aâ†’ a is not a unit production
â€¢ Can we rewrite the grammar not to have unit-productions?
Eliminating unit-productions
Given a grammar G produce an equivalent grammar Gâ€² (i.e., L(G) = L(Gâ€²)) such that Gâ€² has no
rules of the form Aâ†’ B where B âˆˆ V â€².
Role of Unit Productions
Unit productions can play an important role in designing grammars:
â€¢ While eliminating -productions we added a rule Sâ€² â†’ S. This is a unit production.
â€¢ We have used unit productions in building an unambiguous grammar:
I â†’ a | b | Ia | Ib T â†’ F | T âˆ— F
N â†’ 0 | 1 |N0 |N1 E â†’ T | E + T
F â†’ I |N | âˆ’N | (E)
But as we shall see now, they can be (safely) eliminated
Eliminating Unit Productions
Basic Idea
Introduce new â€œlook-aheadâ€ productions to replace unit productions: look ahead to see where the
unit production (or a chain of unit productions) leads to and add a rule to directly go there.
Example 4. E â†’ T â†’ F â†’ I â†’ a|b|Ia|Ib. So introduce new rules E â†’ a|b|Ia|Ib
4
But what if the grammar has cycles of unit productions? For example, Aâ†’ B|a, B â†’ C|b and
C â†’ A|c. You cannot use the â€œlook-aheadâ€ approach, because then you will get into an infinite
loop.
The Algorithm
1. Determine pairs ã€ˆA,Bã€‰ such that A âˆ—â‡’u B, i.e., A derives B using only unit rules. Such pairs
are called unit pairs.
â€¢ Easy to determine unit pairs: Make a directed graph with vertices = V , and edges =
unit productions. ã€ˆA,Bã€‰ is a unit pair, if there is a directed path from A to B in the
graph.
â€¢ Note, it is possible to A âˆ—â‡’ B without using unit productions. Example, A â†’ BC and
C â†’ .
2. If ã€ˆA,Bã€‰ is a unit pair, then add production rules Aâ†’ Î²1|Î²2| Â· Â· Â·Î²k, where B â†’ Î²1|Î²2| Â· Â· Â· |Î²k
are all the non-unit production rules of B
3. Remove all unit production rules.
Proposition 5. Let Gâ€² be the grammar obtained from G using this algorithm to eliminate unit
productions. Then L(Gâ€²) = L(G)
Proof. L(Gâ€²) âŠ† L(G): For every rule A â†’ w in Gâ€², we have A âˆ—â‡’G w (by a sequence of zero or
more unit productions followed by a nonunit production of G)
L(G) âŠ† L(Gâ€²): For w âˆˆ L(G) consider a leftmost derivation S âˆ—â‡’lm w in G.
â€¢ All these derivation steps are possible in Gâ€² also, except the ones using the unit productions
of G.
â€¢ Suppose S âˆ—â‡’ xAÎ±â‡’1 xBÎ±â‡’2 Â· Â· Â· , whereâ‡’1 corresponds to a unit rule. Then (in a leftmost
derivation) â‡’2 must correspond to using a rule for B.
â€¢ So a leftmost derivation of w in G can be broken up into â€œbig-stepsâ€ each consisting of zero
or more unit productions on the leftmost variable, followed by a non-unit production.
â€¢ For each such â€œbig-stepâ€ there is a single production rule in Gâ€² that yields the same result.
1.3 Eliminating Useless Symbols
Eliminating Useless Symbols
â€¢ Ideally one would like to use a compact grammar, with the fewest possible variables
â€¢ But a grammar may have â€œuselessâ€ variables which do not appear in any valid derivation
â€¢ Can we identify all the useless variables and remove them from the grammar? (Note: there
may still be other redundancies in the grammar.)
5
Useless Symbols
Definition 6. A symbol X âˆˆ V âˆªÎ£ is useless in a grammar G = (V,Î£, S, P ) if there is no derivation
of the form S
âˆ—â‡’ Î±XÎ² âˆ—â‡’ w where w âˆˆ Î£âˆ— and Î±, Î² âˆˆ (V âˆª Î£)âˆ—.
Removing useless symbols (and rules involving them) from a grammar does not change the
language of the grammar.
We can say X is useless iff either
Type 1: X is not â€œreachableâ€ from S (i.e., no Î±, Î² such that S
âˆ—â‡’ Î±XÎ²), or
Type 2: for all Î±, Î² such that S
âˆ—â‡’ Î±XÎ², either Î±, X or Î² cannot yield a string in Î£âˆ—. i.e., either
Type 2a: X is not â€œgeneratingâ€ (i.e., no w âˆˆ Î£âˆ— such that X âˆ—â‡’ w), or
Type 2b: Î± or Î² contains a non-generating symbol
Algorithm to Remove Useless Symbols
Algorithm
So, in order to remove useless symbols,
1. First remove all symbols that are not generating (Type 2a)
â€¢ If X was useless, but reachable and generating (i.e., Type 2b) then X becomes unreach-
able after this step
â€“ Type 2b: for all Î±, Î² such that S
âˆ—â‡’ Î±XÎ², Î± or Î² contains a non-generating symbol.
Then in the new grammar all such derivations disappear (because some variable in
Î± or Î² is removed).
2. Next remove all unreachable symbols in the new grammar.
â€¢ Removes Type 1 (originally unreachable) and Type 2b useless symbols now
Doesnâ€™t remove any useful symbol in either step (Why?)
Only remains to show how to do the two steps in this algorithm
Generating and Reachable Symbols
Generating symbols
â€¢ If Aâ†’ x, where x âˆˆ Î£âˆ—, is a production then A is generating
â€¢ If Aâ†’ Î³ is a production and all variables in Î³ are generating, then A is generating.
Reachable symbols
â€¢ S is reachable
â€¢ If A is reachable and Aâ†’ Î±BÎ² is a production, then B is reachable
6
1.4 Putting Together the Three Simplifications
The Three Simplifications, Together
Proposition 7. Given a grammar G, such that L(G) 6= âˆ…, we can find a grammar Gâ€² such that
L(Gâ€²) = L(G) and Gâ€² has no -productions (except possibly S â†’ ), unit productions, or useless
symbols, and S does not appear in the RHS of any rule.
Proof. Apply the following 3 steps in order:
1. Eliminate -productions
2. Eliminate unit productions
3. Eliminate useless symbols.
Note: Applying the steps in a different order may result in a grammar not having all the desired
properties.
7
