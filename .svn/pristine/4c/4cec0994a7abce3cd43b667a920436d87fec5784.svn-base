1 Closure Properties
Closure Properties
â€¢ Recall that we can carry out operations on one or more languages to obtain a new language
â€¢ Very useful in studying the properties of one language by relating it to other (better under-
stood) languages
â€¢ Most useful when the operations are sophisticated, yet are guaranteed to preserve interesting
properties of the language.
â€¢ Today: A variety of operations which preserve regularity
â€“ i.e., the universe of regular languages is closed under these operations
Definition 1. Regular Languages are closed under an operation op on languages if
L1, L2, . . . Ln regular =â‡’ L = op(L1, L2, . . . Ln) is regular
1.1 Boolean Operators
Operations from Regular Expressions
Proposition 2. Regular Languages are closed under âˆª, â—¦ and âˆ—.
Proof. (Summarizing previous arguments.)
â€¢ L1, L2 regular =â‡’ âˆƒ regexes R1, R2 s.t. L1 = L(R1) and L2 = L(R2).
â€“ =â‡’ L1 âˆª L2 = L(R1 âˆªR2) =â‡’ L1 âˆª L2 regular.
â€“ =â‡’ L1 â—¦ L2 = L(R1 â—¦R2) =â‡’ L1 â—¦ L2 regular.
â€“ =â‡’ Lâˆ—1 = L(Râˆ—1) =â‡’ Lâˆ—1 regular.
Closure Under Complementation
Proposition 3. Regular Languages are closed under complementation, i.e., if L is regular then
L = Î£âˆ— \ L is also regular.
Proof. â€¢ If L is regular, then there is a DFA M = (Q,Î£, Î´, q0, F ) such that L = L(M).
â€¢ Then, M = (Q,Î£, Î´, q0, Q \ F ) (i.e., switch accept and non-accept states) accepts L.
What happens if M (above) was an NFA?
Closure under âˆ©
1
Proposition 4. Regular Languages are closed under intersection, i.e., if L1 and L2 are regular
then L1 âˆ© L2 is also regular.
Proof. Observe that L1 âˆ© L2 = L1 âˆª L2. Since regular languages are closed under union and
complementation, we have
â€¢ L1 and L2 are regular
â€¢ L1 âˆª L2 is regular
â€¢ Hence, L1 âˆ© L2 = L1 âˆª L2 is regular.
Is there a direct proof for intersection (yielding a smaller DFA)?
Cross-Product Construction
Let M1 = (Q1,Î£, Î´1, q1, F1) and M2 = (Q2,Î£, Î´2, q2, F2) be DFAs recognizing L1 and L2, respec-
tively.
Idea: Run M1 and M2 in parallel on the same input and accept if both M1 and M2 accept.
Consider M = (Q,Î£, Î´, q0, F ) defined as follows
â€¢ Q = Q1 Ã—Q2
â€¢ q0 = ã€ˆq1, q2ã€‰
â€¢ Î´(ã€ˆp1, p2ã€‰, a) = ã€ˆÎ´1(p1, a), Î´2(p2, a)ã€‰
â€¢ F = F1 Ã— F2
M accepts L1 âˆ© L2 (exercise)
What happens if M1 and M2 where NFAs? Still works! Set Î´(ã€ˆp1, p2ã€‰, a) = Î´1(p1, a)Ã—Î´2(p2, a).
An Example
q00
q01
0 0
1
1
Ã— =q10 q11
1
1
0 0 q00 q01
q10 q11
1
1
1
1
0 0 0 0
2
1.2 Homomorphisms
Homomorphism
Definition 5. A homomorphism is function h : Î£âˆ— â†’ âˆ†âˆ— defined as follows:
â€¢ h() =  and for a âˆˆ Î£, h(a) is any string in âˆ†âˆ—
â€¢ For a = a1a2 . . . an âˆˆ Î£âˆ— (n â‰¥ 2), h(a) = h(a1)h(a2) . . . h(an).
â€¢ A homomorphism h maps a string a âˆˆ Î£âˆ— to a string in âˆ†âˆ— by mapping each character of a
to a string h(a) âˆˆ âˆ†âˆ—
â€¢ A homomorphism is a function from strings to strings that â€œrespectsâ€ concatenation: for any
x, y âˆˆ Î£âˆ—, h(xy) = h(x)h(y). (Any such function is a homomorphism.)
Example 6. h : {0, 1} â†’ {a, b}âˆ— where h(0) = ab and h(1) = ba. Then h(0011) = ababbaba
Homomorphism as an Operation on Languages
Definition 7. Given a homomorphism h : Î£âˆ— â†’ âˆ†âˆ— and a language L âŠ† Î£âˆ—, define h(L) =
{h(w) | w âˆˆ L} âŠ† âˆ†âˆ—.
Example 8. Let L = {0n1n |n â‰¥ 0} and h(0) = ab and h(1) = ba. Then h(L) = {(ab)n(ba)n |n â‰¥ 0}
Proposition 9. For any languages L1 and L2, the following hold: h(L1 âˆª L2) = h(L1) âˆª h(L2);
h(L1 â—¦ L2) = h(L1) â—¦ h(L2); and h(Lâˆ—1) = h(L1)âˆ—.
Proof. Left as exercise.
Closure under Homomorphism
Proposition 10. Regular languages are closed under homomorphism, i.e., if L is a regular language
and h is a homomorphism, then h(L) is also regular.
Proof. We will use the representation of regular languages in terms of regular expressions to argue
this.
â€¢ Define homomorphism as an operation on regular expressions
â€¢ Show that L(h(R)) = h(L(R))
â€¢ Let R be such that L = L(R). Let Râ€² = h(R). Then h(L) = L(Râ€²).
Homomorphism as an Operation on Regular Expressions
3
Definition 11. For a regular expression R, let h(R) be the regular expression obtained by replacing
each occurence of a âˆˆ Î£ in R by the string h(a).
Example 12. If R = (0âˆª1)âˆ—001(0âˆª1)âˆ— and h(0) = ab and h(1) = bc then h(R) = (abâˆªbc)âˆ—ababbc(abâˆª
bc)âˆ—
Formally h(R) is defined inductively as follows.
h(âˆ…) = âˆ… h(R1R2) = h(R1)h(R2)
h() =  h(R1 âˆªR2) = h(R2) âˆª h(R2)
h(a) = h(a) h(Râˆ—) = (h(R))âˆ—
Proof of Claim
Claim
For any regular expression R, L(h(R)) = h(L(R)).
Proof. By induction on the number of operations in R
â€¢ Base Cases: For R =  or âˆ…, h(R) = R and h(L(R)) = L(R). For R = a, L(R) = {a} and
h(L(R)) = {h(a)} = L(h(a)) = L(h(R)). So claim holds.
â€¢ Induction Step: For R = R1 âˆª R2, observe that h(R) = h(R1) âˆª h(R2) and h(L(R)) =
h(L(R1) âˆª L(R2)) = h(L(R1)) âˆª h(L(R2)). By induction hypothesis, h(L(Ri)) = L(h(Ri))
and so h(L(R)) = L(h(R1) âˆª h(R2))
Other cases (R = R1R2 and R = R
âˆ—
1) similar.
1.3 Inverse Homomorphism
Inverse Homomorphism
Definition 13. Given homomorphism h : Î£âˆ— â†’ âˆ†âˆ— and L âŠ† âˆ†âˆ—, hâˆ’1(L) = {w âˆˆ Î£âˆ— | h(w) âˆˆ L}
hâˆ’1(L) consists of strings whose homomorphic images are in L
Î£âˆ— âˆ†âˆ—
h
hâˆ’1(L)
L
4
Inverse Homomorphism
Example 14. Let Î£ = {a, b}, and âˆ† = {0, 1}. Let L = (00 âˆª 1)âˆ— and h(a) = 01 and h(b) = 10.
â€¢ hâˆ’1(1001) = {ba}, hâˆ’1(010110) = {aab}
â€¢ hâˆ’1(L) = (ba)âˆ—
â€¢ What is h(hâˆ’1(L))? (1001)âˆ— ( L
Note: In general h(hâˆ’1(L)) âŠ† L âŠ† hâˆ’1(h(L)), but neither containment is necessarily an equal-
ity.
Closure under Inverse Homomorphism
Proposition 15. Regular languages are closed under inverse homomorphism, i.e., if L is regular
and h is a homomorphism then hâˆ’1(L) is regular.
Proof. We will use the representation of regular languages in terms of DFA to argue this.
Given a DFA M recognizing L, construct an DFA M â€² that accepts hâˆ’1(L)
â€¢ Intuition: On input w M â€² will run M on h(w) and accept if M does.
Closure under Inverse Homomorphism
â€¢ Intuition: On input w M â€² will run M on h(w) and accept if M does.
Example 16. L = L ((00 âˆª 1)âˆ—). h(a) = 01, h(b) = 10.
q0 q1
q2
1
0, 1
0
0
1a
b
b
a
a, b
Figure 1: Transitions of automaton M accepting language L is shown in gray. The transitions of
automaton accepting hâˆ’1(L) are shown in red.
5
Closure under Inverse Homomorphism
Formal Construction
â€¢ Let M = (Q,âˆ†, Î´, q0, F ) accept L âŠ† âˆ†âˆ— and let h : Î£âˆ— â†’ âˆ†âˆ— be a homomorphism
â€¢ Define M â€² = (Qâ€²,Î£, Î´â€², qâ€²0, F â€²), where
â€“ Qâ€² = Q
â€“ qâ€²0 = q0
â€“ F â€² = F , and
â€“ Î´â€²(q, a) = qâ€² where Î´Ë†M (q, h(a)) = {qâ€²}; M â€² on input a simulates M on h(a)
â€¢ M â€² accepts hâˆ’1(L) because âˆ€w. Î´Ë†M â€²(q0, w) = Î´Ë†M (q0, h(w)) (which you show by induction on
w).
2 Applications of Closure Properties
Example I
Definition 17. For a language L âŠ† Î£âˆ—, define suffix(L) = {v âˆˆ Î£âˆ— | âˆƒu âˆˆ Î£âˆ—. uv âˆˆ L}.
Proposition 18. Regular languages are closed under the suffix(Â·) operator. That is, if L is regular
then suffix(L) is also regular.
Proof. We present two possible proofs of this result.
Direct Construction: Since L is regular, there is a DFA M = (Q,Î£, Î´, q0, F ) that recognizes L.
We will construct an NFA N such that L(N) = suffix(L(M)) = suffix(L). Let us first spell out
what N needs to do in order to recognize suffix(L) â€” on input v, it needs to check if there is some
u such that uv âˆˆ L or uv is accepted by M . N will do this by simulating M on the input v, but
instead of starting from the initial state q0, it will first guess a state that M reaches on some string
u (such that uv âˆˆ L), and then simulate M on the input v. Formally, N = (Qâ€²,Î£, Î´â€², qâ€²0, F â€²) where
â€¢ Qâ€² = Q âˆª {qâ€²0}, where qâ€²0 6âˆˆ Q
â€¢ F â€² = F
â€¢ And Î´â€² is given by
Î´â€²(q, a) =
ï£±ï£²ï£³
Î´(q, a) if q âˆˆ Q
{q âˆˆ Q | âˆƒu. q0 uâˆ’â†’M q} if q = qâ€²0 and a = 
âˆ…
6
To complete the proof we need to argue that v is accepted by N iff v âˆˆ suffix(L(M)). Suppose v is
accepted by N . Since the only transitions out of the initial state qâ€²0 are -transitions, the accepting
computation of N on v looks like
qâ€²0
âˆ’â†’N q vâˆ’â†’N qâ€²
with qâ€² âˆˆ F â€² = F , and q being such that there is a u such that q0 uâˆ’â†’M q. In other words, we have
q0
uâˆ’â†’M q vâˆ’â†’M qâ€²
and so uv âˆˆ L(M) = L. Thus, v âˆˆ suffix(L). Conversely, suppose v âˆˆ suffix(L). Then there is u
such that uv âˆˆ L. Since M recognizes L, M accepts uv using a computation of the form
q0
uâˆ’â†’M q vâˆ’â†’M qâ€²
where q is some state in Q and qâ€² âˆˆ F . Then from the definition of N , we have a computation
qâ€²0
âˆ’â†’N q vâˆ’â†’N qâ€²
and since F â€² = F , v âˆˆ L(N). This completes the correctness proof of N .
Closure Properties: Another proof of the same result uses closure properties.
â€¢ For an alphabet Î£, let Î£Â¯ = {aÂ¯ | a âˆˆ Î£}.
â€¢ Define the homomorphisms unbar : (Î£ âˆª Î£Â¯)âˆ— â†’ Î£âˆ— and rembar : (Î£ âˆª Î£Â¯)âˆ— â†’ Î£âˆ— as
unbar(aÂ¯) = a for aÂ¯ âˆˆ Î£Â¯ unbar(a) = a for a âˆˆ Î£
rembar(aÂ¯) =  for aÂ¯ âˆˆ Î£Â¯ rembar(a) = a for a âˆˆ Î£
â€¢ Let L1 = unbarâˆ’1(L); since L is regular and regular languages are closed under inverse
homomorphisms, L1 is regular. L1 contains strings belonging to L which have some (or none)
of the letters annotated with a bar.
â€¢ Let L2 = L1 âˆ© Î£Â¯âˆ—Î£âˆ—; L2 is regular because regular languages are closed under intersection.
L2 is the set of strings from L where some of the first few letters have been annotated with
a bar.
â€¢ Observe that suffix(L) = rembar(L2). Thus suffix(L) is regular.
Example II
Let M = (Q,Î£, Î´, q0, F ) be a DFA. Consider
L = {w |M accepts w and M visits every state at least once on input w}
Is L regular?
Note that M does not necessarily accept all strings in L; L âŠ† L(M).
By applying a series of regularity preserving operations to L(M) we will construct L, thus
showing that L is regular
Computations: Valid and Invalid
7
â€¢ Consider an alphabet âˆ† consisting of [paq] where p, q âˆˆ Q, a âˆˆ Î£ and Î´(p, a) = q. So symbols
of âˆ† represent transitions of M .
â€¢ Let h : âˆ†â†’ Î£âˆ— be a homomorphism such that h([paq]) = a
â€¢ L1 = hâˆ’1(L(M)); L1 contains strings of L(M) where each symbol is associated with a pair
of states that represent some transition
â€“ Some strings of L1 represent valid computations of M . But there are also other strings
in L1 which do not correspond to valid computations of M
â€¢ We will first remove all the strings from L1 that correspond to invalid computations, and
then remove those that do not visit every state at least once.
Only Valid Computations
Strings of âˆ†âˆ— that represent valid computations of M satisfy the following conditions
â€¢ The first state in the first symbol must be q0
L2 = L1 âˆ© (([q0a1q1] âˆª [q0a2q2] âˆª Â· Â· Â· âˆª [q0akqk])âˆ†âˆ—)
([q0a1q1], . . . [q0akqk] are all the transitions out of q0 in M)
â€¢ The first state in one symbol must equal the second state in previous symbol
L3 = L2 \ (âˆ†âˆ—(
âˆ‘
q 6=r
[paq][rbs])âˆ†âˆ—)
Remove â€œinvalidâ€ sequences from L2. Difference of two regular languages is regular ( why?).
So L3 is regular.
â€¢ The second state of the last symbol must be in F . Holds trivially because L3 only contains
strings accepted by M
Example continued
So far, regular language L3 = set of strings in âˆ†
âˆ— that represent valid computations of M .
â€¢ Let Eq âŠ† âˆ† be the set of symbols where q appears neither as the first nor the second state.
Then Eâˆ—q is the set of strings where q never occurs.
â€¢ We remove from L3 those strings where some q âˆˆ Q never occurs
L4 = L3 \ (
â‹ƒ
qâˆˆQ
Eâˆ—q )
â€¢ Finally we discard the state components in L4
L = h(L4)
â€¢ Hence, L is regular.
8
2.1 In a nutshell . . .
Proving Regularity using Closure Properties
How can one show that L is a regular language?
â€¢ Construct a DFA or NFA or regular expression recognizing L
â€¢ Or, show that L can be obtained from known regular languages L1, L2, . . . Lk through regu-
larity preserving operations
A list of Regularity-Preserving Operations
Regular languages are closed under the following operations.
â€¢ Regular Expression operations
â€¢ Boolean operations: union, intersection, complement
â€¢ Homomorphism
â€¢ Inverse Homomorphism
(And several other operations...)
9
