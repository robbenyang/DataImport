1 Closure Properties
Closure Properties
• Recall that we can carry out operations on one or more languages to obtain a new language
• Very useful in studying the properties of one language by relating it to other (better under-
stood) languages
• Most useful when the operations are sophisticated, yet are guaranteed to preserve interesting
properties of the language.
• Today: A variety of operations which preserve regularity
– i.e., the universe of regular languages is closed under these operations
Definition 1. Regular Languages are closed under an operation op on languages if
L1, L2, . . . Ln regular =⇒ L = op(L1, L2, . . . Ln) is regular
1.1 Boolean Operators
Operations from Regular Expressions
Proposition 2. Regular Languages are closed under ∪, ◦ and ∗.
Proof. (Summarizing previous arguments.)
• L1, L2 regular =⇒ ∃ regexes R1, R2 s.t. L1 = L(R1) and L2 = L(R2).
– =⇒ L1 ∪ L2 = L(R1 ∪R2) =⇒ L1 ∪ L2 regular.
– =⇒ L1 ◦ L2 = L(R1 ◦R2) =⇒ L1 ◦ L2 regular.
– =⇒ L∗1 = L(R∗1) =⇒ L∗1 regular.
Closure Under Complementation
Proposition 3. Regular Languages are closed under complementation, i.e., if L is regular then
L = Σ∗ \ L is also regular.
Proof. • If L is regular, then there is a DFA M = (Q,Σ, δ, q0, F ) such that L = L(M).
• Then, M = (Q,Σ, δ, q0, Q \ F ) (i.e., switch accept and non-accept states) accepts L.
What happens if M (above) was an NFA?
Closure under ∩
1
Proposition 4. Regular Languages are closed under intersection, i.e., if L1 and L2 are regular
then L1 ∩ L2 is also regular.
Proof. Observe that L1 ∩ L2 = L1 ∪ L2. Since regular languages are closed under union and
complementation, we have
• L1 and L2 are regular
• L1 ∪ L2 is regular
• Hence, L1 ∩ L2 = L1 ∪ L2 is regular.
Is there a direct proof for intersection (yielding a smaller DFA)?
Cross-Product Construction
Let M1 = (Q1,Σ, δ1, q1, F1) and M2 = (Q2,Σ, δ2, q2, F2) be DFAs recognizing L1 and L2, respec-
tively.
Idea: Run M1 and M2 in parallel on the same input and accept if both M1 and M2 accept.
Consider M = (Q,Σ, δ, q0, F ) defined as follows
• Q = Q1 ×Q2
• q0 = 〈q1, q2〉
• δ(〈p1, p2〉, a) = 〈δ1(p1, a), δ2(p2, a)〉
• F = F1 × F2
M accepts L1 ∩ L2 (exercise)
What happens if M1 and M2 where NFAs? Still works! Set δ(〈p1, p2〉, a) = δ1(p1, a)×δ2(p2, a).
An Example
q00
q01
0 0
1
1
× =q10 q11
1
1
0 0 q00 q01
q10 q11
1
1
1
1
0 0 0 0
2
1.2 Homomorphisms
Homomorphism
Definition 5. A homomorphism is function h : Σ∗ → ∆∗ defined as follows:
• h() =  and for a ∈ Σ, h(a) is any string in ∆∗
• For a = a1a2 . . . an ∈ Σ∗ (n ≥ 2), h(a) = h(a1)h(a2) . . . h(an).
• A homomorphism h maps a string a ∈ Σ∗ to a string in ∆∗ by mapping each character of a
to a string h(a) ∈ ∆∗
• A homomorphism is a function from strings to strings that “respects” concatenation: for any
x, y ∈ Σ∗, h(xy) = h(x)h(y). (Any such function is a homomorphism.)
Example 6. h : {0, 1} → {a, b}∗ where h(0) = ab and h(1) = ba. Then h(0011) = ababbaba
Homomorphism as an Operation on Languages
Definition 7. Given a homomorphism h : Σ∗ → ∆∗ and a language L ⊆ Σ∗, define h(L) =
{h(w) | w ∈ L} ⊆ ∆∗.
Example 8. Let L = {0n1n |n ≥ 0} and h(0) = ab and h(1) = ba. Then h(L) = {(ab)n(ba)n |n ≥ 0}
Proposition 9. For any languages L1 and L2, the following hold: h(L1 ∪ L2) = h(L1) ∪ h(L2);
h(L1 ◦ L2) = h(L1) ◦ h(L2); and h(L∗1) = h(L1)∗.
Proof. Left as exercise.
Closure under Homomorphism
Proposition 10. Regular languages are closed under homomorphism, i.e., if L is a regular language
and h is a homomorphism, then h(L) is also regular.
Proof. We will use the representation of regular languages in terms of regular expressions to argue
this.
• Define homomorphism as an operation on regular expressions
• Show that L(h(R)) = h(L(R))
• Let R be such that L = L(R). Let R′ = h(R). Then h(L) = L(R′).
Homomorphism as an Operation on Regular Expressions
3
Definition 11. For a regular expression R, let h(R) be the regular expression obtained by replacing
each occurence of a ∈ Σ in R by the string h(a).
Example 12. If R = (0∪1)∗001(0∪1)∗ and h(0) = ab and h(1) = bc then h(R) = (ab∪bc)∗ababbc(ab∪
bc)∗
Formally h(R) is defined inductively as follows.
h(∅) = ∅ h(R1R2) = h(R1)h(R2)
h() =  h(R1 ∪R2) = h(R2) ∪ h(R2)
h(a) = h(a) h(R∗) = (h(R))∗
Proof of Claim
Claim
For any regular expression R, L(h(R)) = h(L(R)).
Proof. By induction on the number of operations in R
• Base Cases: For R =  or ∅, h(R) = R and h(L(R)) = L(R). For R = a, L(R) = {a} and
h(L(R)) = {h(a)} = L(h(a)) = L(h(R)). So claim holds.
• Induction Step: For R = R1 ∪ R2, observe that h(R) = h(R1) ∪ h(R2) and h(L(R)) =
h(L(R1) ∪ L(R2)) = h(L(R1)) ∪ h(L(R2)). By induction hypothesis, h(L(Ri)) = L(h(Ri))
and so h(L(R)) = L(h(R1) ∪ h(R2))
Other cases (R = R1R2 and R = R
∗
1) similar.
1.3 Inverse Homomorphism
Inverse Homomorphism
Definition 13. Given homomorphism h : Σ∗ → ∆∗ and L ⊆ ∆∗, h−1(L) = {w ∈ Σ∗ | h(w) ∈ L}
h−1(L) consists of strings whose homomorphic images are in L
Σ∗ ∆∗
h
h−1(L)
L
4
Inverse Homomorphism
Example 14. Let Σ = {a, b}, and ∆ = {0, 1}. Let L = (00 ∪ 1)∗ and h(a) = 01 and h(b) = 10.
• h−1(1001) = {ba}, h−1(010110) = {aab}
• h−1(L) = (ba)∗
• What is h(h−1(L))? (1001)∗ ( L
Note: In general h(h−1(L)) ⊆ L ⊆ h−1(h(L)), but neither containment is necessarily an equal-
ity.
Closure under Inverse Homomorphism
Proposition 15. Regular languages are closed under inverse homomorphism, i.e., if L is regular
and h is a homomorphism then h−1(L) is regular.
Proof. We will use the representation of regular languages in terms of DFA to argue this.
Given a DFA M recognizing L, construct an DFA M ′ that accepts h−1(L)
• Intuition: On input w M ′ will run M on h(w) and accept if M does.
Closure under Inverse Homomorphism
• Intuition: On input w M ′ will run M on h(w) and accept if M does.
Example 16. L = L ((00 ∪ 1)∗). h(a) = 01, h(b) = 10.
q0 q1
q2
1
0, 1
0
0
1a
b
b
a
a, b
Figure 1: Transitions of automaton M accepting language L is shown in gray. The transitions of
automaton accepting h−1(L) are shown in red.
5
Closure under Inverse Homomorphism
Formal Construction
• Let M = (Q,∆, δ, q0, F ) accept L ⊆ ∆∗ and let h : Σ∗ → ∆∗ be a homomorphism
• Define M ′ = (Q′,Σ, δ′, q′0, F ′), where
– Q′ = Q
– q′0 = q0
– F ′ = F , and
– δ′(q, a) = q′ where δˆM (q, h(a)) = {q′}; M ′ on input a simulates M on h(a)
• M ′ accepts h−1(L) because ∀w. δˆM ′(q0, w) = δˆM (q0, h(w)) (which you show by induction on
w).
2 Applications of Closure Properties
Example I
Definition 17. For a language L ⊆ Σ∗, define suffix(L) = {v ∈ Σ∗ | ∃u ∈ Σ∗. uv ∈ L}.
Proposition 18. Regular languages are closed under the suffix(·) operator. That is, if L is regular
then suffix(L) is also regular.
Proof. We present two possible proofs of this result.
Direct Construction: Since L is regular, there is a DFA M = (Q,Σ, δ, q0, F ) that recognizes L.
We will construct an NFA N such that L(N) = suffix(L(M)) = suffix(L). Let us first spell out
what N needs to do in order to recognize suffix(L) — on input v, it needs to check if there is some
u such that uv ∈ L or uv is accepted by M . N will do this by simulating M on the input v, but
instead of starting from the initial state q0, it will first guess a state that M reaches on some string
u (such that uv ∈ L), and then simulate M on the input v. Formally, N = (Q′,Σ, δ′, q′0, F ′) where
• Q′ = Q ∪ {q′0}, where q′0 6∈ Q
• F ′ = F
• And δ′ is given by
δ′(q, a) =

δ(q, a) if q ∈ Q
{q ∈ Q | ∃u. q0 u−→M q} if q = q′0 and a = 
∅
6
To complete the proof we need to argue that v is accepted by N iff v ∈ suffix(L(M)). Suppose v is
accepted by N . Since the only transitions out of the initial state q′0 are -transitions, the accepting
computation of N on v looks like
q′0
−→N q v−→N q′
with q′ ∈ F ′ = F , and q being such that there is a u such that q0 u−→M q. In other words, we have
q0
u−→M q v−→M q′
and so uv ∈ L(M) = L. Thus, v ∈ suffix(L). Conversely, suppose v ∈ suffix(L). Then there is u
such that uv ∈ L. Since M recognizes L, M accepts uv using a computation of the form
q0
u−→M q v−→M q′
where q is some state in Q and q′ ∈ F . Then from the definition of N , we have a computation
q′0
−→N q v−→N q′
and since F ′ = F , v ∈ L(N). This completes the correctness proof of N .
Closure Properties: Another proof of the same result uses closure properties.
• For an alphabet Σ, let Σ¯ = {a¯ | a ∈ Σ}.
• Define the homomorphisms unbar : (Σ ∪ Σ¯)∗ → Σ∗ and rembar : (Σ ∪ Σ¯)∗ → Σ∗ as
unbar(a¯) = a for a¯ ∈ Σ¯ unbar(a) = a for a ∈ Σ
rembar(a¯) =  for a¯ ∈ Σ¯ rembar(a) = a for a ∈ Σ
• Let L1 = unbar−1(L); since L is regular and regular languages are closed under inverse
homomorphisms, L1 is regular. L1 contains strings belonging to L which have some (or none)
of the letters annotated with a bar.
• Let L2 = L1 ∩ Σ¯∗Σ∗; L2 is regular because regular languages are closed under intersection.
L2 is the set of strings from L where some of the first few letters have been annotated with
a bar.
• Observe that suffix(L) = rembar(L2). Thus suffix(L) is regular.
Example II
Let M = (Q,Σ, δ, q0, F ) be a DFA. Consider
L = {w |M accepts w and M visits every state at least once on input w}
Is L regular?
Note that M does not necessarily accept all strings in L; L ⊆ L(M).
By applying a series of regularity preserving operations to L(M) we will construct L, thus
showing that L is regular
Computations: Valid and Invalid
7
• Consider an alphabet ∆ consisting of [paq] where p, q ∈ Q, a ∈ Σ and δ(p, a) = q. So symbols
of ∆ represent transitions of M .
• Let h : ∆→ Σ∗ be a homomorphism such that h([paq]) = a
• L1 = h−1(L(M)); L1 contains strings of L(M) where each symbol is associated with a pair
of states that represent some transition
– Some strings of L1 represent valid computations of M . But there are also other strings
in L1 which do not correspond to valid computations of M
• We will first remove all the strings from L1 that correspond to invalid computations, and
then remove those that do not visit every state at least once.
Only Valid Computations
Strings of ∆∗ that represent valid computations of M satisfy the following conditions
• The first state in the first symbol must be q0
L2 = L1 ∩ (([q0a1q1] ∪ [q0a2q2] ∪ · · · ∪ [q0akqk])∆∗)
([q0a1q1], . . . [q0akqk] are all the transitions out of q0 in M)
• The first state in one symbol must equal the second state in previous symbol
L3 = L2 \ (∆∗(
∑
q 6=r
[paq][rbs])∆∗)
Remove “invalid” sequences from L2. Difference of two regular languages is regular ( why?).
So L3 is regular.
• The second state of the last symbol must be in F . Holds trivially because L3 only contains
strings accepted by M
Example continued
So far, regular language L3 = set of strings in ∆
∗ that represent valid computations of M .
• Let Eq ⊆ ∆ be the set of symbols where q appears neither as the first nor the second state.
Then E∗q is the set of strings where q never occurs.
• We remove from L3 those strings where some q ∈ Q never occurs
L4 = L3 \ (
⋃
q∈Q
E∗q )
• Finally we discard the state components in L4
L = h(L4)
• Hence, L is regular.
8
2.1 In a nutshell . . .
Proving Regularity using Closure Properties
How can one show that L is a regular language?
• Construct a DFA or NFA or regular expression recognizing L
• Or, show that L can be obtained from known regular languages L1, L2, . . . Lk through regu-
larity preserving operations
A list of Regularity-Preserving Operations
Regular languages are closed under the following operations.
• Regular Expression operations
• Boolean operations: union, intersection, complement
• Homomorphism
• Inverse Homomorphism
(And several other operations...)
9
